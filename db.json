{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":0},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"de500cc92319da6a6f49c537f7b44fe17ae1a8b0","modified":1471160217000},{"_id":"source/CNAME","hash":"04fd89a19f7544726f6e3493b1a10c8c31a0cd82","modified":1460084153000},{"_id":"source/favicon.ico","hash":"fca12632f8626af6b5eaf8ef9ea6c76168705543","modified":1460096057000},{"_id":"source/apple-touch-icon.png","hash":"6e8ed37b398b87d2cefa7183acb1d30b31c937fb","modified":1460086737000},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1460084153000},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1460084153000},{"_id":"themes/maupassant/_config.yml","hash":"94b25e314e6f9e9945461a3c0754a264518d7cf5","modified":1460084153000},{"_id":"themes/maupassant/README.md","hash":"def832798496a6ad6a18e0ba2c7149571ded21a0","modified":1460084153000},{"_id":"source/_posts/java-core-conception.md","hash":"ca3810354745c50d292faa66250410a1121a32bd","modified":1461308056000},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1460084153000},{"_id":"source/_posts/hello-world.md","hash":"b78810952024e7c41042ef6ca547fb4aab17b023","modified":1461052545000},{"_id":"source/_posts/java-core-collections.md","hash":"71bf59cd1edea549e5be28f7431462cec30ba2ba","modified":1471160087000},{"_id":"source/_posts/java-core-io.md","hash":"abe3d2606043aa03f1522b0a98ba0e733a87d2b4","modified":1461053080000},{"_id":"source/_posts/java-core-jni.md","hash":"7f4553826bdbe663b6064b1e8970a75326e0d72b","modified":1460715008000},{"_id":"source/_posts/java-core-jni.md.bak","hash":"dc71d67f0aa0e3643cc7c55b73cc726576042d47","modified":1460538182000},{"_id":"source/_posts/java-core-nio.md","hash":"345cb1062edaea3d8767636e0d329282eef92c3c","modified":1461053004000},{"_id":"source/guestbook/index.md","hash":"7ffb6ae5218c7f74de626fad501e2a4edec052bf","modified":1460084153000},{"_id":"source/_posts/java-core-thread.md","hash":"b1bd8e92af4481a7eb0633b33b7cc03542c9a483","modified":1461837885000},{"_id":"source/_posts/java-core-object.md","hash":"4fc20bac35783a2f12aac5d02b8b9a694f470d6e","modified":1461641933000},{"_id":"source/about/index.md","hash":"a0cf903549dc894e19efd0fd22e10a760e791128","modified":1460084153000},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1460084153000},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1460084153000},{"_id":"source/history/index.md","hash":"e3473eb91ff8e00333e8a02cb1bf687e25d6800e","modified":1460084153000},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1460084153000},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1460084153000},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1460084153000},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1460084153000},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1460084153000},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1460084153000},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1460084153000},{"_id":"themes/maupassant/layout/base.jade","hash":"ce9e1efb5a039d785445d2c89ba33cb0967f21df","modified":1460084153000},{"_id":"themes/maupassant/layout/index.jade","hash":"ac74f4f7cee705693bf5977bbae074373acddb7c","modified":1460084153000},{"_id":"source/_posts/java-core-conception/conversion.png","hash":"73c641e9243447b956082b5f7f6b2956ea51c078","modified":1461289522000},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"00af53f447c04dc8ed7bbee544f05278edda0f60","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1460084153000},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"c53ac5e5d44fa99705ae0e212435095e493ea65e","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1460084153000},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1460084153000},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1460084153000},{"_id":"themes/maupassant/source/css/style.scss","hash":"810e09434428b2159a2898935bddb95d33d57400","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1460084153000},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1460084153000},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"92be822124e716a947bae3d676867e702933a93c","modified":1460084153000},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1460084153000},{"_id":"themes/maupassant/source/js/search.js","hash":"53db2eb255dd40a412ed62ea7332ca5a22f7816f","modified":1460084153000},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1460084153000},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1460084153000},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1460084153000},{"_id":"source/_posts/java-core-jni/jni.png","hash":"6912605ca2931de4421e351501c5b2f96404c5ad","modified":1460530988000},{"_id":"public/atom.xml","hash":"f7c7c930b45618f2aa1c688b704ec85363856212","modified":1471760375355},{"_id":"public/guestbook/index.html","hash":"24c7fbcdc24cf44234200eabe9fc76f8ded5003a","modified":1471160993598},{"_id":"public/history/index.html","hash":"44e7c5abef64971725ab439196a5e512496040a0","modified":1471160993598},{"_id":"public/about/index.html","hash":"7cb15b0a0ab597e49abfdc35d87e7b5efed10b63","modified":1471160993598},{"_id":"public/archives/index.html","hash":"43a0f20509bccc5d78058f06ebc0185c76eb6439","modified":1471160993599},{"_id":"public/archives/2016/index.html","hash":"3408ab2229f688fb01652a7a53e06218ec37076e","modified":1471160993599},{"_id":"public/categories/hexo/index.html","hash":"e00d49b80c96e2e09beb208aeeddc49eed9a458d","modified":1471160993599},{"_id":"public/archives/2016/04/index.html","hash":"ddabcc6cf346c6db888a303cd23dd21c84461492","modified":1471760375403},{"_id":"public/categories/java基础/index.html","hash":"8a6e8140cd9a9a3e84ff929b01565a2c9fc5ac81","modified":1471160993599},{"_id":"public/categories/Java基础/index.html","hash":"28562bb7946cdf3de74cb82a96b99b81dd5a9ef5","modified":1471160993599},{"_id":"public/index.html","hash":"14e48cc534d372f26f08cd6776c2c0276022a5ee","modified":1471160993599},{"_id":"public/tags/hexo/index.html","hash":"e00d49b80c96e2e09beb208aeeddc49eed9a458d","modified":1471160993601},{"_id":"public/tags/Java/index.html","hash":"4cce16051bebf41e321b9b897af357a892b8f384","modified":1471160993599},{"_id":"public/tags/jni/index.html","hash":"906d42e881984726716f1e03a2ab1582d4ed66bd","modified":1471160993601},{"_id":"public/tags/java/index.html","hash":"27ddc0362b68a8e3df2cd541193d68507550d4ee","modified":1471160993601},{"_id":"public/2016/04/14/java-core-object/index.html","hash":"c758890aed19e414e003c755e5ffdfda71d7936f","modified":1471160993602},{"_id":"public/2016/04/13/java-core-jni/index.html","hash":"15e80506b4ceb09dd7225733a96215a107b35837","modified":1471160993602},{"_id":"public/2016/04/06/hello-world/index.html","hash":"c26d76a541bba51aac0de9b4063a61e2733a79e8","modified":1471760375403},{"_id":"public/2016/04/19/java-core-collections/index.html","hash":"091cdecae472219974e697c0c6d58793c4dd8536","modified":1471160993601},{"_id":"public/2016/04/19/java-core-nio/index.html","hash":"55b0fdf58a9bca29dc791be0e43322fbee6bd4ad","modified":1471160993598},{"_id":"public/2016/04/19/java-core-io/index.html","hash":"21014978ebdc87e22c00ffb48704c22ab258a39f","modified":1471160993598},{"_id":"public/categories/Java总结/index.html","hash":"9b50cb838241e777a39fc70c997c89f115005f96","modified":1471160993599},{"_id":"public/tags/集合/index.html","hash":"cbd81d04f66271f8d93950d4d1971b8250703216","modified":1471160993601},{"_id":"public/tags/io/index.html","hash":"de67048e093015cfd0b4e601d97aa3b268510d04","modified":1471160993601},{"_id":"public/tags/多线程/index.html","hash":"109cd6c38d633d18bace807dcfbb08c9af6a2072","modified":1471160993601},{"_id":"public/tags/nio/index.html","hash":"393f23a9ee3aec7157ef2a212f8df24d876dec9b","modified":1471160993601},{"_id":"public/2016/04/19/java-core-conception/index.html","hash":"c10b2fa59a5725007ddb3a396d2102911ddd44da","modified":1471160993601},{"_id":"public/2016/04/19/java-core-thread/index.html","hash":"3e4fac6fe44611e1fde04f63392d90e155b1bef1","modified":1471160993602},{"_id":"public/2016/04/19/java-core-conception/conversion.png","hash":"73c641e9243447b956082b5f7f6b2956ea51c078","modified":1461838057600},{"_id":"source/_posts/hadoop-trouble-shooting.md","hash":"c45499a6c4e941665e9a475c7adb734e9be6ad11","modified":1471160086000},{"_id":"source/_posts/js-trouble-shooting.md","hash":"d4eb44de1368b28b4aea10259414a51882a42a4c","modified":1471160086000},{"_id":"source/_posts/hive-params.md","hash":"318dd0472012eb89d987fa66699237f92a7b1760","modified":1471160086000},{"_id":"source/_posts/mysql-tips.md","hash":"8b965d300ca4aaf2a67fde6a423d937a616d1a33","modified":1471160086000},{"_id":"public/2016/08/09/js-trouble-shooting/index.html","hash":"3f5ca1f88647187a41954de11b6b319a4f3042d7","modified":1471160993609},{"_id":"public/2016/08/09/mysql-tips/index.html","hash":"1742be16245dfebccfe90f6e9e933b00b0489db0","modified":1471160993609},{"_id":"public/2016/07/15/hive-params/index.html","hash":"87e4e3de21666cb8e1b176202e904ff37dd00ea5","modified":1471160993610},{"_id":"public/categories/hadoop/index.html","hash":"4cddb9b09e7ac44a1ac0f0185e1826c1b67ca50b","modified":1471160993610},{"_id":"public/categories/js/index.html","hash":"e7009e34e1216d8ad7ebc0c1e63264b0b2103ca6","modified":1471160993610},{"_id":"public/categories/hive/index.html","hash":"ff8ab1c7ab97e4a611951a3605e4503edd8ab0e1","modified":1471760375403},{"_id":"public/categories/mysql/index.html","hash":"891417d46741a12d479311a13d3e7413f7aa5c3a","modified":1471160993611},{"_id":"public/archives/page/2/index.html","hash":"f3c490792a4136a0eb0d4a5004b824693b13c0de","modified":1471760375402},{"_id":"public/archives/2015/index.html","hash":"698f95039173d07256b833967dc395f33c7cd67c","modified":1471160993611},{"_id":"public/archives/2015/02/index.html","hash":"698f95039173d07256b833967dc395f33c7cd67c","modified":1471160993611},{"_id":"public/archives/2016/page/2/index.html","hash":"82f26aa73d8dc419e500b3ed049be015ddc03913","modified":1471760375402},{"_id":"public/archives/2016/07/index.html","hash":"743ac82fca272b408af098b6847e37fa542d4385","modified":1471160993611},{"_id":"public/archives/2016/08/index.html","hash":"04f98dfaaad21ab245731cb4c6e3db615ed7b32e","modified":1471160993611},{"_id":"public/page/2/index.html","hash":"66160c29b714a8e4149149a7c695b7111f1e99bd","modified":1471760375403},{"_id":"public/tags/hadoop-hive/index.html","hash":"ca05e2f5556c9a17f7eb166a43f09f27c0bc665a","modified":1471160993611},{"_id":"public/tags/js/index.html","hash":"e7009e34e1216d8ad7ebc0c1e63264b0b2103ca6","modified":1471160993612},{"_id":"public/tags/hive/index.html","hash":"ff8ab1c7ab97e4a611951a3605e4503edd8ab0e1","modified":1471760375403},{"_id":"public/tags/mysql/index.html","hash":"891417d46741a12d479311a13d3e7413f7aa5c3a","modified":1471160993612},{"_id":"public/2015/02/14/hadoop-trouble-shooting/index.html","hash":"f7611f722770a4d28a448a374e364f6cfab71286","modified":1471760375404},{"_id":"source/_posts/hive-language-manual.md","hash":"b15c5b7c6b3ed2e820958a5f1ee39cbfeaa2c907","modified":1471759635000},{"_id":"public/2016/04/06/hive-language-manual/index.html","hash":"abcca28e0b49ab5739beacdce4ca782b1383c8b1","modified":1471760375404}],"Category":[{"name":"Java总结","_id":"cinb2xt6s0003bgv0s5pcplpe"},{"name":"hexo","_id":"cinb2xt6v0005bgv04uyz4yhs"},{"name":"java基础","_id":"cinb2xtmf000fbgv0d8cgqndc"},{"name":"Java基础","_id":"cinb2xtn2000lbgv0vbkerpuw"},{"name":"hadoop","_id":"cirub9ogw0003g7v0luxeqffg"},{"name":"js","_id":"cirub9oh30007g7v06r2ikfap"},{"name":"hive","_id":"cirub9oh5000bg7v05pw18rsc"},{"name":"mysql","_id":"cirub9oh7000fg7v01tb3fx7x"}],"Data":[],"Page":[{"title":"留言板","date":"2016-04-07T03:33:49.000Z","_content":"欢迎大家留言！\n","source":"guestbook/index.md","raw":"---\ntitle: 留言板\ndate: 2016-04-07 11:33:49\n---\n欢迎大家留言！\n","updated":"2016-04-08T02:55:53.000Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"cinb2xtm4000bbgv0ymx9fiec","content":"<p>欢迎大家留言！</p>\n","excerpt":"","more":"<p>欢迎大家留言！</p>\n"},{"title":"关于我","date":"2016-04-07T03:31:44.000Z","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2016-04-07 11:31:44\ncomments: false\n---\n","updated":"2016-04-08T02:55:53.000Z","path":"about/index.html","layout":"page","_id":"cinb2xtmc000dbgv0m1lser1g","content":"","excerpt":"","more":""},{"title":"时间轴","date":"2016-04-07T07:12:10.000Z","comments":0,"_content":"<div class=\"timeline\">\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">\n\t\t\t注册域名jackalope.cn\n\t\t</div>\n\t</div>\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div>\n\t</div>\n</div>","source":"history/index.md","raw":"---\ntitle: 时间轴\ndate: 2016-04-07 15:12:10\ncomments: false\n---\n<div class=\"timeline\">\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">\n\t\t\t注册域名jackalope.cn\n\t\t</div>\n\t</div>\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div>\n\t</div>\n</div>","updated":"2016-04-08T02:55:53.000Z","path":"history/index.html","layout":"page","_id":"cinb2xtmm000hbgv0n3zprehr","content":"<div class=\"timeline\"><br>    <div class=\"timeline-item active\"><br>        <div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div><br>        <div class=\"info\"><br>            注册域名jackalope.cn<br>        </div><br>    </div><br>    <div class=\"timeline-item active\"><br>        <div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div><br>        <div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div><br>    </div><br></div>","excerpt":"","more":"<div class=\"timeline\"><br>    <div class=\"timeline-item active\"><br>        <div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div><br>        <div class=\"info\"><br>            注册域名jackalope.cn<br>        </div><br>    </div><br>    <div class=\"timeline-item active\"><br>        <div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div><br>        <div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div><br>    </div><br></div>"}],"Post":[{"title":"Java总结 - 基本概念","date":"2016-04-19T08:28:53.000Z","toc":true,"_content":"\n本文主要介绍一些Java中的基本概念，包括数据类型、变量、运算符、字符串、输入输出、控制流程、大数值、数组。\n\n# 数据类型\n\nJava是一种强类型语言，必须为每一个变量声明一种类型。Java中一共有8种基本类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符型char、1种用于表示真值的boolean型。\n\n## 整型\n\n类型|存储需求|后缀\n--|--|--\nint|4字节|无\nshort|2字节|无\nlong|8字节|L,如1000000000L\nbyte|1字节|无\n\n前缀：16进制0x，8进制0，如100的16进制为0x64，8进制为0144，从Java7开始，加上前缀0b就可以写二进制数，`并且，从Java7开始，可以为数字中加下划线，如：int i = 1_0_0`如下：\n\n```\nint i = 1_0_0;\nint i16 = 0x64;\nint i8 = 0144;\nint i2 = 0b1100100;\nSystem.out.println(i16 == i && i8 == i && i2 == i);\n```\n\n结果为true。\n\n## 浮点型\n\n类型|存储需求|后缀\n--|--|--\nfloat|4字节|F,如12.3F\ndouble|8字节|D,如12345678.9D\n\n三个特殊的浮点数值：\n1. 正无穷，Float.POSITIVE_INFINITY/Double.POSITIVE_INFINITY\n2. 负无穷，Float.NEGATIVE_INFINITY/Double.NEGATIVE_INFINITY\n3. NaN(非数字), Float.NaN/Double.NaN\n\n`\n注意：不能这样检测一个特定值是否等于Double.NaN\nif(x == Double.NaN) // is never true\n所有\"非数值\"的值都认为是不同的，应该使用：\nif(Double.isNan(x)) // check whether x is \"not a number\"\n`\n\n`警告：浮点型不适用于禁止出现舍入误差的金融计算中，如果需要在数值计算中不含有任何舍入误差，应该使用BigDecimal类。`\n\n## char型\n\nchar表示单个Unicode编码的字符。Unicode编码单元可以表示为16进制，其范围从\\U0000到\\Uffff。\n\n# 变量\n\r* 在Java中，每一个变量属于一种类型。\r* 变量名必须是以字母开头的由字母或数字构成的序列，不可使用保留字。\r* 可以在一行中声明多个变量，但不提倡这样做，逐一声明每一个变量可以提高程序的可读性。\r* 使用final关键字表示常量——只能被赋值一次，一旦被赋值后，就不能够再更改了。\r\r# 运算符\n\r## 算术运算符\n\r符号|含义\n-|-\n+|加\n-|减\n*|乘\n/|除\r\r* 写法：x = x + 2;\r* 简化格式：x += 2;\r* 自增/自减运算：n++（先用后加）/++n（先加后用）；自减运算：n--（先用后减）/--n（先减后用）。\r\r`使用strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果，如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。`\n\n## 逻辑运算符\n\n符号|含义\n-|-\n\\>|大于\n<|小于\n\\>=|大于等于\n<=|小于等于\n==|等于\n!=|非等于\n&&|与\n&#124;&#124;|或\n!|非\n\r## 位运算\n\n符号|含义\n-|-\n&|与\n&#124;|或\n!|非\r\\>>|右移位，可以用来屏蔽低位，或进行2的倍数计算，如8>>3 == 1，计算过程：转化为2进制即0b1000>>3，为2进制0b0001；\n<<|左移位，可以用来屏蔽高们，或进行2的倍数计算，如1<<3 == 8，计算过程：转化为2进制即0b0001<<3，为2进制0b1000;\n\\>>>|右移位，用0填充高位，与>>的区别在于：>>用符号位填充高位；没有<<<运算符。\n\n注意：对移位运算符右侧的参数需要进行模32的运算（如果左侧的操作数是long类型，则需要模64。）\r\r## 数学函数\n\nMath类中包含了各种各样的数学函数，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，需要使用`StrictMath`类，它使用“自由发布的Math库”(fdlibm)实现算法，以确保所有平台上得到相同的结果。\n\r## 数值类型间的转换\n\n![](conversion.png)\n\r当数值进行运算时，需要先将两个操作数转换为同一种类型，遵循如下原则：\r如果存在double，则转换成double；\r否则，如果存在float，则转换成float；\r否则，如果存在long，则转换成long；\r否则，都转换成int；\r\r## 强制类型转换\n\n如：double d = 1.234; int i = (int)d; i的值为1；强制类型转换通过截断小数部分将浮点值转换为整型。\n\n`注意：如果将一个数值强制转换成另一个类型，而又超出了目标类型的表示范围，结果会截断成一个完全不同的值。如：(byte)300 == 44。`\n\r## 括号与运算符级别\n\r括号优先，无括号的按照优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（右结合运算符按照从右到左进行计算。）。\r\r## 枚举型\n\r变量的取值只在一个有限的集合内，如enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};\r\r# 字符串\n\rJava字符串就是Unicode的字符序列。\r\r* 赋值：String string = \"string\";\r* 子串：String subStr = string.substring(0,3);从0开始，截取长度为3的字符串；\r* 拼接：使用+号将两个字符串拼接；\r\r`\r==判断两个String对象是否放在同一个位置上。\nequals判断两个String对象的值是否相等。\n`\n\r\"\"与null是不相同的概念，null表示空对象，\"\"表示字符串为空值。\n\r`注意，尽量不使用char型，原因是：在使用辅助字符时，由于辅助字符会占用两个代码单元，所以会导致charAt()方法得不到想要的结果。`\n\r## 深入理解\n\r`对String对象的任何改变都会生成新的对象。`\n\r```\nString str1 = \"string\";\nString str2 = \"string\";\nString str3 = new String(\"string\");\nString str4 = new String(\"string\");\nSystem.out.println(str1 == str2);\nSystem.out.println(str2 == str3);\nSystem.out.println(str3 == str4);\r```\n以上代码的输出结果是：\ntrue\nfalse\nfalse\n\n这是因为JVM引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接指向已经存在的字面常量；否则，开辟一个空间来存储该字面常量，并指向该指面常量。所以str1 == str2返回为true。\n而使用new关键字来创建的对象都是在堆区进行的，不会去检测对象是否已经存在。因此，通过new创建的对象，一定是不相同的。\r\r`String、StringBuilder、StringBuffer都是final类，这意味着它们不能被继承，也它们的所有方法都是final方法，即方法不能被覆盖。在需要进行大量的字符串拼接操作时，使用StringBuilder与StringBuffer的效率比String类要高，StringBuilder类非线程安全，StringBuffer类线程安全。`\n\n直接使用String类进行拼接：\n```\npublic class StringStudy {\n    public static void main(String args[]) {\n        String str = \"str\";\n        str += \"ing\";\n    }\n}\n```\n\nStringBuilder与StringBuffer都继承自AbstractStringBuilder，拼接操作都调用的是AbstractStringBuilder类中的append方法，所以这里只使用StringBuilder来与String进行比较：\n```\npublic class StringBuilderStudy {\n    public static void main(String args[]) {\n        StringBuilder sb = new StringBuilder(\"str\");\n        sb.append(\"ing\");\n    }\n}\n```\n使用javap -c查看两段代码的字节码分别如下：\n\n```\nCompiled from \"StringStudy.java\"\npublic class org.jackalope.study.lang.StringStudy {\n  public org.jackalope.study.lang.StringStudy();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: ldc           #2                  // String str\n       2: astore_1\n       3: new           #3                  // class java/lang/StringBuilder\n       6: dup\n       7: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n      10: aload_1\n      11: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      14: ldc           #6                  // String ing\n      16: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      19: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n      22: astore_1\n      23: return\n}\n```\n\n```\nCompiled from \"StringBuilderStudy.java\"\npublic class org.jackalope.study.lang.StringBuilderStudy {\n  public org.jackalope.study.lang.StringBuilderStudy();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/StringBuilder\n       3: dup\n       4: ldc           #3                  // String str\n       6: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":(Ljava/lang/String;)V\n       9: astore_1\n      10: aload_1\n      11: ldc           #5                  // String ing\n      13: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      16: pop\n      17: return\n}\n```\n\n可以看出，String的拼接操作是创建一个StringBuilder对象，并调用append方法来实现的，所以效率上一定比不上直接使用StringBuilder。\n\r# 输入输出\n\r简单介绍一下，详情请见[Java总结 - IO](java-core-io)与[Java总结 - NIO](java-core-nio)\rSystem.in输入流\rSystem.out输出流\rJava 6引入了Console类实现从控制台读取密码，用法如下：\r```\rConsole console = System.console();\rString username = console.readLine(\"User name:\");\rchar[] passwd = console.readPassword(\"Password:\");\r```\r## 格式化输出\n\r转称符|类型\n-|-\r%d|十进制整数\r%x|十六进制整数\r%o|八进制整数\r%f|定点浮点数\r%e|指数浮点数\r%g|通用浮点数\r%a|十六进制浮点数\r%s|字符串\r%c|字符\r%b|布尔型\r%h|散列码\r%tx|日期时间\r%%|百分号\r%n|行分隔符\r\r# 控制流程\n\r## 块作用域\n\r以一对花括号{}括起来的若干条Java语句称为块，一个块可以嵌套在另一个块中，不能在嵌套的两个块中声明同名的变量。\n\r## 条件语句\n\r格式\r* if(condition) statement\r* if(condition) statement1 else statement2\r* if(condition1) statement1 else if(condition2) statement2 else statement3\n* switch\t//多重选择\n\r## 循环语句\n\r* while(condition) statement\r* do statement while(condition) // 先执行一次再判断条件进行循环\r* for(define; condition; statement) statement\r* for(variable : collection) statement // for each\r\r## 中断控制流程语句\n\r* break：跳出并退出循环\r* 带标签的break：用于跳出多重嵌套的循环，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号，如下：\rlabel:\rwhile(...){\r...\rwhille(...){\r...\rbreak label;\r}\r}\r* continue : 跳出并继续循环\r\r# 大数值\n\rBigInteger和BigDecimal可以处理包含任意长度数字序列的数值。BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。\n\n方法|含义\n-|-\radd|加\rsubtract|减\rmultiply|乘\rdivide|除\rmod|取模\r\r# 数组\n\r数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标可以访问数组中的每一个值，数组下标从0开始。\n\r* 声明数组：int[] a;\r* 定义数组：int[] a = new int[100];所有元素初始化为0；\rString[] sa = new String[100];所有元素初始化为null；\r\r一旦创建了数组，就不能再改变它的大小 ，如果需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 —— array list。\n\n## Arrays类\n\nArrays类是JDK提供的一个工具类，方便对数组进行操作（比如排序和搜索），还包含一个允许将数组作为列表来查看的静态工厂。\n\n* asList(T... a):返回一个受指定数组支持的固定大小的列表。\n* binarySearch:一系列查找的方法，以byte型为例(其他类型类推)；\nbinarySearch(byte[] a, byte key):使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。\nbinarySearch(byte[] a, int fromIndex, int toIndex, byte key):使用二分搜索法来搜索指定的 byte 型数组的范围，以获得指定的值。\rcopyOf:一系列拷贝的方法，以byte型为例(其他类型类推)；\ncopyOf(byte[] original, int newLength):复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。\n* copyOfRange:一系列指定范围的拷贝方法，以byte型为例(其他类型类推)；\ncopyOfRange(byte[] original, int from, int to):将指定数组的指定范围复制到一个新数组。\n* deepEquals(Object[] a1, Object[] a2) :如果两个指定数组彼此是深层相等的，则返回true。\n* deepHashCode(Object[] a) :基于指定数组的“深层内容”返回哈希码。\n* deepToString(Object[] a) :返回指定数组“深层内容”的字符串表示形式。\n* equals:一系列判断数组是否相等的方法，以byte型为例（其他类型类推）；\nequals(byte[] a, byte[] a2):如果两个指定的 byte 型数组彼此相等，则返回 true。\n* fill:一系列填充数组的方法，以byte型为例（其他类型类推）；\nfill(byte[] a, byte val):将指定的 byte 值分配给指定 byte 节型数组的每个元素。\nfill(byte[] a, int fromIndex, int toIndex, byte val):将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。\n* hashCode:一系列返回指定数组哈希码的方法，以byte型为例（其他类型类推）;hashCode(byte[] a) \n* sort:一系列对指定数组排序的方法，以byte型为例（其他类型类推）;\nsort(byte[] a):对指定的 byte 型数组按数字升序进行排序。\nsort(byte[] a, int fromIndex, int toIndex):对指定 byte 型数组的指定范围按数字升序进行排序。\n* toString:一系列得到指定数组内容的字符串表示形式的方法，以byte型为例（其他类型类推）;toString(byte[] a) 。\r\r## 多维数组\n\n即数组的数组，如下：\n\n```\n        int[][] a = {\n                {11, 12, 13},\n                {21, 22, 23},\n                {31, 32, 33},\n        };\r```\n\n","source":"_posts/java-core-conception.md","raw":"---\ntitle: Java总结 - 基本概念\ndate: 2016-04-19 16:28:53\ntoc: true\ntags:\n- Java\ncategories:\n- Java总结\n\n---\n\n本文主要介绍一些Java中的基本概念，包括数据类型、变量、运算符、字符串、输入输出、控制流程、大数值、数组。\n\n# 数据类型\n\nJava是一种强类型语言，必须为每一个变量声明一种类型。Java中一共有8种基本类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符型char、1种用于表示真值的boolean型。\n\n## 整型\n\n类型|存储需求|后缀\n--|--|--\nint|4字节|无\nshort|2字节|无\nlong|8字节|L,如1000000000L\nbyte|1字节|无\n\n前缀：16进制0x，8进制0，如100的16进制为0x64，8进制为0144，从Java7开始，加上前缀0b就可以写二进制数，`并且，从Java7开始，可以为数字中加下划线，如：int i = 1_0_0`如下：\n\n```\nint i = 1_0_0;\nint i16 = 0x64;\nint i8 = 0144;\nint i2 = 0b1100100;\nSystem.out.println(i16 == i && i8 == i && i2 == i);\n```\n\n结果为true。\n\n## 浮点型\n\n类型|存储需求|后缀\n--|--|--\nfloat|4字节|F,如12.3F\ndouble|8字节|D,如12345678.9D\n\n三个特殊的浮点数值：\n1. 正无穷，Float.POSITIVE_INFINITY/Double.POSITIVE_INFINITY\n2. 负无穷，Float.NEGATIVE_INFINITY/Double.NEGATIVE_INFINITY\n3. NaN(非数字), Float.NaN/Double.NaN\n\n`\n注意：不能这样检测一个特定值是否等于Double.NaN\nif(x == Double.NaN) // is never true\n所有\"非数值\"的值都认为是不同的，应该使用：\nif(Double.isNan(x)) // check whether x is \"not a number\"\n`\n\n`警告：浮点型不适用于禁止出现舍入误差的金融计算中，如果需要在数值计算中不含有任何舍入误差，应该使用BigDecimal类。`\n\n## char型\n\nchar表示单个Unicode编码的字符。Unicode编码单元可以表示为16进制，其范围从\\U0000到\\Uffff。\n\n# 变量\n\r* 在Java中，每一个变量属于一种类型。\r* 变量名必须是以字母开头的由字母或数字构成的序列，不可使用保留字。\r* 可以在一行中声明多个变量，但不提倡这样做，逐一声明每一个变量可以提高程序的可读性。\r* 使用final关键字表示常量——只能被赋值一次，一旦被赋值后，就不能够再更改了。\r\r# 运算符\n\r## 算术运算符\n\r符号|含义\n-|-\n+|加\n-|减\n*|乘\n/|除\r\r* 写法：x = x + 2;\r* 简化格式：x += 2;\r* 自增/自减运算：n++（先用后加）/++n（先加后用）；自减运算：n--（先用后减）/--n（先减后用）。\r\r`使用strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果，如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。`\n\n## 逻辑运算符\n\n符号|含义\n-|-\n\\>|大于\n<|小于\n\\>=|大于等于\n<=|小于等于\n==|等于\n!=|非等于\n&&|与\n&#124;&#124;|或\n!|非\n\r## 位运算\n\n符号|含义\n-|-\n&|与\n&#124;|或\n!|非\r\\>>|右移位，可以用来屏蔽低位，或进行2的倍数计算，如8>>3 == 1，计算过程：转化为2进制即0b1000>>3，为2进制0b0001；\n<<|左移位，可以用来屏蔽高们，或进行2的倍数计算，如1<<3 == 8，计算过程：转化为2进制即0b0001<<3，为2进制0b1000;\n\\>>>|右移位，用0填充高位，与>>的区别在于：>>用符号位填充高位；没有<<<运算符。\n\n注意：对移位运算符右侧的参数需要进行模32的运算（如果左侧的操作数是long类型，则需要模64。）\r\r## 数学函数\n\nMath类中包含了各种各样的数学函数，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，需要使用`StrictMath`类，它使用“自由发布的Math库”(fdlibm)实现算法，以确保所有平台上得到相同的结果。\n\r## 数值类型间的转换\n\n![](conversion.png)\n\r当数值进行运算时，需要先将两个操作数转换为同一种类型，遵循如下原则：\r如果存在double，则转换成double；\r否则，如果存在float，则转换成float；\r否则，如果存在long，则转换成long；\r否则，都转换成int；\r\r## 强制类型转换\n\n如：double d = 1.234; int i = (int)d; i的值为1；强制类型转换通过截断小数部分将浮点值转换为整型。\n\n`注意：如果将一个数值强制转换成另一个类型，而又超出了目标类型的表示范围，结果会截断成一个完全不同的值。如：(byte)300 == 44。`\n\r## 括号与运算符级别\n\r括号优先，无括号的按照优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（右结合运算符按照从右到左进行计算。）。\r\r## 枚举型\n\r变量的取值只在一个有限的集合内，如enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};\r\r# 字符串\n\rJava字符串就是Unicode的字符序列。\r\r* 赋值：String string = \"string\";\r* 子串：String subStr = string.substring(0,3);从0开始，截取长度为3的字符串；\r* 拼接：使用+号将两个字符串拼接；\r\r`\r==判断两个String对象是否放在同一个位置上。\nequals判断两个String对象的值是否相等。\n`\n\r\"\"与null是不相同的概念，null表示空对象，\"\"表示字符串为空值。\n\r`注意，尽量不使用char型，原因是：在使用辅助字符时，由于辅助字符会占用两个代码单元，所以会导致charAt()方法得不到想要的结果。`\n\r## 深入理解\n\r`对String对象的任何改变都会生成新的对象。`\n\r```\nString str1 = \"string\";\nString str2 = \"string\";\nString str3 = new String(\"string\");\nString str4 = new String(\"string\");\nSystem.out.println(str1 == str2);\nSystem.out.println(str2 == str3);\nSystem.out.println(str3 == str4);\r```\n以上代码的输出结果是：\ntrue\nfalse\nfalse\n\n这是因为JVM引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接指向已经存在的字面常量；否则，开辟一个空间来存储该字面常量，并指向该指面常量。所以str1 == str2返回为true。\n而使用new关键字来创建的对象都是在堆区进行的，不会去检测对象是否已经存在。因此，通过new创建的对象，一定是不相同的。\r\r`String、StringBuilder、StringBuffer都是final类，这意味着它们不能被继承，也它们的所有方法都是final方法，即方法不能被覆盖。在需要进行大量的字符串拼接操作时，使用StringBuilder与StringBuffer的效率比String类要高，StringBuilder类非线程安全，StringBuffer类线程安全。`\n\n直接使用String类进行拼接：\n```\npublic class StringStudy {\n    public static void main(String args[]) {\n        String str = \"str\";\n        str += \"ing\";\n    }\n}\n```\n\nStringBuilder与StringBuffer都继承自AbstractStringBuilder，拼接操作都调用的是AbstractStringBuilder类中的append方法，所以这里只使用StringBuilder来与String进行比较：\n```\npublic class StringBuilderStudy {\n    public static void main(String args[]) {\n        StringBuilder sb = new StringBuilder(\"str\");\n        sb.append(\"ing\");\n    }\n}\n```\n使用javap -c查看两段代码的字节码分别如下：\n\n```\nCompiled from \"StringStudy.java\"\npublic class org.jackalope.study.lang.StringStudy {\n  public org.jackalope.study.lang.StringStudy();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: ldc           #2                  // String str\n       2: astore_1\n       3: new           #3                  // class java/lang/StringBuilder\n       6: dup\n       7: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":()V\n      10: aload_1\n      11: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      14: ldc           #6                  // String ing\n      16: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      19: invokevirtual #7                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;\n      22: astore_1\n      23: return\n}\n```\n\n```\nCompiled from \"StringBuilderStudy.java\"\npublic class org.jackalope.study.lang.StringBuilderStudy {\n  public org.jackalope.study.lang.StringBuilderStudy();\n    Code:\n       0: aload_0\n       1: invokespecial #1                  // Method java/lang/Object.\"<init>\":()V\n       4: return\n\n  public static void main(java.lang.String[]);\n    Code:\n       0: new           #2                  // class java/lang/StringBuilder\n       3: dup\n       4: ldc           #3                  // String str\n       6: invokespecial #4                  // Method java/lang/StringBuilder.\"<init>\":(Ljava/lang/String;)V\n       9: astore_1\n      10: aload_1\n      11: ldc           #5                  // String ing\n      13: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;\n      16: pop\n      17: return\n}\n```\n\n可以看出，String的拼接操作是创建一个StringBuilder对象，并调用append方法来实现的，所以效率上一定比不上直接使用StringBuilder。\n\r# 输入输出\n\r简单介绍一下，详情请见[Java总结 - IO](java-core-io)与[Java总结 - NIO](java-core-nio)\rSystem.in输入流\rSystem.out输出流\rJava 6引入了Console类实现从控制台读取密码，用法如下：\r```\rConsole console = System.console();\rString username = console.readLine(\"User name:\");\rchar[] passwd = console.readPassword(\"Password:\");\r```\r## 格式化输出\n\r转称符|类型\n-|-\r%d|十进制整数\r%x|十六进制整数\r%o|八进制整数\r%f|定点浮点数\r%e|指数浮点数\r%g|通用浮点数\r%a|十六进制浮点数\r%s|字符串\r%c|字符\r%b|布尔型\r%h|散列码\r%tx|日期时间\r%%|百分号\r%n|行分隔符\r\r# 控制流程\n\r## 块作用域\n\r以一对花括号{}括起来的若干条Java语句称为块，一个块可以嵌套在另一个块中，不能在嵌套的两个块中声明同名的变量。\n\r## 条件语句\n\r格式\r* if(condition) statement\r* if(condition) statement1 else statement2\r* if(condition1) statement1 else if(condition2) statement2 else statement3\n* switch\t//多重选择\n\r## 循环语句\n\r* while(condition) statement\r* do statement while(condition) // 先执行一次再判断条件进行循环\r* for(define; condition; statement) statement\r* for(variable : collection) statement // for each\r\r## 中断控制流程语句\n\r* break：跳出并退出循环\r* 带标签的break：用于跳出多重嵌套的循环，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号，如下：\rlabel:\rwhile(...){\r...\rwhille(...){\r...\rbreak label;\r}\r}\r* continue : 跳出并继续循环\r\r# 大数值\n\rBigInteger和BigDecimal可以处理包含任意长度数字序列的数值。BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。\n\n方法|含义\n-|-\radd|加\rsubtract|减\rmultiply|乘\rdivide|除\rmod|取模\r\r# 数组\n\r数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标可以访问数组中的每一个值，数组下标从0开始。\n\r* 声明数组：int[] a;\r* 定义数组：int[] a = new int[100];所有元素初始化为0；\rString[] sa = new String[100];所有元素初始化为null；\r\r一旦创建了数组，就不能再改变它的大小 ，如果需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 —— array list。\n\n## Arrays类\n\nArrays类是JDK提供的一个工具类，方便对数组进行操作（比如排序和搜索），还包含一个允许将数组作为列表来查看的静态工厂。\n\n* asList(T... a):返回一个受指定数组支持的固定大小的列表。\n* binarySearch:一系列查找的方法，以byte型为例(其他类型类推)；\nbinarySearch(byte[] a, byte key):使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。\nbinarySearch(byte[] a, int fromIndex, int toIndex, byte key):使用二分搜索法来搜索指定的 byte 型数组的范围，以获得指定的值。\rcopyOf:一系列拷贝的方法，以byte型为例(其他类型类推)；\ncopyOf(byte[] original, int newLength):复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。\n* copyOfRange:一系列指定范围的拷贝方法，以byte型为例(其他类型类推)；\ncopyOfRange(byte[] original, int from, int to):将指定数组的指定范围复制到一个新数组。\n* deepEquals(Object[] a1, Object[] a2) :如果两个指定数组彼此是深层相等的，则返回true。\n* deepHashCode(Object[] a) :基于指定数组的“深层内容”返回哈希码。\n* deepToString(Object[] a) :返回指定数组“深层内容”的字符串表示形式。\n* equals:一系列判断数组是否相等的方法，以byte型为例（其他类型类推）；\nequals(byte[] a, byte[] a2):如果两个指定的 byte 型数组彼此相等，则返回 true。\n* fill:一系列填充数组的方法，以byte型为例（其他类型类推）；\nfill(byte[] a, byte val):将指定的 byte 值分配给指定 byte 节型数组的每个元素。\nfill(byte[] a, int fromIndex, int toIndex, byte val):将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。\n* hashCode:一系列返回指定数组哈希码的方法，以byte型为例（其他类型类推）;hashCode(byte[] a) \n* sort:一系列对指定数组排序的方法，以byte型为例（其他类型类推）;\nsort(byte[] a):对指定的 byte 型数组按数字升序进行排序。\nsort(byte[] a, int fromIndex, int toIndex):对指定 byte 型数组的指定范围按数字升序进行排序。\n* toString:一系列得到指定数组内容的字符串表示形式的方法，以byte型为例（其他类型类推）;toString(byte[] a) 。\r\r## 多维数组\n\n即数组的数组，如下：\n\n```\n        int[][] a = {\n                {11, 12, 13},\n                {21, 22, 23},\n                {31, 32, 33},\n        };\r```\n\n","slug":"java-core-conception","published":1,"updated":"2016-04-22T06:54:16.000Z","_id":"cinb2xt600000bgv03ys4fcie","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要介绍一些Java中的基本概念，包括数据类型、变量、运算符、字符串、输入输出、控制流程、大数值、数组。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>Java是一种强类型语言，必须为每一个变量声明一种类型。Java中一共有8种基本类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符型char、1种用于表示真值的boolean型。</p>\n<h2 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储需求</th>\n<th>后缀</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>无</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>无</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>L,如1000000000L</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<p>前缀：16进制0x，8进制0，如100的16进制为0x64，8进制为0144，从Java7开始，加上前缀0b就可以写二进制数，<code>并且，从Java7开始，可以为数字中加下划线，如：int i = 1_0_0</code>如下：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1_0_0;</span><br><span class=\"line\">int i16 = <span class=\"number\">0x64</span>;</span><br><span class=\"line\">int i8 = <span class=\"number\">0144</span>;</span><br><span class=\"line\">int i2 = <span class=\"number\">0b1100100</span>;</span><br><span class=\"line\">System.out.println(i16 == i &amp;&amp; i8 == i &amp;&amp; i2 == i);</span><br></pre></td></tr></table></figure>\n<p>结果为true。</p>\n<h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储需求</th>\n<th>后缀</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>F,如12.3F</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>D,如12345678.9D</td>\n</tr>\n</tbody>\n</table>\n<p>三个特殊的浮点数值：</p>\n<ol>\n<li>正无穷，Float.POSITIVE_INFINITY/Double.POSITIVE_INFINITY</li>\n<li>负无穷，Float.NEGATIVE_INFINITY/Double.NEGATIVE_INFINITY</li>\n<li>NaN(非数字), Float.NaN/Double.NaN</li>\n</ol>\n<p><code>注意：不能这样检测一个特定值是否等于Double.NaN\nif(x == Double.NaN) // is never true\n所有&quot;非数值&quot;的值都认为是不同的，应该使用：\nif(Double.isNan(x)) // check whether x is &quot;not a number&quot;</code></p>\n<p><code>警告：浮点型不适用于禁止出现舍入误差的金融计算中，如果需要在数值计算中不含有任何舍入误差，应该使用BigDecimal类。</code></p>\n<h2 id=\"char型\"><a href=\"#char型\" class=\"headerlink\" title=\"char型\"></a>char型</h2><p>char表示单个Unicode编码的字符。Unicode编码单元可以表示为16进制，其范围从\\U0000到\\Uffff。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><ul>\n<li>在Java中，每一个变量属于一种类型。</li>\n<li>变量名必须是以字母开头的由字母或数字构成的序列，不可使用保留字。</li>\n<li>可以在一行中声明多个变量，但不提倡这样做，逐一声明每一个变量可以提高程序的可读性。</li>\n<li>使用final关键字表示常量——只能被赋值一次，一旦被赋值后，就不能够再更改了。</li>\n</ul>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>加</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>写法：x = x + 2;</li>\n<li>简化格式：x += 2;</li>\n<li>自增/自减运算：n++（先用后加）/++n（先加后用）；自减运算：n–（先用后减）/–n（先减后用）。</li>\n</ul>\n<p><code>使用strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果，如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。</code></p>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>></td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>>=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>非等于</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>与</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>或</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非</td>\n</tr>\n<tr>\n<td>>&gt;</td>\n<td>右移位，可以用来屏蔽低位，或进行2的倍数计算，如8&gt;&gt;3 == 1，计算过程：转化为2进制即0b1000&gt;&gt;3，为2进制0b0001；</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移位，可以用来屏蔽高们，或进行2的倍数计算，如1&lt;&lt;3 == 8，计算过程：转化为2进制即0b0001&lt;&lt;3，为2进制0b1000;</td>\n</tr>\n<tr>\n<td>>&gt;&gt;</td>\n<td>右移位，用0填充高位，与&gt;&gt;的区别在于：&gt;&gt;用符号位填充高位；没有&lt;&lt;&lt;运算符。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：对移位运算符右侧的参数需要进行模32的运算（如果左侧的操作数是long类型，则需要模64。）</p>\n<h2 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h2><p>Math类中包含了各种各样的数学函数，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，需要使用<code>StrictMath</code>类，它使用“自由发布的Math库”(fdlibm)实现算法，以确保所有平台上得到相同的结果。</p>\n<h2 id=\"数值类型间的转换\"><a href=\"#数值类型间的转换\" class=\"headerlink\" title=\"数值类型间的转换\"></a>数值类型间的转换</h2><p><img src=\"conversion.png\" alt=\"\"></p>\n<p>当数值进行运算时，需要先将两个操作数转换为同一种类型，遵循如下原则：<br>如果存在double，则转换成double；<br>否则，如果存在float，则转换成float；<br>否则，如果存在long，则转换成long；<br>否则，都转换成int；</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>如：double d = 1.234; int i = (int)d; i的值为1；强制类型转换通过截断小数部分将浮点值转换为整型。</p>\n<p><code>注意：如果将一个数值强制转换成另一个类型，而又超出了目标类型的表示范围，结果会截断成一个完全不同的值。如：(byte)300 == 44。</code></p>\n<h2 id=\"括号与运算符级别\"><a href=\"#括号与运算符级别\" class=\"headerlink\" title=\"括号与运算符级别\"></a>括号与运算符级别</h2><p>括号优先，无括号的按照优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（右结合运算符按照从右到左进行计算。）。</p>\n<h2 id=\"枚举型\"><a href=\"#枚举型\" class=\"headerlink\" title=\"枚举型\"></a>枚举型</h2><p>变量的取值只在一个有限的集合内，如enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};</p>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>Java字符串就是Unicode的字符序列。</p>\n<ul>\n<li>赋值：String string = “string”;</li>\n<li>子串：String subStr = string.substring(0,3);从0开始，截取长度为3的字符串；</li>\n<li>拼接：使用+号将两个字符串拼接；</li>\n</ul>\n<p><code>==判断两个String对象是否放在同一个位置上。\nequals判断两个String对象的值是否相等。</code></p>\n<p>“”与null是不相同的概念，null表示空对象，””表示字符串为空值。</p>\n<p><code>注意，尽量不使用char型，原因是：在使用辅助字符时，由于辅助字符会占用两个代码单元，所以会导致charAt()方法得不到想要的结果。</code></p>\n<h2 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h2><p><code>对String对象的任何改变都会生成新的对象。</code></p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str1 </span>= <span class=\"string\">\"string\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str2 </span>= <span class=\"string\">\"string\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str3 </span>= new <span class=\"keyword\">String(\"string\");</span><br><span class=\"line\"></span><span class=\"keyword\">String </span><span class=\"keyword\">str4 </span>= new <span class=\"keyword\">String(\"string\");</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str1 </span>== <span class=\"keyword\">str2);</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str2 </span>== <span class=\"keyword\">str3);</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3 </span>== <span class=\"keyword\">str4);</span></span><br></pre></td></tr></table></figure>\n<p>以上代码的输出结果是：<br>true<br>false<br>false</p>\n<p>这是因为JVM引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接指向已经存在的字面常量；否则，开辟一个空间来存储该字面常量，并指向该指面常量。所以str1 == str2返回为true。<br>而使用new关键字来创建的对象都是在堆区进行的，不会去检测对象是否已经存在。因此，通过new创建的对象，一定是不相同的。</p>\n<p><code>String、StringBuilder、StringBuffer都是final类，这意味着它们不能被继承，也它们的所有方法都是final方法，即方法不能被覆盖。在需要进行大量的字符串拼接操作时，使用StringBuilder与StringBuffer的效率比String类要高，StringBuilder类非线程安全，StringBuffer类线程安全。</code></p>\n<p>直接使用String类进行拼接：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringStudy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String args[]) &#123;</span><br><span class=\"line\">        String <span class=\"keyword\">str</span> = <span class=\"string\">\"str\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">str</span> += <span class=\"string\">\"ing\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>StringBuilder与StringBuffer都继承自AbstractStringBuilder，拼接操作都调用的是AbstractStringBuilder类中的append方法，所以这里只使用StringBuilder来与String进行比较：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">StringBuilderStudy</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"str\"</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">\"ing\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用javap -c查看两段代码的字节码分别如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"StringStudy.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> org.jackalope.study.lang.StringStudy &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> org.jackalope.study.lang.StringStudy();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial <span class=\"meta\">#1                  <span class=\"comment\">// Method java/lang/Object.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(java.lang.<span class=\"keyword\">String</span>[]);</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: ldc           <span class=\"meta\">#2                  <span class=\"comment\">// String str</span></span></span><br><span class=\"line\">       <span class=\"number\">2</span>: astore_1</span><br><span class=\"line\">       <span class=\"number\">3</span>: new           <span class=\"meta\">#3                  <span class=\"comment\">// class java/lang/StringBuilder</span></span></span><br><span class=\"line\">       <span class=\"number\">6</span>: dup</span><br><span class=\"line\">       <span class=\"number\">7</span>: invokespecial <span class=\"meta\">#4                  <span class=\"comment\">// Method java/lang/StringBuilder.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: invokevirtual <span class=\"meta\">#5                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">14</span>: ldc           <span class=\"meta\">#6                  <span class=\"comment\">// String ing</span></span></span><br><span class=\"line\">      <span class=\"number\">16</span>: invokevirtual <span class=\"meta\">#5                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">19</span>: invokevirtual <span class=\"meta\">#7                  <span class=\"comment\">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span></span><br><span class=\"line\">      <span class=\"number\">22</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">23</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"StringBuilderStudy.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> org.jackalope.study.lang.StringBuilderStudy &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> org.jackalope.study.lang.StringBuilderStudy();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial <span class=\"meta\">#1                  <span class=\"comment\">// Method java/lang/Object.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(java.lang.<span class=\"keyword\">String</span>[]);</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: new           <span class=\"meta\">#2                  <span class=\"comment\">// class java/lang/StringBuilder</span></span></span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       <span class=\"number\">4</span>: ldc           <span class=\"meta\">#3                  <span class=\"comment\">// String str</span></span></span><br><span class=\"line\">       <span class=\"number\">6</span>: invokespecial <span class=\"meta\">#4                  <span class=\"comment\">// Method java/lang/StringBuilder.\"&lt;init&gt;\":(Ljava/lang/String;)V</span></span></span><br><span class=\"line\">       <span class=\"number\">9</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: ldc           <span class=\"meta\">#5                  <span class=\"comment\">// String ing</span></span></span><br><span class=\"line\">      <span class=\"number\">13</span>: invokevirtual <span class=\"meta\">#6                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">16</span>: pop</span><br><span class=\"line\">      <span class=\"number\">17</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，String的拼接操作是创建一个StringBuilder对象，并调用append方法来实现的，所以效率上一定比不上直接使用StringBuilder。</p>\n<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><p>简单介绍一下，详情请见<a href=\"java-core-io\">Java总结 - IO</a>与<a href=\"java-core-nio\">Java总结 - NIO</a><br>System.in输入流<br>System.out输出流<br>Java 6引入了Console类实现从控制台读取密码，用法如下：</p>\n<pre><code>Console console = System.console();\nString username = console.readLine(&quot;User name:&quot;);\nchar[] passwd = console.readPassword(&quot;Password:&quot;);\n</code></pre><h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><table>\n<thead>\n<tr>\n<th>转称符</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d</td>\n<td>十进制整数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>八进制整数</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>定点浮点数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>指数浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>通用浮点数</td>\n</tr>\n<tr>\n<td>%a</td>\n<td>十六进制浮点数</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>布尔型</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>散列码</td>\n</tr>\n<tr>\n<td>%tx</td>\n<td>日期时间</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>百分号</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>行分隔符</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"控制流程\"><a href=\"#控制流程\" class=\"headerlink\" title=\"控制流程\"></a>控制流程</h1><h2 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h2><p>以一对花括号{}括起来的若干条Java语句称为块，一个块可以嵌套在另一个块中，不能在嵌套的两个块中声明同名的变量。</p>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>格式</p>\n<ul>\n<li>if(condition) statement</li>\n<li>if(condition) statement1 else statement2</li>\n<li>if(condition1) statement1 else if(condition2) statement2 else statement3</li>\n<li>switch    //多重选择</li>\n</ul>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><ul>\n<li>while(condition) statement</li>\n<li>do statement while(condition) // 先执行一次再判断条件进行循环</li>\n<li>for(define; condition; statement) statement</li>\n<li>for(variable : collection) statement // for each</li>\n</ul>\n<h2 id=\"中断控制流程语句\"><a href=\"#中断控制流程语句\" class=\"headerlink\" title=\"中断控制流程语句\"></a>中断控制流程语句</h2><ul>\n<li>break：跳出并退出循环</li>\n<li>带标签的break：用于跳出多重嵌套的循环，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号，如下：<br>label:<br>while(…){<br>…<br>whille(…){<br>…<br>break label;<br>}<br>}</li>\n<li>continue : 跳出并继续循环</li>\n</ul>\n<h1 id=\"大数值\"><a href=\"#大数值\" class=\"headerlink\" title=\"大数值\"></a>大数值</h1><p>BigInteger和BigDecimal可以处理包含任意长度数字序列的数值。BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add</td>\n<td>加</td>\n</tr>\n<tr>\n<td>subtract</td>\n<td>减</td>\n</tr>\n<tr>\n<td>multiply</td>\n<td>乘</td>\n</tr>\n<tr>\n<td>divide</td>\n<td>除</td>\n</tr>\n<tr>\n<td>mod</td>\n<td>取模</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标可以访问数组中的每一个值，数组下标从0开始。</p>\n<ul>\n<li>声明数组：int[] a;</li>\n<li>定义数组：int[] a = new int[100];所有元素初始化为0；<br>String[] sa = new String[100];所有元素初始化为null；</li>\n</ul>\n<p>一旦创建了数组，就不能再改变它的大小 ，如果需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 —— array list。</p>\n<h2 id=\"Arrays类\"><a href=\"#Arrays类\" class=\"headerlink\" title=\"Arrays类\"></a>Arrays类</h2><p>Arrays类是JDK提供的一个工具类，方便对数组进行操作（比如排序和搜索），还包含一个允许将数组作为列表来查看的静态工厂。</p>\n<ul>\n<li>asList(T… a):返回一个受指定数组支持的固定大小的列表。</li>\n<li>binarySearch:一系列查找的方法，以byte型为例(其他类型类推)；<br>binarySearch(byte[] a, byte key):使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。<br>binarySearch(byte[] a, int fromIndex, int toIndex, byte key):使用二分搜索法来搜索指定的 byte 型数组的范围，以获得指定的值。<br>copyOf:一系列拷贝的方法，以byte型为例(其他类型类推)；<br>copyOf(byte[] original, int newLength):复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。</li>\n<li>copyOfRange:一系列指定范围的拷贝方法，以byte型为例(其他类型类推)；<br>copyOfRange(byte[] original, int from, int to):将指定数组的指定范围复制到一个新数组。</li>\n<li>deepEquals(Object[] a1, Object[] a2) :如果两个指定数组彼此是深层相等的，则返回true。</li>\n<li>deepHashCode(Object[] a) :基于指定数组的“深层内容”返回哈希码。</li>\n<li>deepToString(Object[] a) :返回指定数组“深层内容”的字符串表示形式。</li>\n<li>equals:一系列判断数组是否相等的方法，以byte型为例（其他类型类推）；<br>equals(byte[] a, byte[] a2):如果两个指定的 byte 型数组彼此相等，则返回 true。</li>\n<li>fill:一系列填充数组的方法，以byte型为例（其他类型类推）；<br>fill(byte[] a, byte val):将指定的 byte 值分配给指定 byte 节型数组的每个元素。<br>fill(byte[] a, int fromIndex, int toIndex, byte val):将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。</li>\n<li>hashCode:一系列返回指定数组哈希码的方法，以byte型为例（其他类型类推）;hashCode(byte[] a) </li>\n<li>sort:一系列对指定数组排序的方法，以byte型为例（其他类型类推）;<br>sort(byte[] a):对指定的 byte 型数组按数字升序进行排序。<br>sort(byte[] a, int fromIndex, int toIndex):对指定 byte 型数组的指定范围按数字升序进行排序。</li>\n<li>toString:一系列得到指定数组内容的字符串表示形式的方法，以byte型为例（其他类型类推）;toString(byte[] a) 。</li>\n</ul>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>即数组的数组，如下：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[][] a = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">21</span>, <span class=\"number\">22</span>, <span class=\"number\">23</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">31</span>, <span class=\"number\">32</span>, <span class=\"number\">33</span>&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>本文主要介绍一些Java中的基本概念，包括数据类型、变量、运算符、字符串、输入输出、控制流程、大数值、数组。</p>\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>Java是一种强类型语言，必须为每一个变量声明一种类型。Java中一共有8种基本类型，其中有4种整型、2种浮点型、1种用于表示Unicode编码的字符单元的字符型char、1种用于表示真值的boolean型。</p>\n<h2 id=\"整型\"><a href=\"#整型\" class=\"headerlink\" title=\"整型\"></a>整型</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储需求</th>\n<th>后缀</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>int</td>\n<td>4字节</td>\n<td>无</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2字节</td>\n<td>无</td>\n</tr>\n<tr>\n<td>long</td>\n<td>8字节</td>\n<td>L,如1000000000L</td>\n</tr>\n<tr>\n<td>byte</td>\n<td>1字节</td>\n<td>无</td>\n</tr>\n</tbody>\n</table>\n<p>前缀：16进制0x，8进制0，如100的16进制为0x64，8进制为0144，从Java7开始，加上前缀0b就可以写二进制数，<code>并且，从Java7开始，可以为数字中加下划线，如：int i = 1_0_0</code>如下：</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 1_0_0;</span><br><span class=\"line\">int i16 = <span class=\"number\">0x64</span>;</span><br><span class=\"line\">int i8 = <span class=\"number\">0144</span>;</span><br><span class=\"line\">int i2 = <span class=\"number\">0b1100100</span>;</span><br><span class=\"line\">System.out.println(i16 == i &amp;&amp; i8 == i &amp;&amp; i2 == i);</span><br></pre></td></tr></table></figure>\n<p>结果为true。</p>\n<h2 id=\"浮点型\"><a href=\"#浮点型\" class=\"headerlink\" title=\"浮点型\"></a>浮点型</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>存储需求</th>\n<th>后缀</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>float</td>\n<td>4字节</td>\n<td>F,如12.3F</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8字节</td>\n<td>D,如12345678.9D</td>\n</tr>\n</tbody>\n</table>\n<p>三个特殊的浮点数值：</p>\n<ol>\n<li>正无穷，Float.POSITIVE_INFINITY/Double.POSITIVE_INFINITY</li>\n<li>负无穷，Float.NEGATIVE_INFINITY/Double.NEGATIVE_INFINITY</li>\n<li>NaN(非数字), Float.NaN/Double.NaN</li>\n</ol>\n<p><code>注意：不能这样检测一个特定值是否等于Double.NaN\nif(x == Double.NaN) // is never true\n所有&quot;非数值&quot;的值都认为是不同的，应该使用：\nif(Double.isNan(x)) // check whether x is &quot;not a number&quot;</code></p>\n<p><code>警告：浮点型不适用于禁止出现舍入误差的金融计算中，如果需要在数值计算中不含有任何舍入误差，应该使用BigDecimal类。</code></p>\n<h2 id=\"char型\"><a href=\"#char型\" class=\"headerlink\" title=\"char型\"></a>char型</h2><p>char表示单个Unicode编码的字符。Unicode编码单元可以表示为16进制，其范围从\\U0000到\\Uffff。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><ul>\n<li>在Java中，每一个变量属于一种类型。</li>\n<li>变量名必须是以字母开头的由字母或数字构成的序列，不可使用保留字。</li>\n<li>可以在一行中声明多个变量，但不提倡这样做，逐一声明每一个变量可以提高程序的可读性。</li>\n<li>使用final关键字表示常量——只能被赋值一次，一旦被赋值后，就不能够再更改了。</li>\n</ul>\n<h1 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h1><h2 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>+</td>\n<td>加</td>\n</tr>\n<tr>\n<td>-</td>\n<td>减</td>\n</tr>\n<tr>\n<td>*</td>\n<td>乘</td>\n</tr>\n<tr>\n<td>/</td>\n<td>除</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>写法：x = x + 2;</li>\n<li>简化格式：x += 2;</li>\n<li>自增/自减运算：n++（先用后加）/++n（先加后用）；自减运算：n–（先用后减）/–n（先减后用）。</li>\n</ul>\n<p><code>使用strictfp关键字标记的方法必须使用严格的浮点计算来产生理想的结果，如果将一个类标记为strictfp，这个类中的所有方法都要使用严格的浮点计算。</code></p>\n<h2 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>></td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>>=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>==</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>!=</td>\n<td>非等于</td>\n</tr>\n<tr>\n<td>&amp;&amp;</td>\n<td>与</td>\n</tr>\n<tr>\n<td>&#124;&#124;</td>\n<td>或</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"位运算\"><a href=\"#位运算\" class=\"headerlink\" title=\"位运算\"></a>位运算</h2><table>\n<thead>\n<tr>\n<th>符号</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>&amp;</td>\n<td>与</td>\n</tr>\n<tr>\n<td>&#124;</td>\n<td>或</td>\n</tr>\n<tr>\n<td>!</td>\n<td>非</td>\n</tr>\n<tr>\n<td>>&gt;</td>\n<td>右移位，可以用来屏蔽低位，或进行2的倍数计算，如8&gt;&gt;3 == 1，计算过程：转化为2进制即0b1000&gt;&gt;3，为2进制0b0001；</td>\n</tr>\n<tr>\n<td>&lt;&lt;</td>\n<td>左移位，可以用来屏蔽高们，或进行2的倍数计算，如1&lt;&lt;3 == 8，计算过程：转化为2进制即0b0001&lt;&lt;3，为2进制0b1000;</td>\n</tr>\n<tr>\n<td>>&gt;&gt;</td>\n<td>右移位，用0填充高位，与&gt;&gt;的区别在于：&gt;&gt;用符号位填充高位；没有&lt;&lt;&lt;运算符。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：对移位运算符右侧的参数需要进行模32的运算（如果左侧的操作数是long类型，则需要模64。）</p>\n<h2 id=\"数学函数\"><a href=\"#数学函数\" class=\"headerlink\" title=\"数学函数\"></a>数学函数</h2><p>Math类中包含了各种各样的数学函数，所有的方法都使用计算机浮点单元中的例程。如果得到一个完全可预测的结果比运行速度更重要的话，需要使用<code>StrictMath</code>类，它使用“自由发布的Math库”(fdlibm)实现算法，以确保所有平台上得到相同的结果。</p>\n<h2 id=\"数值类型间的转换\"><a href=\"#数值类型间的转换\" class=\"headerlink\" title=\"数值类型间的转换\"></a>数值类型间的转换</h2><p><img src=\"conversion.png\" alt=\"\"></p>\n<p>当数值进行运算时，需要先将两个操作数转换为同一种类型，遵循如下原则：<br>如果存在double，则转换成double；<br>否则，如果存在float，则转换成float；<br>否则，如果存在long，则转换成long；<br>否则，都转换成int；</p>\n<h2 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h2><p>如：double d = 1.234; int i = (int)d; i的值为1；强制类型转换通过截断小数部分将浮点值转换为整型。</p>\n<p><code>注意：如果将一个数值强制转换成另一个类型，而又超出了目标类型的表示范围，结果会截断成一个完全不同的值。如：(byte)300 == 44。</code></p>\n<h2 id=\"括号与运算符级别\"><a href=\"#括号与运算符级别\" class=\"headerlink\" title=\"括号与运算符级别\"></a>括号与运算符级别</h2><p>括号优先，无括号的按照优先级次序进行计算。同一个级别的运算符按照从左到右的次序进行计算（右结合运算符按照从右到左进行计算。）。</p>\n<h2 id=\"枚举型\"><a href=\"#枚举型\" class=\"headerlink\" title=\"枚举型\"></a>枚举型</h2><p>变量的取值只在一个有限的集合内，如enum Size {SMALL, MEDIUM, LARGE, EXTRA_LARGE};</p>\n<h1 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h1><p>Java字符串就是Unicode的字符序列。</p>\n<ul>\n<li>赋值：String string = “string”;</li>\n<li>子串：String subStr = string.substring(0,3);从0开始，截取长度为3的字符串；</li>\n<li>拼接：使用+号将两个字符串拼接；</li>\n</ul>\n<p><code>==判断两个String对象是否放在同一个位置上。\nequals判断两个String对象的值是否相等。</code></p>\n<p>“”与null是不相同的概念，null表示空对象，””表示字符串为空值。</p>\n<p><code>注意，尽量不使用char型，原因是：在使用辅助字符时，由于辅助字符会占用两个代码单元，所以会导致charAt()方法得不到想要的结果。</code></p>\n<h2 id=\"深入理解\"><a href=\"#深入理解\" class=\"headerlink\" title=\"深入理解\"></a>深入理解</h2><p><code>对String对象的任何改变都会生成新的对象。</code></p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str1 </span>= <span class=\"string\">\"string\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str2 </span>= <span class=\"string\">\"string\"</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"keyword\">String </span><span class=\"keyword\">str3 </span>= new <span class=\"keyword\">String(\"string\");</span><br><span class=\"line\"></span><span class=\"keyword\">String </span><span class=\"keyword\">str4 </span>= new <span class=\"keyword\">String(\"string\");</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str1 </span>== <span class=\"keyword\">str2);</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str2 </span>== <span class=\"keyword\">str3);</span><br><span class=\"line\"></span><span class=\"symbol\">System.out.println</span>(<span class=\"keyword\">str3 </span>== <span class=\"keyword\">str4);</span></span><br></pre></td></tr></table></figure>\n<p>以上代码的输出结果是：<br>true<br>false<br>false</p>\n<p>这是因为JVM引擎会先在运行时常量池查找是否存在相同的字面常量，如果存在，则直接指向已经存在的字面常量；否则，开辟一个空间来存储该字面常量，并指向该指面常量。所以str1 == str2返回为true。<br>而使用new关键字来创建的对象都是在堆区进行的，不会去检测对象是否已经存在。因此，通过new创建的对象，一定是不相同的。</p>\n<p><code>String、StringBuilder、StringBuffer都是final类，这意味着它们不能被继承，也它们的所有方法都是final方法，即方法不能被覆盖。在需要进行大量的字符串拼接操作时，使用StringBuilder与StringBuffer的效率比String类要高，StringBuilder类非线程安全，StringBuffer类线程安全。</code></p>\n<p>直接使用String类进行拼接：<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringStudy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(String args[]) &#123;</span><br><span class=\"line\">        String <span class=\"keyword\">str</span> = <span class=\"string\">\"str\"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">str</span> += <span class=\"string\">\"ing\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>StringBuilder与StringBuffer都继承自AbstractStringBuilder，拼接操作都调用的是AbstractStringBuilder类中的append方法，所以这里只使用StringBuilder来与String进行比较：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">StringBuilderStudy</span> &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder(<span class=\"string\">\"str\"</span>);</span><br><span class=\"line\">        sb.append(<span class=\"string\">\"ing\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用javap -c查看两段代码的字节码分别如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"StringStudy.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> org.jackalope.study.lang.StringStudy &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> org.jackalope.study.lang.StringStudy();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial <span class=\"meta\">#1                  <span class=\"comment\">// Method java/lang/Object.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(java.lang.<span class=\"keyword\">String</span>[]);</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: ldc           <span class=\"meta\">#2                  <span class=\"comment\">// String str</span></span></span><br><span class=\"line\">       <span class=\"number\">2</span>: astore_1</span><br><span class=\"line\">       <span class=\"number\">3</span>: new           <span class=\"meta\">#3                  <span class=\"comment\">// class java/lang/StringBuilder</span></span></span><br><span class=\"line\">       <span class=\"number\">6</span>: dup</span><br><span class=\"line\">       <span class=\"number\">7</span>: invokespecial <span class=\"meta\">#4                  <span class=\"comment\">// Method java/lang/StringBuilder.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: invokevirtual <span class=\"meta\">#5                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">14</span>: ldc           <span class=\"meta\">#6                  <span class=\"comment\">// String ing</span></span></span><br><span class=\"line\">      <span class=\"number\">16</span>: invokevirtual <span class=\"meta\">#5                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">19</span>: invokevirtual <span class=\"meta\">#7                  <span class=\"comment\">// Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span></span><br><span class=\"line\">      <span class=\"number\">22</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">23</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compiled from <span class=\"string\">\"StringBuilderStudy.java\"</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> org.jackalope.study.lang.StringBuilderStudy &#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> org.jackalope.study.lang.StringBuilderStudy();</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: aload_0</span><br><span class=\"line\">       <span class=\"number\">1</span>: invokespecial <span class=\"meta\">#1                  <span class=\"comment\">// Method java/lang/Object.\"&lt;init&gt;\":()V</span></span></span><br><span class=\"line\">       <span class=\"number\">4</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> main(java.lang.<span class=\"keyword\">String</span>[]);</span><br><span class=\"line\">    Code:</span><br><span class=\"line\">       <span class=\"number\">0</span>: new           <span class=\"meta\">#2                  <span class=\"comment\">// class java/lang/StringBuilder</span></span></span><br><span class=\"line\">       <span class=\"number\">3</span>: dup</span><br><span class=\"line\">       <span class=\"number\">4</span>: ldc           <span class=\"meta\">#3                  <span class=\"comment\">// String str</span></span></span><br><span class=\"line\">       <span class=\"number\">6</span>: invokespecial <span class=\"meta\">#4                  <span class=\"comment\">// Method java/lang/StringBuilder.\"&lt;init&gt;\":(Ljava/lang/String;)V</span></span></span><br><span class=\"line\">       <span class=\"number\">9</span>: astore_1</span><br><span class=\"line\">      <span class=\"number\">10</span>: aload_1</span><br><span class=\"line\">      <span class=\"number\">11</span>: ldc           <span class=\"meta\">#5                  <span class=\"comment\">// String ing</span></span></span><br><span class=\"line\">      <span class=\"number\">13</span>: invokevirtual <span class=\"meta\">#6                  <span class=\"comment\">// Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></span><br><span class=\"line\">      <span class=\"number\">16</span>: pop</span><br><span class=\"line\">      <span class=\"number\">17</span>: <span class=\"built_in\">return</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看出，String的拼接操作是创建一个StringBuilder对象，并调用append方法来实现的，所以效率上一定比不上直接使用StringBuilder。</p>\n<h1 id=\"输入输出\"><a href=\"#输入输出\" class=\"headerlink\" title=\"输入输出\"></a>输入输出</h1><p>简单介绍一下，详情请见<a href=\"java-core-io\">Java总结 - IO</a>与<a href=\"java-core-nio\">Java总结 - NIO</a><br>System.in输入流<br>System.out输出流<br>Java 6引入了Console类实现从控制台读取密码，用法如下：</p>\n<pre><code>Console console = System.console();\nString username = console.readLine(&quot;User name:&quot;);\nchar[] passwd = console.readPassword(&quot;Password:&quot;);\n</code></pre><h2 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h2><table>\n<thead>\n<tr>\n<th>转称符</th>\n<th>类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%d</td>\n<td>十进制整数</td>\n</tr>\n<tr>\n<td>%x</td>\n<td>十六进制整数</td>\n</tr>\n<tr>\n<td>%o</td>\n<td>八进制整数</td>\n</tr>\n<tr>\n<td>%f</td>\n<td>定点浮点数</td>\n</tr>\n<tr>\n<td>%e</td>\n<td>指数浮点数</td>\n</tr>\n<tr>\n<td>%g</td>\n<td>通用浮点数</td>\n</tr>\n<tr>\n<td>%a</td>\n<td>十六进制浮点数</td>\n</tr>\n<tr>\n<td>%s</td>\n<td>字符串</td>\n</tr>\n<tr>\n<td>%c</td>\n<td>字符</td>\n</tr>\n<tr>\n<td>%b</td>\n<td>布尔型</td>\n</tr>\n<tr>\n<td>%h</td>\n<td>散列码</td>\n</tr>\n<tr>\n<td>%tx</td>\n<td>日期时间</td>\n</tr>\n<tr>\n<td>%%</td>\n<td>百分号</td>\n</tr>\n<tr>\n<td>%n</td>\n<td>行分隔符</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"控制流程\"><a href=\"#控制流程\" class=\"headerlink\" title=\"控制流程\"></a>控制流程</h1><h2 id=\"块作用域\"><a href=\"#块作用域\" class=\"headerlink\" title=\"块作用域\"></a>块作用域</h2><p>以一对花括号{}括起来的若干条Java语句称为块，一个块可以嵌套在另一个块中，不能在嵌套的两个块中声明同名的变量。</p>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>格式</p>\n<ul>\n<li>if(condition) statement</li>\n<li>if(condition) statement1 else statement2</li>\n<li>if(condition1) statement1 else if(condition2) statement2 else statement3</li>\n<li>switch    //多重选择</li>\n</ul>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><ul>\n<li>while(condition) statement</li>\n<li>do statement while(condition) // 先执行一次再判断条件进行循环</li>\n<li>for(define; condition; statement) statement</li>\n<li>for(variable : collection) statement // for each</li>\n</ul>\n<h2 id=\"中断控制流程语句\"><a href=\"#中断控制流程语句\" class=\"headerlink\" title=\"中断控制流程语句\"></a>中断控制流程语句</h2><ul>\n<li>break：跳出并退出循环</li>\n<li>带标签的break：用于跳出多重嵌套的循环，标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号，如下：<br>label:<br>while(…){<br>…<br>whille(…){<br>…<br>break label;<br>}<br>}</li>\n<li>continue : 跳出并继续循环</li>\n</ul>\n<h1 id=\"大数值\"><a href=\"#大数值\" class=\"headerlink\" title=\"大数值\"></a>大数值</h1><p>BigInteger和BigDecimal可以处理包含任意长度数字序列的数值。BigInteger实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>add</td>\n<td>加</td>\n</tr>\n<tr>\n<td>subtract</td>\n<td>减</td>\n</tr>\n<tr>\n<td>multiply</td>\n<td>乘</td>\n</tr>\n<tr>\n<td>divide</td>\n<td>除</td>\n</tr>\n<tr>\n<td>mod</td>\n<td>取模</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h1><p>数组是一种数据结构，用来存储同一类型值的集合。通过一个整形下标可以访问数组中的每一个值，数组下标从0开始。</p>\n<ul>\n<li>声明数组：int[] a;</li>\n<li>定义数组：int[] a = new int[100];所有元素初始化为0；<br>String[] sa = new String[100];所有元素初始化为null；</li>\n</ul>\n<p>一旦创建了数组，就不能再改变它的大小 ，如果需要在运行过程中扩展数组的大小，就应该使用另一种数据结构 —— array list。</p>\n<h2 id=\"Arrays类\"><a href=\"#Arrays类\" class=\"headerlink\" title=\"Arrays类\"></a>Arrays类</h2><p>Arrays类是JDK提供的一个工具类，方便对数组进行操作（比如排序和搜索），还包含一个允许将数组作为列表来查看的静态工厂。</p>\n<ul>\n<li>asList(T… a):返回一个受指定数组支持的固定大小的列表。</li>\n<li>binarySearch:一系列查找的方法，以byte型为例(其他类型类推)；<br>binarySearch(byte[] a, byte key):使用二分搜索法来搜索指定的 byte 型数组，以获得指定的值。<br>binarySearch(byte[] a, int fromIndex, int toIndex, byte key):使用二分搜索法来搜索指定的 byte 型数组的范围，以获得指定的值。<br>copyOf:一系列拷贝的方法，以byte型为例(其他类型类推)；<br>copyOf(byte[] original, int newLength):复制指定的数组，截取或用 0 填充（如有必要），以使副本具有指定的长度。</li>\n<li>copyOfRange:一系列指定范围的拷贝方法，以byte型为例(其他类型类推)；<br>copyOfRange(byte[] original, int from, int to):将指定数组的指定范围复制到一个新数组。</li>\n<li>deepEquals(Object[] a1, Object[] a2) :如果两个指定数组彼此是深层相等的，则返回true。</li>\n<li>deepHashCode(Object[] a) :基于指定数组的“深层内容”返回哈希码。</li>\n<li>deepToString(Object[] a) :返回指定数组“深层内容”的字符串表示形式。</li>\n<li>equals:一系列判断数组是否相等的方法，以byte型为例（其他类型类推）；<br>equals(byte[] a, byte[] a2):如果两个指定的 byte 型数组彼此相等，则返回 true。</li>\n<li>fill:一系列填充数组的方法，以byte型为例（其他类型类推）；<br>fill(byte[] a, byte val):将指定的 byte 值分配给指定 byte 节型数组的每个元素。<br>fill(byte[] a, int fromIndex, int toIndex, byte val):将指定的 byte 值分配给指定 byte 型数组指定范围中的每个元素。</li>\n<li>hashCode:一系列返回指定数组哈希码的方法，以byte型为例（其他类型类推）;hashCode(byte[] a) </li>\n<li>sort:一系列对指定数组排序的方法，以byte型为例（其他类型类推）;<br>sort(byte[] a):对指定的 byte 型数组按数字升序进行排序。<br>sort(byte[] a, int fromIndex, int toIndex):对指定 byte 型数组的指定范围按数字升序进行排序。</li>\n<li>toString:一系列得到指定数组内容的字符串表示形式的方法，以byte型为例（其他类型类推）;toString(byte[] a) 。</li>\n</ul>\n<h2 id=\"多维数组\"><a href=\"#多维数组\" class=\"headerlink\" title=\"多维数组\"></a>多维数组</h2><p>即数组的数组，如下：</p>\n<figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[][] a = &#123;</span><br><span class=\"line\">        &#123;<span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">13</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">21</span>, <span class=\"number\">22</span>, <span class=\"number\">23</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"number\">31</span>, <span class=\"number\">32</span>, <span class=\"number\">33</span>&#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"欢迎","date":"2016-04-05T16:00:00.000Z","toc":true,"_content":"基于hexo搭好了个人博客，在这里记录并测试一下。\n\n# hexo的安装步骤\n参考官方文档：[hexo.io](https://hexo.io/zh-cn/docs/index.html)\n# 注意事项\n## Node.js版本\n* 不使用最新版本的Node.js，使用官方文档建议的v4；\n\n## disqus集成\n* 注册disqus；\n* 将short_name添加到_config.yml；\n* 注意修改disqus设置为中文；\n* 不使用评论：\n\t在front-matter中添加一行\n\t```\n\tcomments: false\n\t```\n\n## maupassant主题\n使用[屠城](https://www.haomwei.com/)的主题，感谢！\n* 添加关于(about)，历史（history），留言（guestbook）\n```\nhexo new page abou\nhexo new page history\nhexo new page guestbook\n```\n\n* _config.yml的menu中添加：\n```\n- page: about\n  directory: about/\n  icon: fa-user\n- page: history\n  directory: history/\n  icon: fa-book\n- page: guestbook\n  directory: guestbook/\n  icon: fa-comments\n```\n* 添加时间轴\n```\n---\ntitle: 时间轴\ndate: 2016-04-07 15:12:10\ncomments: false\n---\n<div class=\"timeline\">\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">\n\t\t\t注册域名jackalope.cn\n\t\t</div>\n\t</div>\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div>\n\t</div>\n</div>\n```\n\n## 配置文件\n{% asset_path _config.yml 全局配置 %}\n{% asset_path maupassant_config.yml 主题配置 %}\n\n# Mou的使用\n\n## 标题\n将#号写在行首表示标题，标题1 - 标题6，数字对应#号个数\n\n## 加粗\n未加粗/**加粗**（aaa/**aaa**）(快捷链：Cmd + B)\n\n## 倾斜\n未倾斜/*倾斜*（aaa/*aaa*）(快捷键：Cmd + I)\n\n## 引用\n> 把 > 写到开头，本质上是生成blockquote标签\n\n## 链接\n[jackalope](http://jackalope.cn)\n\n## 邮件\n<zowie_chen@163.com>\n\n## 图片\n内嵌图片，直接写入具体图片地址\n![内嵌图片](http://25.io/smaller/favicon.ico \"Title here\")\n\n引用图片，先指定图片名称，之后再将图片名称映射到具体图片地址\n![引用图片][图片名称]\n[图片名称]: http://resizesafari.com/favicon.ico \"Title\"\n\n## 代码块\n使用3个及以上着重符(`)开始并结束：\n```\nSystem.out.println(\"Hello world!\");\n```\n\n## 有序列表\n使用\"1.\" + 空格\n1. 111\n2. 222\n3. 333\n\n## 无序列表\n使用\"*\" + 空格\n* 111\n* 222\n* 333\n\n或者\"-\" + 空格\n- 111\n- 222\n- 333\n\n## 换行符\n两个及以上空格即可生成一个换行符`<br />`\n\n## 水平分隔符\n三个及以上 \"*\" 或 \"-\" 或 \"- \"，每行之前有空行\n\n***\n\n---\n\n- - -\n\n## 脚注\n脚本，跳到标题[^1]\n[^1]: #标题\n\n## 删除线\n使用两个~开始并结束\n~~ZZZZZZzzzzzz~~\n\n## 表格\n列使用|分开，头尾的|可加可不加；\n列名与行使用多个-分开，:----表示左对齐，:----:表示两端对齐，----:表示右对齐，`PS: 表格上方有一空行`\n\n列1|列2|列3\n--|--|--\n11|12|13\n21|22|23\n31|32|33\n\n\n`列补齐\"|\"`\n\n|列1 | 列2 | 列3|\n|----|----|----|\n|11  |12  |13|\n|21  |22  |23|\n|31  |32  |33|\n\n\n`左中右对齐`\n\n列1|列2|列3\n:--|:--:|--:\n11|12|13\n21|22|23\n31|32|33\n\n## 快捷链\n### 视图\n* 预览: Shift + Cmd + I\n* 统计字数: Shift + Cmd + W\n* 透明: Shift + Cmd + T\n* 悬浮，永在最前: Shift + Cmd + F\n* 左右窗口大小1/1: Cmd + 0\n* 左右窗口大小3/1: Cmd + +\n* 左右窗口大小1/3: Cmd + -\n* 书写方向: Cmd + L\n* 全屏/退出全屏: Control + Cmd + F\n\n### 操作\n* 拷贝html: Option + Cmd + C\n* 加黑加粗: Select text, Cmd + B\n* 倾斜: Select text, Cmd + I\n* Inline Code: Select text, Cmd + K\n* Strikethrough: Select text, Cmd + U\n* Link: Select text, Control + Shift + L\n* Image: Select text, Control + Shift + I\n* Select Word: Control + Option + W\n* Select Line: Shift + Cmd + L\n* Select All: Cmd + A\n* Deselect All: Cmd + D\n* Convert to Uppercase: Select text, Control + U\n* Convert to Lowercase: Select text, Control + Shift + U\n* Convert to Titlecase: Select text, Control + Option + U\n* Convert to List: Select lines, Control + L\n* Convert to Blockquote: Select lines, Control + Q\n* Convert to H1: Cmd + 1\n* Convert to H2: Cmd + 2\n* Convert to H3: Cmd + 3\n* Convert to H4: Cmd + 4\n* Convert to H5: Cmd + 5\n* Convert to H6: Cmd + 6\n* Convert Spaces to Tabs: Control + [\n* Convert Tabs to Spaces: Control + ]\n* Insert Current Date: Control + Shift + 1\n* Insert Current Time: Control + Shift + 2\n* Insert entity <: Control + Shift + ,\n* Insert entity >: Control + Shift + .\n* Insert entity &: Control + Shift + 7\n* Insert entity Space: Control + Shift + Space\n* Insert Scriptogr.am Header: Control + Shift + G\n* Shift Line Left: Select lines, Cmd + [\n* Shift Line Right: Select lines, Cmd + ]\n* New Line: Cmd + Return\n* Comment: Cmd + /\n* Hard Linebreak: Control + Return\n\n### 编辑\n\n* Auto complete current word: Esc\n* Find: Cmd + F\n* Close find bar: Esc\n\n### Post\n\n* Post on Scriptogr.am: Control + Shift + S\n* Post on Tumblr: Control + Shift + T\n\n### 导出\n\n* Export HTML: Option + Cmd + E\n* Export PDF:  Option + Cmd + P\n\n\n### And more?\n\nDon't forget to check Preferences, lots of useful options are there.\n\nFollow [@Mou](https://twitter.com/mou) on Twitter for the latest news.\n\nFor feedback, use the menu `Help` - `Send Feedback`\n\n# hello-world.md\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: 欢迎\ndate: 2016/04/06 00:00:00\ntoc: true\ntags: \n- hexo\ncategories: \n- hexo\n\n---\n基于hexo搭好了个人博客，在这里记录并测试一下。\n\n# hexo的安装步骤\n参考官方文档：[hexo.io](https://hexo.io/zh-cn/docs/index.html)\n# 注意事项\n## Node.js版本\n* 不使用最新版本的Node.js，使用官方文档建议的v4；\n\n## disqus集成\n* 注册disqus；\n* 将short_name添加到_config.yml；\n* 注意修改disqus设置为中文；\n* 不使用评论：\n\t在front-matter中添加一行\n\t```\n\tcomments: false\n\t```\n\n## maupassant主题\n使用[屠城](https://www.haomwei.com/)的主题，感谢！\n* 添加关于(about)，历史（history），留言（guestbook）\n```\nhexo new page abou\nhexo new page history\nhexo new page guestbook\n```\n\n* _config.yml的menu中添加：\n```\n- page: about\n  directory: about/\n  icon: fa-user\n- page: history\n  directory: history/\n  icon: fa-book\n- page: guestbook\n  directory: guestbook/\n  icon: fa-comments\n```\n* 添加时间轴\n```\n---\ntitle: 时间轴\ndate: 2016-04-07 15:12:10\ncomments: false\n---\n<div class=\"timeline\">\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2014<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">\n\t\t\t注册域名jackalope.cn\n\t\t</div>\n\t</div>\n\t<div class=\"timeline-item active\">\n\t\t<div class=\"year\">2016<span class=\"marker\"><span class=\"dot\"></span></span></div>\n\t\t<div class=\"info\">初试个人博客，使用hexo搭建，托管于Github</div>\n\t</div>\n</div>\n```\n\n## 配置文件\n{% asset_path _config.yml 全局配置 %}\n{% asset_path maupassant_config.yml 主题配置 %}\n\n# Mou的使用\n\n## 标题\n将#号写在行首表示标题，标题1 - 标题6，数字对应#号个数\n\n## 加粗\n未加粗/**加粗**（aaa/**aaa**）(快捷链：Cmd + B)\n\n## 倾斜\n未倾斜/*倾斜*（aaa/*aaa*）(快捷键：Cmd + I)\n\n## 引用\n> 把 > 写到开头，本质上是生成blockquote标签\n\n## 链接\n[jackalope](http://jackalope.cn)\n\n## 邮件\n<zowie_chen@163.com>\n\n## 图片\n内嵌图片，直接写入具体图片地址\n![内嵌图片](http://25.io/smaller/favicon.ico \"Title here\")\n\n引用图片，先指定图片名称，之后再将图片名称映射到具体图片地址\n![引用图片][图片名称]\n[图片名称]: http://resizesafari.com/favicon.ico \"Title\"\n\n## 代码块\n使用3个及以上着重符(`)开始并结束：\n```\nSystem.out.println(\"Hello world!\");\n```\n\n## 有序列表\n使用\"1.\" + 空格\n1. 111\n2. 222\n3. 333\n\n## 无序列表\n使用\"*\" + 空格\n* 111\n* 222\n* 333\n\n或者\"-\" + 空格\n- 111\n- 222\n- 333\n\n## 换行符\n两个及以上空格即可生成一个换行符`<br />`\n\n## 水平分隔符\n三个及以上 \"*\" 或 \"-\" 或 \"- \"，每行之前有空行\n\n***\n\n---\n\n- - -\n\n## 脚注\n脚本，跳到标题[^1]\n[^1]: #标题\n\n## 删除线\n使用两个~开始并结束\n~~ZZZZZZzzzzzz~~\n\n## 表格\n列使用|分开，头尾的|可加可不加；\n列名与行使用多个-分开，:----表示左对齐，:----:表示两端对齐，----:表示右对齐，`PS: 表格上方有一空行`\n\n列1|列2|列3\n--|--|--\n11|12|13\n21|22|23\n31|32|33\n\n\n`列补齐\"|\"`\n\n|列1 | 列2 | 列3|\n|----|----|----|\n|11  |12  |13|\n|21  |22  |23|\n|31  |32  |33|\n\n\n`左中右对齐`\n\n列1|列2|列3\n:--|:--:|--:\n11|12|13\n21|22|23\n31|32|33\n\n## 快捷链\n### 视图\n* 预览: Shift + Cmd + I\n* 统计字数: Shift + Cmd + W\n* 透明: Shift + Cmd + T\n* 悬浮，永在最前: Shift + Cmd + F\n* 左右窗口大小1/1: Cmd + 0\n* 左右窗口大小3/1: Cmd + +\n* 左右窗口大小1/3: Cmd + -\n* 书写方向: Cmd + L\n* 全屏/退出全屏: Control + Cmd + F\n\n### 操作\n* 拷贝html: Option + Cmd + C\n* 加黑加粗: Select text, Cmd + B\n* 倾斜: Select text, Cmd + I\n* Inline Code: Select text, Cmd + K\n* Strikethrough: Select text, Cmd + U\n* Link: Select text, Control + Shift + L\n* Image: Select text, Control + Shift + I\n* Select Word: Control + Option + W\n* Select Line: Shift + Cmd + L\n* Select All: Cmd + A\n* Deselect All: Cmd + D\n* Convert to Uppercase: Select text, Control + U\n* Convert to Lowercase: Select text, Control + Shift + U\n* Convert to Titlecase: Select text, Control + Option + U\n* Convert to List: Select lines, Control + L\n* Convert to Blockquote: Select lines, Control + Q\n* Convert to H1: Cmd + 1\n* Convert to H2: Cmd + 2\n* Convert to H3: Cmd + 3\n* Convert to H4: Cmd + 4\n* Convert to H5: Cmd + 5\n* Convert to H6: Cmd + 6\n* Convert Spaces to Tabs: Control + [\n* Convert Tabs to Spaces: Control + ]\n* Insert Current Date: Control + Shift + 1\n* Insert Current Time: Control + Shift + 2\n* Insert entity <: Control + Shift + ,\n* Insert entity >: Control + Shift + .\n* Insert entity &: Control + Shift + 7\n* Insert entity Space: Control + Shift + Space\n* Insert Scriptogr.am Header: Control + Shift + G\n* Shift Line Left: Select lines, Cmd + [\n* Shift Line Right: Select lines, Cmd + ]\n* New Line: Cmd + Return\n* Comment: Cmd + /\n* Hard Linebreak: Control + Return\n\n### 编辑\n\n* Auto complete current word: Esc\n* Find: Cmd + F\n* Close find bar: Esc\n\n### Post\n\n* Post on Scriptogr.am: Control + Shift + S\n* Post on Tumblr: Control + Shift + T\n\n### 导出\n\n* Export HTML: Option + Cmd + E\n* Export PDF:  Option + Cmd + P\n\n\n### And more?\n\nDon't forget to check Preferences, lots of useful options are there.\n\nFollow [@Mou](https://twitter.com/mou) on Twitter for the latest news.\n\nFor feedback, use the menu `Help` - `Send Feedback`\n\n# hello-world.md\n\n","slug":"hello-world","published":1,"updated":"2016-04-19T07:55:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinb2xt6c0001bgv0htx6dqiq","content":"<p>基于hexo搭好了个人博客，在这里记录并测试一下。</p>\n<h1 id=\"hexo的安装步骤\"><a href=\"#hexo的安装步骤\" class=\"headerlink\" title=\"hexo的安装步骤\"></a>hexo的安装步骤</h1><p>参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/index.html\" target=\"_blank\" rel=\"external\">hexo.io</a></p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><h2 id=\"Node-js版本\"><a href=\"#Node-js版本\" class=\"headerlink\" title=\"Node.js版本\"></a>Node.js版本</h2><ul>\n<li>不使用最新版本的Node.js，使用官方文档建议的v4；</li>\n</ul>\n<h2 id=\"disqus集成\"><a href=\"#disqus集成\" class=\"headerlink\" title=\"disqus集成\"></a>disqus集成</h2><ul>\n<li>注册disqus；</li>\n<li>将short_name添加到_config.yml；</li>\n<li>注意修改disqus设置为中文；</li>\n<li>不使用评论：<br>  在front-matter中添加一行  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">comments:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"maupassant主题\"><a href=\"#maupassant主题\" class=\"headerlink\" title=\"maupassant主题\"></a>maupassant主题</h2><p>使用<a href=\"https://www.haomwei.com/\" target=\"_blank\" rel=\"external\">屠城</a>的主题，感谢！</p>\n<ul>\n<li><p>添加关于(about)，历史（history），留言（guestbook）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> page abou</span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> page <span class=\"keyword\">history</span></span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> page guestbook</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>_config.yml的menu中添加：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"attribute\">page</span>: about</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: about/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-user</span><br><span class=\"line\">- <span class=\"attribute\">page</span>: history</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: history/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-book</span><br><span class=\"line\">- <span class=\"attribute\">page</span>: guestbook</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: guestbook/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-comments</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加时间轴</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">---</span></span><br><span class=\"line\">title: 时间轴</span><br><span class=\"line\"><span class=\"built_in\">date</span>: <span class=\"number\">2016</span><span class=\"number\">-04</span><span class=\"number\">-07</span> <span class=\"number\">15</span>:<span class=\"number\">12</span>:<span class=\"number\">10</span></span><br><span class=\"line\">comments: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">---</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline\"</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline-item active\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"year\"</span>&gt;<span class=\"number\">2014</span>&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"marker\"</span>&gt;&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"dot\"</span>&gt;&lt;/span&gt;&lt;/span&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"info\"</span>&gt;</span><br><span class=\"line\">\t\t\t注册域名jackalope.cn</span><br><span class=\"line\">\t\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline-item active\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"year\"</span>&gt;<span class=\"number\">2016</span>&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"marker\"</span>&gt;&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"dot\"</span>&gt;&lt;/span&gt;&lt;/span&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"info\"</span>&gt;初试个人博客，使用hexo搭建，托管于Github&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2>\n\n<h1 id=\"Mou的使用\"><a href=\"#Mou的使用\" class=\"headerlink\" title=\"Mou的使用\"></a>Mou的使用</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>将#号写在行首表示标题，标题1 - 标题6，数字对应#号个数</p>\n<h2 id=\"加粗\"><a href=\"#加粗\" class=\"headerlink\" title=\"加粗\"></a>加粗</h2><p>未加粗/<strong>加粗</strong>（aaa/<strong>aaa</strong>）(快捷链：Cmd + B)</p>\n<h2 id=\"倾斜\"><a href=\"#倾斜\" class=\"headerlink\" title=\"倾斜\"></a>倾斜</h2><p>未倾斜/<em>倾斜</em>（aaa/<em>aaa</em>）(快捷键：Cmd + I)</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>把 &gt; 写到开头，本质上是生成blockquote标签</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://jackalope.cn\">jackalope</a></p>\n<h2 id=\"邮件\"><a href=\"#邮件\" class=\"headerlink\" title=\"邮件\"></a>邮件</h2><p><a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#122;&#111;&#119;&#105;&#101;&#x5f;&#x63;&#x68;&#x65;&#x6e;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;\">&#122;&#111;&#119;&#105;&#101;&#x5f;&#x63;&#x68;&#x65;&#x6e;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>内嵌图片，直接写入具体图片地址<br><img src=\"http://25.io/smaller/favicon.ico\" alt=\"内嵌图片\" title=\"Title here\"></p>\n<p>引用图片，先指定图片名称，之后再将图片名称映射到具体图片地址<br><img src=\"http://resizesafari.com/favicon.ico\" alt=\"引用图片\" title=\"Title\"></p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>使用3个及以上着重符(`)开始并结束：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System<span class=\"selector-class\">.out</span><span class=\"selector-class\">.println</span>(<span class=\"string\">\"Hello world!\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><p>使用”1.” + 空格</p>\n<ol>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ol>\n<h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>使用”*” + 空格</p>\n<ul>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ul>\n<p>或者”-“ + 空格</p>\n<ul>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ul>\n<h2 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\"></a>换行符</h2><p>两个及以上空格即可生成一个换行符<code>&lt;br /&gt;</code></p>\n<h2 id=\"水平分隔符\"><a href=\"#水平分隔符\" class=\"headerlink\" title=\"水平分隔符\"></a>水平分隔符</h2><p>三个及以上 “*” 或 “-“ 或 “- “，每行之前有空行</p>\n<hr>\n<hr>\n<hr>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚本，跳到标题<a href=\"#标题\">^1</a></p>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>使用两个~开始并结束<br><del>ZZZZZZzzzzzz</del></p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>列使用|分开，头尾的|可加可不加；<br>列名与行使用多个-分开，:—-表示左对齐，:—-:表示两端对齐，—-:表示右对齐，<code>PS: 表格上方有一空行</code></p>\n<table>\n<thead>\n<tr>\n<th>列1</th>\n<th>列2</th>\n<th>列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n<p><code>列补齐&quot;|&quot;</code></p>\n<table>\n<thead>\n<tr>\n<th>列1</th>\n<th>列2</th>\n<th>列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n<p><code>左中右对齐</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">列1</th>\n<th style=\"text-align:center\">列2</th>\n<th style=\"text-align:right\">列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:right\">13</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">21</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:right\">23</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">31</td>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:right\">33</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"快捷链\"><a href=\"#快捷链\" class=\"headerlink\" title=\"快捷链\"></a>快捷链</h2><h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><ul>\n<li>预览: Shift + Cmd + I</li>\n<li>统计字数: Shift + Cmd + W</li>\n<li>透明: Shift + Cmd + T</li>\n<li>悬浮，永在最前: Shift + Cmd + F</li>\n<li>左右窗口大小1/1: Cmd + 0</li>\n<li>左右窗口大小3/1: Cmd + +</li>\n<li>左右窗口大小1/3: Cmd + -</li>\n<li>书写方向: Cmd + L</li>\n<li>全屏/退出全屏: Control + Cmd + F</li>\n</ul>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><ul>\n<li>拷贝html: Option + Cmd + C</li>\n<li>加黑加粗: Select text, Cmd + B</li>\n<li>倾斜: Select text, Cmd + I</li>\n<li>Inline Code: Select text, Cmd + K</li>\n<li>Strikethrough: Select text, Cmd + U</li>\n<li>Link: Select text, Control + Shift + L</li>\n<li>Image: Select text, Control + Shift + I</li>\n<li>Select Word: Control + Option + W</li>\n<li>Select Line: Shift + Cmd + L</li>\n<li>Select All: Cmd + A</li>\n<li>Deselect All: Cmd + D</li>\n<li>Convert to Uppercase: Select text, Control + U</li>\n<li>Convert to Lowercase: Select text, Control + Shift + U</li>\n<li>Convert to Titlecase: Select text, Control + Option + U</li>\n<li>Convert to List: Select lines, Control + L</li>\n<li>Convert to Blockquote: Select lines, Control + Q</li>\n<li>Convert to H1: Cmd + 1</li>\n<li>Convert to H2: Cmd + 2</li>\n<li>Convert to H3: Cmd + 3</li>\n<li>Convert to H4: Cmd + 4</li>\n<li>Convert to H5: Cmd + 5</li>\n<li>Convert to H6: Cmd + 6</li>\n<li>Convert Spaces to Tabs: Control + [</li>\n<li>Convert Tabs to Spaces: Control + ]</li>\n<li>Insert Current Date: Control + Shift + 1</li>\n<li>Insert Current Time: Control + Shift + 2</li>\n<li>Insert entity &lt;: Control + Shift + ,</li>\n<li>Insert entity &gt;: Control + Shift + .</li>\n<li>Insert entity &amp;: Control + Shift + 7</li>\n<li>Insert entity Space: Control + Shift + Space</li>\n<li>Insert Scriptogr.am Header: Control + Shift + G</li>\n<li>Shift Line Left: Select lines, Cmd + [</li>\n<li>Shift Line Right: Select lines, Cmd + ]</li>\n<li>New Line: Cmd + Return</li>\n<li>Comment: Cmd + /</li>\n<li>Hard Linebreak: Control + Return</li>\n</ul>\n<h3 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h3><ul>\n<li>Auto complete current word: Esc</li>\n<li>Find: Cmd + F</li>\n<li>Close find bar: Esc</li>\n</ul>\n<h3 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h3><ul>\n<li>Post on Scriptogr.am: Control + Shift + S</li>\n<li>Post on Tumblr: Control + Shift + T</li>\n</ul>\n<h3 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h3><ul>\n<li>Export HTML: Option + Cmd + E</li>\n<li>Export PDF:  Option + Cmd + P</li>\n</ul>\n<h3 id=\"And-more\"><a href=\"#And-more\" class=\"headerlink\" title=\"And more?\"></a>And more?</h3><p>Don’t forget to check Preferences, lots of useful options are there.</p>\n<p>Follow <a href=\"https://twitter.com/mou\" target=\"_blank\" rel=\"external\">@Mou</a> on Twitter for the latest news.</p>\n<p>For feedback, use the menu <code>Help</code> - <code>Send Feedback</code></p>\n<h1 id=\"hello-world-md\"><a href=\"#hello-world-md\" class=\"headerlink\" title=\"hello-world.md\"></a>hello-world.md</h1>","excerpt":"","more":"<p>基于hexo搭好了个人博客，在这里记录并测试一下。</p>\n<h1 id=\"hexo的安装步骤\"><a href=\"#hexo的安装步骤\" class=\"headerlink\" title=\"hexo的安装步骤\"></a>hexo的安装步骤</h1><p>参考官方文档：<a href=\"https://hexo.io/zh-cn/docs/index.html\">hexo.io</a></p>\n<h1 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h1><h2 id=\"Node-js版本\"><a href=\"#Node-js版本\" class=\"headerlink\" title=\"Node.js版本\"></a>Node.js版本</h2><ul>\n<li>不使用最新版本的Node.js，使用官方文档建议的v4；</li>\n</ul>\n<h2 id=\"disqus集成\"><a href=\"#disqus集成\" class=\"headerlink\" title=\"disqus集成\"></a>disqus集成</h2><ul>\n<li>注册disqus；</li>\n<li>将short_name添加到_config.yml；</li>\n<li>注意修改disqus设置为中文；</li>\n<li>不使用评论：<br>  在front-matter中添加一行  <figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">comments:</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"maupassant主题\"><a href=\"#maupassant主题\" class=\"headerlink\" title=\"maupassant主题\"></a>maupassant主题</h2><p>使用<a href=\"https://www.haomwei.com/\">屠城</a>的主题，感谢！</p>\n<ul>\n<li><p>添加关于(about)，历史（history），留言（guestbook）</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">new</span> page abou</span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> page <span class=\"keyword\">history</span></span><br><span class=\"line\">hexo <span class=\"keyword\">new</span> page guestbook</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>_config.yml的menu中添加：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- <span class=\"attribute\">page</span>: about</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: about/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-user</span><br><span class=\"line\">- <span class=\"attribute\">page</span>: history</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: history/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-book</span><br><span class=\"line\">- <span class=\"attribute\">page</span>: guestbook</span><br><span class=\"line\">  <span class=\"attribute\">directory</span>: guestbook/</span><br><span class=\"line\">  <span class=\"attribute\">icon</span>: fa-comments</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加时间轴</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">---</span></span><br><span class=\"line\">title: 时间轴</span><br><span class=\"line\"><span class=\"built_in\">date</span>: <span class=\"number\">2016</span><span class=\"number\">-04</span><span class=\"number\">-07</span> <span class=\"number\">15</span>:<span class=\"number\">12</span>:<span class=\"number\">10</span></span><br><span class=\"line\">comments: <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"comment\">---</span></span><br><span class=\"line\">&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline\"</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline-item active\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"year\"</span>&gt;<span class=\"number\">2014</span>&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"marker\"</span>&gt;&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"dot\"</span>&gt;&lt;/span&gt;&lt;/span&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"info\"</span>&gt;</span><br><span class=\"line\">\t\t\t注册域名jackalope.cn</span><br><span class=\"line\">\t\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"timeline-item active\"</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"year\"</span>&gt;<span class=\"number\">2016</span>&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"marker\"</span>&gt;&lt;span <span class=\"built_in\">class</span>=<span class=\"string\">\"dot\"</span>&gt;&lt;/span&gt;&lt;/span&gt;&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t\t&lt;<span class=\"keyword\">div</span> <span class=\"built_in\">class</span>=<span class=\"string\">\"info\"</span>&gt;初试个人博客，使用hexo搭建，托管于Github&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">\t&lt;/<span class=\"keyword\">div</span>&gt;</span><br><span class=\"line\">&lt;/<span class=\"keyword\">div</span>&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2>\n\n<h1 id=\"Mou的使用\"><a href=\"#Mou的使用\" class=\"headerlink\" title=\"Mou的使用\"></a>Mou的使用</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><p>将#号写在行首表示标题，标题1 - 标题6，数字对应#号个数</p>\n<h2 id=\"加粗\"><a href=\"#加粗\" class=\"headerlink\" title=\"加粗\"></a>加粗</h2><p>未加粗/<strong>加粗</strong>（aaa/<strong>aaa</strong>）(快捷链：Cmd + B)</p>\n<h2 id=\"倾斜\"><a href=\"#倾斜\" class=\"headerlink\" title=\"倾斜\"></a>倾斜</h2><p>未倾斜/<em>倾斜</em>（aaa/<em>aaa</em>）(快捷键：Cmd + I)</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><blockquote>\n<p>把 &gt; 写到开头，本质上是生成blockquote标签</p>\n</blockquote>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p><a href=\"http://jackalope.cn\">jackalope</a></p>\n<h2 id=\"邮件\"><a href=\"#邮件\" class=\"headerlink\" title=\"邮件\"></a>邮件</h2><p><a href=\"&#x6d;&#x61;&#105;&#x6c;&#x74;&#111;&#58;&#122;&#111;&#119;&#105;&#101;&#x5f;&#x63;&#x68;&#x65;&#x6e;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;\">&#122;&#111;&#119;&#105;&#101;&#x5f;&#x63;&#x68;&#x65;&#x6e;&#64;&#49;&#x36;&#x33;&#x2e;&#x63;&#111;&#109;</a></p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>内嵌图片，直接写入具体图片地址<br><img src=\"http://25.io/smaller/favicon.ico\" alt=\"内嵌图片\" title=\"Title here\"></p>\n<p>引用图片，先指定图片名称，之后再将图片名称映射到具体图片地址<br><img src=\"http://resizesafari.com/favicon.ico\" alt=\"引用图片\" title=\"Title\"></p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>使用3个及以上着重符(`)开始并结束：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">System<span class=\"selector-class\">.out</span><span class=\"selector-class\">.println</span>(<span class=\"string\">\"Hello world!\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"有序列表\"><a href=\"#有序列表\" class=\"headerlink\" title=\"有序列表\"></a>有序列表</h2><p>使用”1.” + 空格</p>\n<ol>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ol>\n<h2 id=\"无序列表\"><a href=\"#无序列表\" class=\"headerlink\" title=\"无序列表\"></a>无序列表</h2><p>使用”*” + 空格</p>\n<ul>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ul>\n<p>或者”-“ + 空格</p>\n<ul>\n<li>111</li>\n<li>222</li>\n<li>333</li>\n</ul>\n<h2 id=\"换行符\"><a href=\"#换行符\" class=\"headerlink\" title=\"换行符\"></a>换行符</h2><p>两个及以上空格即可生成一个换行符<code>&lt;br /&gt;</code></p>\n<h2 id=\"水平分隔符\"><a href=\"#水平分隔符\" class=\"headerlink\" title=\"水平分隔符\"></a>水平分隔符</h2><p>三个及以上 “*” 或 “-“ 或 “- “，每行之前有空行</p>\n<hr>\n<hr>\n<hr>\n<h2 id=\"脚注\"><a href=\"#脚注\" class=\"headerlink\" title=\"脚注\"></a>脚注</h2><p>脚本，跳到标题<a href=\"#标题\">^1</a></p>\n<h2 id=\"删除线\"><a href=\"#删除线\" class=\"headerlink\" title=\"删除线\"></a>删除线</h2><p>使用两个~开始并结束<br><del>ZZZZZZzzzzzz</del></p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>列使用|分开，头尾的|可加可不加；<br>列名与行使用多个-分开，:—-表示左对齐，:—-:表示两端对齐，—-:表示右对齐，<code>PS: 表格上方有一空行</code></p>\n<table>\n<thead>\n<tr>\n<th>列1</th>\n<th>列2</th>\n<th>列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n<p><code>列补齐&quot;|&quot;</code></p>\n<table>\n<thead>\n<tr>\n<th>列1</th>\n<th>列2</th>\n<th>列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n<p><code>左中右对齐</code></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">列1</th>\n<th style=\"text-align:center\">列2</th>\n<th style=\"text-align:right\">列3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:center\">12</td>\n<td style=\"text-align:right\">13</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">21</td>\n<td style=\"text-align:center\">22</td>\n<td style=\"text-align:right\">23</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">31</td>\n<td style=\"text-align:center\">32</td>\n<td style=\"text-align:right\">33</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"快捷链\"><a href=\"#快捷链\" class=\"headerlink\" title=\"快捷链\"></a>快捷链</h2><h3 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h3><ul>\n<li>预览: Shift + Cmd + I</li>\n<li>统计字数: Shift + Cmd + W</li>\n<li>透明: Shift + Cmd + T</li>\n<li>悬浮，永在最前: Shift + Cmd + F</li>\n<li>左右窗口大小1/1: Cmd + 0</li>\n<li>左右窗口大小3/1: Cmd + +</li>\n<li>左右窗口大小1/3: Cmd + -</li>\n<li>书写方向: Cmd + L</li>\n<li>全屏/退出全屏: Control + Cmd + F</li>\n</ul>\n<h3 id=\"操作\"><a href=\"#操作\" class=\"headerlink\" title=\"操作\"></a>操作</h3><ul>\n<li>拷贝html: Option + Cmd + C</li>\n<li>加黑加粗: Select text, Cmd + B</li>\n<li>倾斜: Select text, Cmd + I</li>\n<li>Inline Code: Select text, Cmd + K</li>\n<li>Strikethrough: Select text, Cmd + U</li>\n<li>Link: Select text, Control + Shift + L</li>\n<li>Image: Select text, Control + Shift + I</li>\n<li>Select Word: Control + Option + W</li>\n<li>Select Line: Shift + Cmd + L</li>\n<li>Select All: Cmd + A</li>\n<li>Deselect All: Cmd + D</li>\n<li>Convert to Uppercase: Select text, Control + U</li>\n<li>Convert to Lowercase: Select text, Control + Shift + U</li>\n<li>Convert to Titlecase: Select text, Control + Option + U</li>\n<li>Convert to List: Select lines, Control + L</li>\n<li>Convert to Blockquote: Select lines, Control + Q</li>\n<li>Convert to H1: Cmd + 1</li>\n<li>Convert to H2: Cmd + 2</li>\n<li>Convert to H3: Cmd + 3</li>\n<li>Convert to H4: Cmd + 4</li>\n<li>Convert to H5: Cmd + 5</li>\n<li>Convert to H6: Cmd + 6</li>\n<li>Convert Spaces to Tabs: Control + [</li>\n<li>Convert Tabs to Spaces: Control + ]</li>\n<li>Insert Current Date: Control + Shift + 1</li>\n<li>Insert Current Time: Control + Shift + 2</li>\n<li>Insert entity &lt;: Control + Shift + ,</li>\n<li>Insert entity &gt;: Control + Shift + .</li>\n<li>Insert entity &amp;: Control + Shift + 7</li>\n<li>Insert entity Space: Control + Shift + Space</li>\n<li>Insert Scriptogr.am Header: Control + Shift + G</li>\n<li>Shift Line Left: Select lines, Cmd + [</li>\n<li>Shift Line Right: Select lines, Cmd + ]</li>\n<li>New Line: Cmd + Return</li>\n<li>Comment: Cmd + /</li>\n<li>Hard Linebreak: Control + Return</li>\n</ul>\n<h3 id=\"编辑\"><a href=\"#编辑\" class=\"headerlink\" title=\"编辑\"></a>编辑</h3><ul>\n<li>Auto complete current word: Esc</li>\n<li>Find: Cmd + F</li>\n<li>Close find bar: Esc</li>\n</ul>\n<h3 id=\"Post\"><a href=\"#Post\" class=\"headerlink\" title=\"Post\"></a>Post</h3><ul>\n<li>Post on Scriptogr.am: Control + Shift + S</li>\n<li>Post on Tumblr: Control + Shift + T</li>\n</ul>\n<h3 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h3><ul>\n<li>Export HTML: Option + Cmd + E</li>\n<li>Export PDF:  Option + Cmd + P</li>\n</ul>\n<h3 id=\"And-more\"><a href=\"#And-more\" class=\"headerlink\" title=\"And more?\"></a>And more?</h3><p>Don’t forget to check Preferences, lots of useful options are there.</p>\n<p>Follow <a href=\"https://twitter.com/mou\">@Mou</a> on Twitter for the latest news.</p>\n<p>For feedback, use the menu <code>Help</code> - <code>Send Feedback</code></p>\n<h1 id=\"hello-world-md\"><a href=\"#hello-world-md\" class=\"headerlink\" title=\"hello-world.md\"></a>hello-world.md</h1>"},{"title":"JNI（Java Native Interface）原理与使用","date":"2016-04-13T08:44:39.000Z","toc":true,"_content":"\n# 概述\nJava本地接口（Java Native Interface(JNI)）允许运行在Java虚拟机(Java Virtual Machine(JVM))上的代码调用本地程序和类库，或者被它们调用，这些程序和类库可以是其他语言编写的，比如：C、C++或汇编语言。\n很多基本类库都依赖JNI来为开发者和用户提供服务，比如文件的输入/输出和音频功能。在基本类库中包含的对于性能和平台敏感的API可以允许所有的Java程序以安全和平台无关的方式来使用这些功能。\n\n# 知识图\n\n![](jni.png)\n\n# 一些宏定义\nwindows宏定义的代码位置：\n`./jdk/src/windows/javavm/export/jni_md.h`）；\n非windows宏定义代码位置（以MAC为例）：\n`./jdk/src/macosx/javavm/export/jni_md.h`）\n\n## JNIEXPORT\nwindows:\n`#define JNIEXPORT __declspec(dllexport)`\n非windows:\n`#define JNIEXPORT`\n\n## JNIIMPORT\nwindows:\n`#define JNIIMPORT __declspec(dllimport)`\n非windows:\n`#define JNIIMPORT`\n\n## JNICALL\nwindows:\n`#define JNICALL __stdcall`\n非windows:\n`#define JNICALL`\n\n# 实例\n## 使用javah\n### java代码\n\n编写java代码，并生成C/C++头文件；\n\n程序清单1: `HelloJni.java`\n\n```\npackage org.jackalope.study.jni;\n\npublic class HelloJni {\n\n    static {\n        System.loadLibrary(\"HelloJni\");\n    }\n\n    public native void DisplayHello();\n\n    public static void main(String[] args) {\n        new HelloJni().DisplayHello();\n    }\n\n}\n```\n\n进入src目录下，编译该JAVA类：\n\n`javac HelloJni.java`\n\n生成头文件：\n\n`javah org.jackalope.study.jni.HelloJni`\n\n得到头文件 org_jackalope_study_jni_HelloJni.h，此文件供C、C++程序来引用并实现其中的函数\n\n程序清单2: `org_jackalope_study_jni_HelloJni.h`\n\n```\n* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class org_jackalope_study_jni_HelloJni */\n\n#ifndef _Included_org_jackalope_study_jni_HelloJni\n#define _Included_org_jackalope_study_jni_HelloJni\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     org_jackalope_study_jni_HelloJni\n * Method:    DisplayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_org_jackalope_study_jni_HelloJni_DisplayHello\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n### C++代码\n\n编写C++代码，实现函数功能 ———— 打印\"HelloJni\"。\n\n程序清单3：jni_helloworldImpl.cpp\n\n```\n#include <jni.h>\n#include org_jackalope_study_jni_HelloJni.h\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_org_jackalope_study_jni_HelloJni_DisplayHello(JNIEnv *env, jobject obj)\n{\n    printf(\"From org_jackalope_study_jni_HelloJni.cpp :\");\n    printf(\"Hello world ! \\n\");\n    return;\n}\n```\n\n此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。\n编译生成动态库libHelloJni.jnilib:\n`g++ -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/include/ org_jackalope_study_jni_HelloJni.cpp -o libHelloJni.jnilib`\n\n注意：在mac下后缀名应当写为jnilib，这是由\n./jdk/src/macosx/classes/java/lang/ClassLoaderHelper.java中的mapAlternativeName方法引起的，代码如下：\n\n```\n// For mac, this replaces the final .dylib suffix with .jnilib\nint index = name.toLowerCase().lastIndexOf(\".dylib\");\nif (index < 0) {\n\treturn null;\n}\nreturn new File(name.substring(0, index) + \".jnilib\");\n```\n\n注意：\n\tmac下会提示找不到jni_md.h，创建一个软链接即可解决：\n\t`sudo ln -s darwin/jni_md.h jni_md.h`\n\t\n成功后，便会在当前目录下生成动态链接库libHelloJni.jnilib文件。\n有了具体实现的动态库后，就可以运行JAVA调用JNI程序类的native方法了:\n`java -Djava.library.path=../c++/  org.jackalope.study.jni.HelloJni`\n输出：\nFrom org_jackalope_study_jni_HelloJni.cpp :Hello world !\n\n## 使用RegisterNatives\n### 优点\n1. C＋＋中函数命名自由，不必像javah自动生成的函数声明那样，拘泥特定的命名方式；\n2. 效率高。传统方式下，Java类call本地函数时，通常是依靠VM去动态寻找.so中的本地函数(因此它们才需要特定规则的命名格式)，而使用RegisterNatives将本地函数向VM进行登记，可以让其更有效率的找到函数；\n3. 运行时动态调整本地函数与Java函数值之间的映射关系，只需要多次call RegisterNatives()方法，并传入不同的映射表参数即可。\n\n为了使用RegisterNatives，我们需要了解JNI_OnLoad和JNI_OnUnload函数。JNI_OnLoad()函数在VM执行System.loadLibrary(xxx)函数时被调用，它有两个重要的作用：\n* 指定JNI版本：告诉VM该组件使用那一个JNI版本(若未提供JNI_OnLoad()函数，VM会默认该使用最老的JNI 1.1版)，如果要使用新版本的JNI，例如JNI 1.4版，则必须由JNI_OnLoad()函数返回常量JNI_VERSION_1_4(该常量定义在jni.h中) 来告知VM。\n* 初始化设定，当VM执行到System.loadLibrary()函数时，会立即先呼叫JNI_OnLoad()方法，因此在该方法中进行各种资源的初始化操作最为恰当，RegisterNatives也在这里进行。\n\nJNI_OnUnload()当VM释放该组件时被调用，JNI_OnUnload()函数的作用与JNI_OnLoad()对应，因此在该方法中进行善后清理，资源释放的动作最为合适。\n\n### Java代码\nJava代码和使用哪种方式实现JNI无关，如下所示：\n```\nclass MyJavaClass\n{\n public int iValue;\n public void Squa(){iValue = iValue*iValue;}\n}\npublic class RegisterNativesTest\n{\n static{\n  System.load(\"/home/zmh/workspace/RegisterNativesTest/lib/libCallClass.so\");\n }\n public static void main(String[] args)\n {\n  RegisterNativesTest app = new RegisterNativesTest();\n  MyJavaClass obj = new MyJavaClass();\n  obj.iValue = 10;\n  System.out.println(\"Before callCustomClass: \" + obj.iValue);\n  app.callCustomClass(obj);\n  System.out.println(\"After callCustomClass: \" + obj.iValue);\n }\n private native void callCustomClass(MyJavaClass obj);\n}\n\n```\n\n### C++代码\nC＋＋的代码可以分为两部分：实现callCustomClass方法和注册callCustomClass。\n实现callCustomClass方法的代码如下：\n\n```\nvoid callCustomClass(JNIEnv* env, jobject, jobject obj)\n{\n jclass cls = env->GetObjectClass(obj);\n jfieldID fid = env->GetFieldID(cls, \"iValue\", \"I\");\n jmethodID mid = env->GetMethodID(cls, \"Squa\", \"()V\");\n int value = env->GetIntField(obj, fid);\n printf(\"Native: %d\\n\", value);\n env->SetIntField(obj, fid, 5);\n env->CallVoidMethod(obj, mid);\n value = env->GetIntField(obj, fid);\n printf(\"Native:%d\\n\", value);\n}\n```\n\nC＋＋函数内忽略this指针，他所接收的jobject是“Java程序代码传递过来的Java object reference“在原生端的形式，在C＋＋中对jobject的改变在java中也是有效的。如果想要访问Java数据成员和函数，得先使用GetFieldID或GetMethodID分别获取数据成员和函数的识别码，这两个函数的参数依次为1）class object；2）包含元素名称的字符串；3）表示类型的字符串。\n注册callCustomClass在JNI_OnLoad中进行，代码如下：\n\n```\nstatic JNINativeMethod s_methods[] = {\n{\"callCustomClass\", \"(LMyJavaClass;)V\", (void*)callCustomClass},\n};\n\nint JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n JNIEnv* env = NULL;\n   if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK)\n   {\n      return JNI_ERR;\n   }\n\n jclass cls = env->FindClass(\"LRegisterNativesTest;\");\n   if (cls == NULL)\n   {\n      return JNI_ERR;\n   }\n\n   int len = sizeof(s_methods) / sizeof(s_methods[0]);\n   if (env->RegisterNatives(cls, s_methods, len) < 0)\n   {\n      return JNI_ERR;\n   }\n\n   return JNI_VERSION_1_4;\n}\n```\n\n在C＋＋和Java中创建关联的是JNINativeMethod，它在jni.h中定义：\n\n```\n/*\n * used in RegisterNatives to describe native method name, signature,\n * and function pointer.\n */\ntypedef struct {\n    char *name;\n    char *signature;\n    void *fnPtr;\n} JNINativeMethod;\n```\n\nname是java中定义的native函数的名字，fnPtr是函数指针，也就是C＋＋中java native函数的实现。signature是java native函数的签名，可以认为是参数和返回值。比如(LMyJavaClass;)V，表示函数的参数是LMyJavaClass，返回值是void。对于基本类型，对应关系如下：\n\n```\n字符     Java类型     C/C++类型\nV           void         void\nZ         jboolean      boolean\nI            jint           int\nJ           jlong         long\nD         jdouble       double\nF          jfloat         float\nB          jbyte         byte\nC          jchar          char\nS          jshort        short\n```\n\n数组则以\"[\"开始，用两个字符表示，比如int数组表示为［I，以此类推。\n如果参数是Java类，则以\"L\"开头，以\";\"结尾，中间是用\"/\"隔开包及类名，例如Ljava/lang/String;，而其对应的C＋＋函数的参数为jobject，一个例外是String类，它对应C＋＋类型jstring。\n\n# 参考链接\n\n[JAVA基础之理解JNI原理](http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html)\n[JNI：使用RegisterNatives方法传递和使用Java自定义类](http://blog.csdn.net/qiuxiaolong007/article/details/7860610)","source":"_posts/java-core-jni.md","raw":"---\ntitle: JNI（Java Native Interface）原理与使用\ndate: 2016-04-13 16:44:39\ntoc: true\ntags: \n- java\n- jni\ncategories: \n- java基础\n\n---\n\n# 概述\nJava本地接口（Java Native Interface(JNI)）允许运行在Java虚拟机(Java Virtual Machine(JVM))上的代码调用本地程序和类库，或者被它们调用，这些程序和类库可以是其他语言编写的，比如：C、C++或汇编语言。\n很多基本类库都依赖JNI来为开发者和用户提供服务，比如文件的输入/输出和音频功能。在基本类库中包含的对于性能和平台敏感的API可以允许所有的Java程序以安全和平台无关的方式来使用这些功能。\n\n# 知识图\n\n![](jni.png)\n\n# 一些宏定义\nwindows宏定义的代码位置：\n`./jdk/src/windows/javavm/export/jni_md.h`）；\n非windows宏定义代码位置（以MAC为例）：\n`./jdk/src/macosx/javavm/export/jni_md.h`）\n\n## JNIEXPORT\nwindows:\n`#define JNIEXPORT __declspec(dllexport)`\n非windows:\n`#define JNIEXPORT`\n\n## JNIIMPORT\nwindows:\n`#define JNIIMPORT __declspec(dllimport)`\n非windows:\n`#define JNIIMPORT`\n\n## JNICALL\nwindows:\n`#define JNICALL __stdcall`\n非windows:\n`#define JNICALL`\n\n# 实例\n## 使用javah\n### java代码\n\n编写java代码，并生成C/C++头文件；\n\n程序清单1: `HelloJni.java`\n\n```\npackage org.jackalope.study.jni;\n\npublic class HelloJni {\n\n    static {\n        System.loadLibrary(\"HelloJni\");\n    }\n\n    public native void DisplayHello();\n\n    public static void main(String[] args) {\n        new HelloJni().DisplayHello();\n    }\n\n}\n```\n\n进入src目录下，编译该JAVA类：\n\n`javac HelloJni.java`\n\n生成头文件：\n\n`javah org.jackalope.study.jni.HelloJni`\n\n得到头文件 org_jackalope_study_jni_HelloJni.h，此文件供C、C++程序来引用并实现其中的函数\n\n程序清单2: `org_jackalope_study_jni_HelloJni.h`\n\n```\n* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class org_jackalope_study_jni_HelloJni */\n\n#ifndef _Included_org_jackalope_study_jni_HelloJni\n#define _Included_org_jackalope_study_jni_HelloJni\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     org_jackalope_study_jni_HelloJni\n * Method:    DisplayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_org_jackalope_study_jni_HelloJni_DisplayHello\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\n\n### C++代码\n\n编写C++代码，实现函数功能 ———— 打印\"HelloJni\"。\n\n程序清单3：jni_helloworldImpl.cpp\n\n```\n#include <jni.h>\n#include org_jackalope_study_jni_HelloJni.h\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_org_jackalope_study_jni_HelloJni_DisplayHello(JNIEnv *env, jobject obj)\n{\n    printf(\"From org_jackalope_study_jni_HelloJni.cpp :\");\n    printf(\"Hello world ! \\n\");\n    return;\n}\n```\n\n此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。\n编译生成动态库libHelloJni.jnilib:\n`g++ -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/include/ org_jackalope_study_jni_HelloJni.cpp -o libHelloJni.jnilib`\n\n注意：在mac下后缀名应当写为jnilib，这是由\n./jdk/src/macosx/classes/java/lang/ClassLoaderHelper.java中的mapAlternativeName方法引起的，代码如下：\n\n```\n// For mac, this replaces the final .dylib suffix with .jnilib\nint index = name.toLowerCase().lastIndexOf(\".dylib\");\nif (index < 0) {\n\treturn null;\n}\nreturn new File(name.substring(0, index) + \".jnilib\");\n```\n\n注意：\n\tmac下会提示找不到jni_md.h，创建一个软链接即可解决：\n\t`sudo ln -s darwin/jni_md.h jni_md.h`\n\t\n成功后，便会在当前目录下生成动态链接库libHelloJni.jnilib文件。\n有了具体实现的动态库后，就可以运行JAVA调用JNI程序类的native方法了:\n`java -Djava.library.path=../c++/  org.jackalope.study.jni.HelloJni`\n输出：\nFrom org_jackalope_study_jni_HelloJni.cpp :Hello world !\n\n## 使用RegisterNatives\n### 优点\n1. C＋＋中函数命名自由，不必像javah自动生成的函数声明那样，拘泥特定的命名方式；\n2. 效率高。传统方式下，Java类call本地函数时，通常是依靠VM去动态寻找.so中的本地函数(因此它们才需要特定规则的命名格式)，而使用RegisterNatives将本地函数向VM进行登记，可以让其更有效率的找到函数；\n3. 运行时动态调整本地函数与Java函数值之间的映射关系，只需要多次call RegisterNatives()方法，并传入不同的映射表参数即可。\n\n为了使用RegisterNatives，我们需要了解JNI_OnLoad和JNI_OnUnload函数。JNI_OnLoad()函数在VM执行System.loadLibrary(xxx)函数时被调用，它有两个重要的作用：\n* 指定JNI版本：告诉VM该组件使用那一个JNI版本(若未提供JNI_OnLoad()函数，VM会默认该使用最老的JNI 1.1版)，如果要使用新版本的JNI，例如JNI 1.4版，则必须由JNI_OnLoad()函数返回常量JNI_VERSION_1_4(该常量定义在jni.h中) 来告知VM。\n* 初始化设定，当VM执行到System.loadLibrary()函数时，会立即先呼叫JNI_OnLoad()方法，因此在该方法中进行各种资源的初始化操作最为恰当，RegisterNatives也在这里进行。\n\nJNI_OnUnload()当VM释放该组件时被调用，JNI_OnUnload()函数的作用与JNI_OnLoad()对应，因此在该方法中进行善后清理，资源释放的动作最为合适。\n\n### Java代码\nJava代码和使用哪种方式实现JNI无关，如下所示：\n```\nclass MyJavaClass\n{\n public int iValue;\n public void Squa(){iValue = iValue*iValue;}\n}\npublic class RegisterNativesTest\n{\n static{\n  System.load(\"/home/zmh/workspace/RegisterNativesTest/lib/libCallClass.so\");\n }\n public static void main(String[] args)\n {\n  RegisterNativesTest app = new RegisterNativesTest();\n  MyJavaClass obj = new MyJavaClass();\n  obj.iValue = 10;\n  System.out.println(\"Before callCustomClass: \" + obj.iValue);\n  app.callCustomClass(obj);\n  System.out.println(\"After callCustomClass: \" + obj.iValue);\n }\n private native void callCustomClass(MyJavaClass obj);\n}\n\n```\n\n### C++代码\nC＋＋的代码可以分为两部分：实现callCustomClass方法和注册callCustomClass。\n实现callCustomClass方法的代码如下：\n\n```\nvoid callCustomClass(JNIEnv* env, jobject, jobject obj)\n{\n jclass cls = env->GetObjectClass(obj);\n jfieldID fid = env->GetFieldID(cls, \"iValue\", \"I\");\n jmethodID mid = env->GetMethodID(cls, \"Squa\", \"()V\");\n int value = env->GetIntField(obj, fid);\n printf(\"Native: %d\\n\", value);\n env->SetIntField(obj, fid, 5);\n env->CallVoidMethod(obj, mid);\n value = env->GetIntField(obj, fid);\n printf(\"Native:%d\\n\", value);\n}\n```\n\nC＋＋函数内忽略this指针，他所接收的jobject是“Java程序代码传递过来的Java object reference“在原生端的形式，在C＋＋中对jobject的改变在java中也是有效的。如果想要访问Java数据成员和函数，得先使用GetFieldID或GetMethodID分别获取数据成员和函数的识别码，这两个函数的参数依次为1）class object；2）包含元素名称的字符串；3）表示类型的字符串。\n注册callCustomClass在JNI_OnLoad中进行，代码如下：\n\n```\nstatic JNINativeMethod s_methods[] = {\n{\"callCustomClass\", \"(LMyJavaClass;)V\", (void*)callCustomClass},\n};\n\nint JNI_OnLoad(JavaVM* vm, void* reserved)\n{\n JNIEnv* env = NULL;\n   if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK)\n   {\n      return JNI_ERR;\n   }\n\n jclass cls = env->FindClass(\"LRegisterNativesTest;\");\n   if (cls == NULL)\n   {\n      return JNI_ERR;\n   }\n\n   int len = sizeof(s_methods) / sizeof(s_methods[0]);\n   if (env->RegisterNatives(cls, s_methods, len) < 0)\n   {\n      return JNI_ERR;\n   }\n\n   return JNI_VERSION_1_4;\n}\n```\n\n在C＋＋和Java中创建关联的是JNINativeMethod，它在jni.h中定义：\n\n```\n/*\n * used in RegisterNatives to describe native method name, signature,\n * and function pointer.\n */\ntypedef struct {\n    char *name;\n    char *signature;\n    void *fnPtr;\n} JNINativeMethod;\n```\n\nname是java中定义的native函数的名字，fnPtr是函数指针，也就是C＋＋中java native函数的实现。signature是java native函数的签名，可以认为是参数和返回值。比如(LMyJavaClass;)V，表示函数的参数是LMyJavaClass，返回值是void。对于基本类型，对应关系如下：\n\n```\n字符     Java类型     C/C++类型\nV           void         void\nZ         jboolean      boolean\nI            jint           int\nJ           jlong         long\nD         jdouble       double\nF          jfloat         float\nB          jbyte         byte\nC          jchar          char\nS          jshort        short\n```\n\n数组则以\"[\"开始，用两个字符表示，比如int数组表示为［I，以此类推。\n如果参数是Java类，则以\"L\"开头，以\";\"结尾，中间是用\"/\"隔开包及类名，例如Ljava/lang/String;，而其对应的C＋＋函数的参数为jobject，一个例外是String类，它对应C＋＋类型jstring。\n\n# 参考链接\n\n[JAVA基础之理解JNI原理](http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html)\n[JNI：使用RegisterNatives方法传递和使用Java自定义类](http://blog.csdn.net/qiuxiaolong007/article/details/7860610)","slug":"java-core-jni","published":1,"updated":"2016-04-15T10:10:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinb2xtm1000abgv08ejcz5sy","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Java本地接口（Java Native Interface(JNI)）允许运行在Java虚拟机(Java Virtual Machine(JVM))上的代码调用本地程序和类库，或者被它们调用，这些程序和类库可以是其他语言编写的，比如：C、C++或汇编语言。<br>很多基本类库都依赖JNI来为开发者和用户提供服务，比如文件的输入/输出和音频功能。在基本类库中包含的对于性能和平台敏感的API可以允许所有的Java程序以安全和平台无关的方式来使用这些功能。</p>\n<h1 id=\"知识图\"><a href=\"#知识图\" class=\"headerlink\" title=\"知识图\"></a>知识图</h1><p><img src=\"jni.png\" alt=\"\"></p>\n<h1 id=\"一些宏定义\"><a href=\"#一些宏定义\" class=\"headerlink\" title=\"一些宏定义\"></a>一些宏定义</h1><p>windows宏定义的代码位置：<br><code>./jdk/src/windows/javavm/export/jni_md.h</code>）；<br>非windows宏定义代码位置（以MAC为例）：<br><code>./jdk/src/macosx/javavm/export/jni_md.h</code>）</p>\n<h2 id=\"JNIEXPORT\"><a href=\"#JNIEXPORT\" class=\"headerlink\" title=\"JNIEXPORT\"></a>JNIEXPORT</h2><p>windows:<br><code>#define JNIEXPORT __declspec(dllexport)</code><br>非windows:<br><code>#define JNIEXPORT</code></p>\n<h2 id=\"JNIIMPORT\"><a href=\"#JNIIMPORT\" class=\"headerlink\" title=\"JNIIMPORT\"></a>JNIIMPORT</h2><p>windows:<br><code>#define JNIIMPORT __declspec(dllimport)</code><br>非windows:<br><code>#define JNIIMPORT</code></p>\n<h2 id=\"JNICALL\"><a href=\"#JNICALL\" class=\"headerlink\" title=\"JNICALL\"></a>JNICALL</h2><p>windows:<br><code>#define JNICALL __stdcall</code><br>非windows:<br><code>#define JNICALL</code></p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><h2 id=\"使用javah\"><a href=\"#使用javah\" class=\"headerlink\" title=\"使用javah\"></a>使用javah</h2><h3 id=\"java代码\"><a href=\"#java代码\" class=\"headerlink\" title=\"java代码\"></a>java代码</h3><p>编写java代码，并生成C/C++头文件；</p>\n<p>程序清单1: <code>HelloJni.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.jackalope.study.jni;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloJni</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"HelloJni\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">DisplayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HelloJni().DisplayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入src目录下，编译该JAVA类：</p>\n<p><code>javac HelloJni.java</code></p>\n<p>生成头文件：</p>\n<p><code>javah org.jackalope.study.jni.HelloJni</code></p>\n<p>得到头文件 org_jackalope_study_jni_HelloJni.h，此文件供C、C++程序来引用并实现其中的函数</p>\n<p>程序清单2: <code>org_jackalope_study_jni_HelloJni.h</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class org_jackalope_study_jni_HelloJni */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_org_jackalope_study_jni_HelloJni</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_org_jackalope_study_jni_HelloJni</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * Class:     org_jackalope_study_jni_HelloJni</span><br><span class=\"line\"> * Method:    DisplayHello</span><br><span class=\"line\"> * Signature: ()V</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_org_jackalope_study_jni_HelloJni_DisplayHello</span></span><br><span class=\"line\">  <span class=\"params\">(JNIEnv *, jobject)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"C-代码\"><a href=\"#C-代码\" class=\"headerlink\" title=\"C++代码\"></a>C++代码</h3><p>编写C++代码，实现函数功能 ———— 打印”HelloJni”。</p>\n<p>程序清单3：jni_helloworldImpl.cpp</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> org_jackalope_study_jni_HelloJni.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_org_jackalope_study_jni_HelloJni_DisplayHello</span><span class=\"params\">(JNIEnv *env, jobject obj)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"From org_jackalope_study_jni_HelloJni.cpp :\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello world ! \\n\"</span>);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。<br>编译生成动态库libHelloJni.jnilib:<br><code>g++ -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/include/ org_jackalope_study_jni_HelloJni.cpp -o libHelloJni.jnilib</code></p>\n<p>注意：在mac下后缀名应当写为jnilib，这是由<br>./jdk/src/macosx/classes/java/lang/ClassLoaderHelper.java中的mapAlternativeName方法引起的，代码如下：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// For mac, this replaces the final .dylib suffix with .jnilib</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">index</span> = name.toLowerCase().lastIndexOf(<span class=\"string\">\".dylib\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">index</span> &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(name.substring(<span class=\"number\">0</span>, <span class=\"keyword\">index</span>) + <span class=\"string\">\".jnilib\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>    mac下会提示找不到jni_md.h，创建一个软链接即可解决：<br>    <code>sudo ln -s darwin/jni_md.h jni_md.h</code></p>\n<p>成功后，便会在当前目录下生成动态链接库libHelloJni.jnilib文件。<br>有了具体实现的动态库后，就可以运行JAVA调用JNI程序类的native方法了:<br><code>java -Djava.library.path=../c++/  org.jackalope.study.jni.HelloJni</code><br>输出：<br>From org_jackalope_study_jni_HelloJni.cpp :Hello world !</p>\n<h2 id=\"使用RegisterNatives\"><a href=\"#使用RegisterNatives\" class=\"headerlink\" title=\"使用RegisterNatives\"></a>使用RegisterNatives</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>C＋＋中函数命名自由，不必像javah自动生成的函数声明那样，拘泥特定的命名方式；</li>\n<li>效率高。传统方式下，Java类call本地函数时，通常是依靠VM去动态寻找.so中的本地函数(因此它们才需要特定规则的命名格式)，而使用RegisterNatives将本地函数向VM进行登记，可以让其更有效率的找到函数；</li>\n<li>运行时动态调整本地函数与Java函数值之间的映射关系，只需要多次call RegisterNatives()方法，并传入不同的映射表参数即可。</li>\n</ol>\n<p>为了使用RegisterNatives，我们需要了解JNI_OnLoad和JNI_OnUnload函数。JNI_OnLoad()函数在VM执行System.loadLibrary(xxx)函数时被调用，它有两个重要的作用：</p>\n<ul>\n<li>指定JNI版本：告诉VM该组件使用那一个JNI版本(若未提供JNI_OnLoad()函数，VM会默认该使用最老的JNI 1.1版)，如果要使用新版本的JNI，例如JNI 1.4版，则必须由JNI_OnLoad()函数返回常量JNI_VERSION_1_4(该常量定义在jni.h中) 来告知VM。</li>\n<li>初始化设定，当VM执行到System.loadLibrary()函数时，会立即先呼叫JNI_OnLoad()方法，因此在该方法中进行各种资源的初始化操作最为恰当，RegisterNatives也在这里进行。</li>\n</ul>\n<p>JNI_OnUnload()当VM释放该组件时被调用，JNI_OnUnload()函数的作用与JNI_OnLoad()对应，因此在该方法中进行善后清理，资源释放的动作最为合适。</p>\n<h3 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h3><p>Java代码和使用哪种方式实现JNI无关，如下所示：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyJavaClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> iValue;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Squa</span>(<span class=\"params\"></span>)</span>&#123;iValue = iValue*iValue;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">RegisterNativesTest</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">  System.load(<span class=\"string\">\"/home/zmh/workspace/RegisterNativesTest/lib/libCallClass.so\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>)</span><br><span class=\"line\"> </span>&#123;</span><br><span class=\"line\">  RegisterNativesTest app = <span class=\"keyword\">new</span> RegisterNativesTest();</span><br><span class=\"line\">  MyJavaClass obj = <span class=\"keyword\">new</span> MyJavaClass();</span><br><span class=\"line\">  obj.iValue = <span class=\"number\">10</span>;</span><br><span class=\"line\">  System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Before callCustomClass: \"</span> + obj.iValue);</span><br><span class=\"line\">  app.callCustomClass(obj);</span><br><span class=\"line\">  System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"After callCustomClass: \"</span> + obj.iValue);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> native <span class=\"keyword\">void</span> <span class=\"title\">callCustomClass</span>(<span class=\"params\">MyJavaClass obj</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"C-代码-1\"><a href=\"#C-代码-1\" class=\"headerlink\" title=\"C++代码\"></a>C++代码</h3><p>C＋＋的代码可以分为两部分：实现callCustomClass方法和注册callCustomClass。<br>实现callCustomClass方法的代码如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void callCustomClass(<span class=\"keyword\">JNIEnv* </span>env, <span class=\"keyword\">jobject, </span><span class=\"keyword\">jobject </span>obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">jclass </span>cls = env-&gt;GetObjectClass(obj)<span class=\"comment\">;</span></span><br><span class=\"line\"> <span class=\"keyword\">jfieldID </span>fid = env-&gt;GetFieldID(cls, <span class=\"string\">\"iValue\"</span>, <span class=\"string\">\"I\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> <span class=\"keyword\">jmethodID </span>mid = env-&gt;GetMethodID(cls, <span class=\"string\">\"Squa\"</span>, <span class=\"string\">\"()V\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> int value = env-&gt;GetIntField(obj, fid)<span class=\"comment\">;</span></span><br><span class=\"line\"> printf(<span class=\"string\">\"Native: %d\\n\"</span>, value)<span class=\"comment\">;</span></span><br><span class=\"line\"> env-&gt;SetIntField(obj, fid, <span class=\"number\">5</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> env-&gt;CallVoidMethod(obj, mid)<span class=\"comment\">;</span></span><br><span class=\"line\"> value = env-&gt;GetIntField(obj, fid)<span class=\"comment\">;</span></span><br><span class=\"line\"> printf(<span class=\"string\">\"Native:%d\\n\"</span>, value)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C＋＋函数内忽略this指针，他所接收的jobject是“Java程序代码传递过来的Java object reference“在原生端的形式，在C＋＋中对jobject的改变在java中也是有效的。如果想要访问Java数据成员和函数，得先使用GetFieldID或GetMethodID分别获取数据成员和函数的识别码，这两个函数的参数依次为1）class object；2）包含元素名称的字符串；3）表示类型的字符串。<br>注册callCustomClass在JNI_OnLoad中进行，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod s_methods[] = &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">\"callCustomClass\"</span>, <span class=\"string\">\"(LMyJavaClass;)V\"</span>, (<span class=\"keyword\">void</span>*)callCustomClass&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> JNI_OnLoad(JavaVM* vm, <span class=\"keyword\">void</span>* reserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> JNIEnv* env = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (vm-&gt;GetEnv((<span class=\"keyword\">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> jclass cls = env-&gt;FindClass(<span class=\"string\">\"LRegisterNativesTest;\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (cls == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">int</span> len = <span class=\"keyword\">sizeof</span>(s_methods) / <span class=\"keyword\">sizeof</span>(s_methods[<span class=\"number\">0</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (env-&gt;RegisterNatives(cls, s_methods, len) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> JNI_VERSION_1_4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在C＋＋和Java中创建关联的是JNINativeMethod，它在jni.h中定义：</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * used <span class=\"keyword\">in</span> <span class=\"type\">RegisterNatives</span> <span class=\"keyword\">to</span> describe native <span class=\"keyword\">method</span> name, signature,</span><br><span class=\"line\"> * <span class=\"keyword\">and</span> <span class=\"keyword\">function</span> pointer.</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">char</span> *name;</span><br><span class=\"line\">    <span class=\"built_in\">char</span> *signature;</span><br><span class=\"line\">    void *fnPtr;</span><br><span class=\"line\">&#125; <span class=\"type\">JNINativeMethod</span>;</span><br></pre></td></tr></table></figure>\n<p>name是java中定义的native函数的名字，fnPtr是函数指针，也就是C＋＋中java native函数的实现。signature是java native函数的签名，可以认为是参数和返回值。比如(LMyJavaClass;)V，表示函数的参数是LMyJavaClass，返回值是void。对于基本类型，对应关系如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符     Java类型     C/C++类型</span><br><span class=\"line\">V           <span class=\"keyword\">void</span>         <span class=\"keyword\">void</span></span><br><span class=\"line\">Z         jboolean      <span class=\"keyword\">boolean</span></span><br><span class=\"line\">I            jint           <span class=\"keyword\">int</span></span><br><span class=\"line\">J           jlong         <span class=\"keyword\">long</span></span><br><span class=\"line\">D         jdouble       <span class=\"keyword\">double</span></span><br><span class=\"line\">F          jfloat         <span class=\"keyword\">float</span></span><br><span class=\"line\">B          jbyte         <span class=\"keyword\">byte</span></span><br><span class=\"line\">C          jchar          <span class=\"keyword\">char</span></span><br><span class=\"line\">S          jshort        <span class=\"keyword\">short</span></span><br></pre></td></tr></table></figure>\n<p>数组则以”[“开始，用两个字符表示，比如int数组表示为［I，以此类推。<br>如果参数是Java类，则以”L”开头，以”;”结尾，中间是用”/“隔开包及类名，例如Ljava/lang/String;，而其对应的C＋＋函数的参数为jobject，一个例外是String类，它对应C＋＋类型jstring。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html\" target=\"_blank\" rel=\"external\">JAVA基础之理解JNI原理</a><br><a href=\"http://blog.csdn.net/qiuxiaolong007/article/details/7860610\" target=\"_blank\" rel=\"external\">JNI：使用RegisterNatives方法传递和使用Java自定义类</a></p>\n","excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>Java本地接口（Java Native Interface(JNI)）允许运行在Java虚拟机(Java Virtual Machine(JVM))上的代码调用本地程序和类库，或者被它们调用，这些程序和类库可以是其他语言编写的，比如：C、C++或汇编语言。<br>很多基本类库都依赖JNI来为开发者和用户提供服务，比如文件的输入/输出和音频功能。在基本类库中包含的对于性能和平台敏感的API可以允许所有的Java程序以安全和平台无关的方式来使用这些功能。</p>\n<h1 id=\"知识图\"><a href=\"#知识图\" class=\"headerlink\" title=\"知识图\"></a>知识图</h1><p><img src=\"jni.png\" alt=\"\"></p>\n<h1 id=\"一些宏定义\"><a href=\"#一些宏定义\" class=\"headerlink\" title=\"一些宏定义\"></a>一些宏定义</h1><p>windows宏定义的代码位置：<br><code>./jdk/src/windows/javavm/export/jni_md.h</code>）；<br>非windows宏定义代码位置（以MAC为例）：<br><code>./jdk/src/macosx/javavm/export/jni_md.h</code>）</p>\n<h2 id=\"JNIEXPORT\"><a href=\"#JNIEXPORT\" class=\"headerlink\" title=\"JNIEXPORT\"></a>JNIEXPORT</h2><p>windows:<br><code>#define JNIEXPORT __declspec(dllexport)</code><br>非windows:<br><code>#define JNIEXPORT</code></p>\n<h2 id=\"JNIIMPORT\"><a href=\"#JNIIMPORT\" class=\"headerlink\" title=\"JNIIMPORT\"></a>JNIIMPORT</h2><p>windows:<br><code>#define JNIIMPORT __declspec(dllimport)</code><br>非windows:<br><code>#define JNIIMPORT</code></p>\n<h2 id=\"JNICALL\"><a href=\"#JNICALL\" class=\"headerlink\" title=\"JNICALL\"></a>JNICALL</h2><p>windows:<br><code>#define JNICALL __stdcall</code><br>非windows:<br><code>#define JNICALL</code></p>\n<h1 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h1><h2 id=\"使用javah\"><a href=\"#使用javah\" class=\"headerlink\" title=\"使用javah\"></a>使用javah</h2><h3 id=\"java代码\"><a href=\"#java代码\" class=\"headerlink\" title=\"java代码\"></a>java代码</h3><p>编写java代码，并生成C/C++头文件；</p>\n<p>程序清单1: <code>HelloJni.java</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> org.jackalope.study.jni;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloJni</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        System.loadLibrary(<span class=\"string\">\"HelloJni\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">void</span> <span class=\"title\">DisplayHello</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> HelloJni().DisplayHello();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>进入src目录下，编译该JAVA类：</p>\n<p><code>javac HelloJni.java</code></p>\n<p>生成头文件：</p>\n<p><code>javah org.jackalope.study.jni.HelloJni</code></p>\n<p>得到头文件 org_jackalope_study_jni_HelloJni.h，此文件供C、C++程序来引用并实现其中的函数</p>\n<p>程序清单2: <code>org_jackalope_study_jni_HelloJni.h</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class org_jackalope_study_jni_HelloJni */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_org_jackalope_study_jni_HelloJni</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_org_jackalope_study_jni_HelloJni</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">\"C\"</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span><br><span class=\"line\"> * Class:     org_jackalope_study_jni_HelloJni</span><br><span class=\"line\"> * Method:    DisplayHello</span><br><span class=\"line\"> * Signature: ()V</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_org_jackalope_study_jni_HelloJni_DisplayHello</span></span><br><span class=\"line\">  <span class=\"params\">(JNIEnv *, jobject)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"C-代码\"><a href=\"#C-代码\" class=\"headerlink\" title=\"C++代码\"></a>C++代码</h3><p>编写C++代码，实现函数功能 ———— 打印”HelloJni”。</p>\n<p>程序清单3：jni_helloworldImpl.cpp</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> org_jackalope_study_jni_HelloJni.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_org_jackalope_study_jni_HelloJni_DisplayHello</span><span class=\"params\">(JNIEnv *env, jobject obj)</span></span><br><span class=\"line\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"From org_jackalope_study_jni_HelloJni.cpp :\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Hello world ! \\n\"</span>);</span><br><span class=\"line\">    return;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此C++文件实现了上述头文件中的函数，注意方法函数名要保持一致。<br>编译生成动态库libHelloJni.jnilib:<br><code>g++ -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_25.jdk/Contents/Home/include/ org_jackalope_study_jni_HelloJni.cpp -o libHelloJni.jnilib</code></p>\n<p>注意：在mac下后缀名应当写为jnilib，这是由<br>./jdk/src/macosx/classes/java/lang/ClassLoaderHelper.java中的mapAlternativeName方法引起的，代码如下：</p>\n<figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// For mac, this replaces the final .dylib suffix with .jnilib</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> <span class=\"keyword\">index</span> = name.toLowerCase().lastIndexOf(<span class=\"string\">\".dylib\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">index</span> &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> File(name.substring(<span class=\"number\">0</span>, <span class=\"keyword\">index</span>) + <span class=\"string\">\".jnilib\"</span>);</span><br></pre></td></tr></table></figure>\n<p>注意：<br>    mac下会提示找不到jni_md.h，创建一个软链接即可解决：<br>    <code>sudo ln -s darwin/jni_md.h jni_md.h</code></p>\n<p>成功后，便会在当前目录下生成动态链接库libHelloJni.jnilib文件。<br>有了具体实现的动态库后，就可以运行JAVA调用JNI程序类的native方法了:<br><code>java -Djava.library.path=../c++/  org.jackalope.study.jni.HelloJni</code><br>输出：<br>From org_jackalope_study_jni_HelloJni.cpp :Hello world !</p>\n<h2 id=\"使用RegisterNatives\"><a href=\"#使用RegisterNatives\" class=\"headerlink\" title=\"使用RegisterNatives\"></a>使用RegisterNatives</h2><h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><ol>\n<li>C＋＋中函数命名自由，不必像javah自动生成的函数声明那样，拘泥特定的命名方式；</li>\n<li>效率高。传统方式下，Java类call本地函数时，通常是依靠VM去动态寻找.so中的本地函数(因此它们才需要特定规则的命名格式)，而使用RegisterNatives将本地函数向VM进行登记，可以让其更有效率的找到函数；</li>\n<li>运行时动态调整本地函数与Java函数值之间的映射关系，只需要多次call RegisterNatives()方法，并传入不同的映射表参数即可。</li>\n</ol>\n<p>为了使用RegisterNatives，我们需要了解JNI_OnLoad和JNI_OnUnload函数。JNI_OnLoad()函数在VM执行System.loadLibrary(xxx)函数时被调用，它有两个重要的作用：</p>\n<ul>\n<li>指定JNI版本：告诉VM该组件使用那一个JNI版本(若未提供JNI_OnLoad()函数，VM会默认该使用最老的JNI 1.1版)，如果要使用新版本的JNI，例如JNI 1.4版，则必须由JNI_OnLoad()函数返回常量JNI_VERSION_1_4(该常量定义在jni.h中) 来告知VM。</li>\n<li>初始化设定，当VM执行到System.loadLibrary()函数时，会立即先呼叫JNI_OnLoad()方法，因此在该方法中进行各种资源的初始化操作最为恰当，RegisterNatives也在这里进行。</li>\n</ul>\n<p>JNI_OnUnload()当VM释放该组件时被调用，JNI_OnUnload()函数的作用与JNI_OnLoad()对应，因此在该方法中进行善后清理，资源释放的动作最为合适。</p>\n<h3 id=\"Java代码\"><a href=\"#Java代码\" class=\"headerlink\" title=\"Java代码\"></a>Java代码</h3><p>Java代码和使用哪种方式实现JNI无关，如下所示：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title\">MyJavaClass</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> iValue;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">Squa</span>(<span class=\"params\"></span>)</span>&#123;iValue = iValue*iValue;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">RegisterNativesTest</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">static</span>&#123;</span><br><span class=\"line\">  System.load(<span class=\"string\">\"/home/zmh/workspace/RegisterNativesTest/lib/libCallClass.so\"</span>);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String[] args</span>)</span><br><span class=\"line\"> </span>&#123;</span><br><span class=\"line\">  RegisterNativesTest app = <span class=\"keyword\">new</span> RegisterNativesTest();</span><br><span class=\"line\">  MyJavaClass obj = <span class=\"keyword\">new</span> MyJavaClass();</span><br><span class=\"line\">  obj.iValue = <span class=\"number\">10</span>;</span><br><span class=\"line\">  System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Before callCustomClass: \"</span> + obj.iValue);</span><br><span class=\"line\">  app.callCustomClass(obj);</span><br><span class=\"line\">  System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"After callCustomClass: \"</span> + obj.iValue);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">private</span> native <span class=\"keyword\">void</span> <span class=\"title\">callCustomClass</span>(<span class=\"params\">MyJavaClass obj</span>)</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"C-代码-1\"><a href=\"#C-代码-1\" class=\"headerlink\" title=\"C++代码\"></a>C++代码</h3><p>C＋＋的代码可以分为两部分：实现callCustomClass方法和注册callCustomClass。<br>实现callCustomClass方法的代码如下：</p>\n<figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void callCustomClass(<span class=\"keyword\">JNIEnv* </span>env, <span class=\"keyword\">jobject, </span><span class=\"keyword\">jobject </span>obj)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"keyword\">jclass </span>cls = env-&gt;GetObjectClass(obj)<span class=\"comment\">;</span></span><br><span class=\"line\"> <span class=\"keyword\">jfieldID </span>fid = env-&gt;GetFieldID(cls, <span class=\"string\">\"iValue\"</span>, <span class=\"string\">\"I\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> <span class=\"keyword\">jmethodID </span>mid = env-&gt;GetMethodID(cls, <span class=\"string\">\"Squa\"</span>, <span class=\"string\">\"()V\"</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> int value = env-&gt;GetIntField(obj, fid)<span class=\"comment\">;</span></span><br><span class=\"line\"> printf(<span class=\"string\">\"Native: %d\\n\"</span>, value)<span class=\"comment\">;</span></span><br><span class=\"line\"> env-&gt;SetIntField(obj, fid, <span class=\"number\">5</span>)<span class=\"comment\">;</span></span><br><span class=\"line\"> env-&gt;CallVoidMethod(obj, mid)<span class=\"comment\">;</span></span><br><span class=\"line\"> value = env-&gt;GetIntField(obj, fid)<span class=\"comment\">;</span></span><br><span class=\"line\"> printf(<span class=\"string\">\"Native:%d\\n\"</span>, value)<span class=\"comment\">;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>C＋＋函数内忽略this指针，他所接收的jobject是“Java程序代码传递过来的Java object reference“在原生端的形式，在C＋＋中对jobject的改变在java中也是有效的。如果想要访问Java数据成员和函数，得先使用GetFieldID或GetMethodID分别获取数据成员和函数的识别码，这两个函数的参数依次为1）class object；2）包含元素名称的字符串；3）表示类型的字符串。<br>注册callCustomClass在JNI_OnLoad中进行，代码如下：</p>\n<figure class=\"highlight objectivec\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> JNINativeMethod s_methods[] = &#123;</span><br><span class=\"line\">&#123;<span class=\"string\">\"callCustomClass\"</span>, <span class=\"string\">\"(LMyJavaClass;)V\"</span>, (<span class=\"keyword\">void</span>*)callCustomClass&#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> JNI_OnLoad(JavaVM* vm, <span class=\"keyword\">void</span>* reserved)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> JNIEnv* env = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (vm-&gt;GetEnv((<span class=\"keyword\">void</span>**) &amp;env, JNI_VERSION_1_4) != JNI_OK)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> jclass cls = env-&gt;FindClass(<span class=\"string\">\"LRegisterNativesTest;\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (cls == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">int</span> len = <span class=\"keyword\">sizeof</span>(s_methods) / <span class=\"keyword\">sizeof</span>(s_methods[<span class=\"number\">0</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (env-&gt;RegisterNatives(cls, s_methods, len) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">   &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> JNI_ERR;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> JNI_VERSION_1_4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在C＋＋和Java中创建关联的是JNINativeMethod，它在jni.h中定义：</p>\n<figure class=\"highlight ocaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> * used <span class=\"keyword\">in</span> <span class=\"type\">RegisterNatives</span> <span class=\"keyword\">to</span> describe native <span class=\"keyword\">method</span> name, signature,</span><br><span class=\"line\"> * <span class=\"keyword\">and</span> <span class=\"keyword\">function</span> pointer.</span><br><span class=\"line\"> */</span><br><span class=\"line\">typedef <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">char</span> *name;</span><br><span class=\"line\">    <span class=\"built_in\">char</span> *signature;</span><br><span class=\"line\">    void *fnPtr;</span><br><span class=\"line\">&#125; <span class=\"type\">JNINativeMethod</span>;</span><br></pre></td></tr></table></figure>\n<p>name是java中定义的native函数的名字，fnPtr是函数指针，也就是C＋＋中java native函数的实现。signature是java native函数的签名，可以认为是参数和返回值。比如(LMyJavaClass;)V，表示函数的参数是LMyJavaClass，返回值是void。对于基本类型，对应关系如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符     Java类型     C/C++类型</span><br><span class=\"line\">V           <span class=\"keyword\">void</span>         <span class=\"keyword\">void</span></span><br><span class=\"line\">Z         jboolean      <span class=\"keyword\">boolean</span></span><br><span class=\"line\">I            jint           <span class=\"keyword\">int</span></span><br><span class=\"line\">J           jlong         <span class=\"keyword\">long</span></span><br><span class=\"line\">D         jdouble       <span class=\"keyword\">double</span></span><br><span class=\"line\">F          jfloat         <span class=\"keyword\">float</span></span><br><span class=\"line\">B          jbyte         <span class=\"keyword\">byte</span></span><br><span class=\"line\">C          jchar          <span class=\"keyword\">char</span></span><br><span class=\"line\">S          jshort        <span class=\"keyword\">short</span></span><br></pre></td></tr></table></figure>\n<p>数组则以”[“开始，用两个字符表示，比如int数组表示为［I，以此类推。<br>如果参数是Java类，则以”L”开头，以”;”结尾，中间是用”/“隔开包及类名，例如Ljava/lang/String;，而其对应的C＋＋函数的参数为jobject，一个例外是String类，它对应C＋＋类型jstring。</p>\n<h1 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h1><p><a href=\"http://www.cnblogs.com/mandroid/archive/2011/06/15/2081093.html\">JAVA基础之理解JNI原理</a><br><a href=\"http://blog.csdn.net/qiuxiaolong007/article/details/7860610\">JNI：使用RegisterNatives方法传递和使用Java自定义类</a></p>\n"},{"title":"集合总结","date":"2016-04-19T07:50:37.000Z","toc":true,"_content":"\n在实现方法时，选择不同的数据结构会导致其实现风格以及性能存存着很大差异，JDK帮我们实现了传统的数据结构，我们称之为collection(集合)。\ncollection（集合）表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些而不允许。一些collection是有序的，而另一些则是无序的。\n\n# 接口\n\n## Collection接口\n\nCollection接口是Java集合的根接口，JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。\nCollection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用\"for each\"循环。\n\n## Iterator接口\n\nIterator接口包含如下方法：\n\n```\npublic interface Iterator<E> {\n    boolean hasNext();\n    E next();\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n* 通过反复调用next()方法，可以逐个访问集合中的每个元素，但是如果到了集合的末尾，next()方法将抛出一个NoSuchElementException。因为在调用next之前需要调用hasNext()方法。\n* 元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而如果访问HashSet中的元素，每个元素会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。\n* remove()方法将删除上次调用next()方法时返回的值。如果调用remove()之前没有调用next()将会抛出IllegalStateException异常。如果想删除相邻的两个元素，不能直接这样调用：\n\n```\nit.remove();\nit.remove(); // Error!\n```\n而应该是：\n\n```\nit.remove();\nit.next();\nit.remove();\n```\n\n# 具体的集合\n\nJava库中的具体集合如下表所示：\n\n集合类型|描述\n-|-\nArrayList|一种可以动态增长和缩减的索引序列\nLinkedList|一种可以在任何位置进行高效地插入和删除操作的有序序列\nArrayDeque|一种用循环数组实现的双端队列\nHashSet|一种没有重复元素的无序集合\nTreeSet|一种有序集\nEnumSet|一种包含枚举类型的集合\nLinkedHashSet|一种可以记住元素插入次序的集合\nPriorityQueue|一种允许高效删除最小元素的集合\nHashMap|一种存储键/值关联的数据结构\nTreeMap|一种键值有序排队的映射表\nEnumMap|一种键值属于枚举类型的映射表\nLinkedHashMap|一种可以记住键/值项添加次序的映射表\nWeakHashMap|一种其值无用武之地后可以被垃圾回收的映射表\nIdentityHashMap|一种用==而不是用equals比较键值的映射表\n\n## 数组列表\n\nArrayList封装了一个动态再分配的对象数组。主要适用于查询多、修改少的场景。\nArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以使用如下几种办法：\n\n1. Collections.synchronizedList(List l);\n2. 使用concurrent包下的CopyOnWriteArrayList类；\n3. 使用Vector类；\n\nArrayList实现了List接口、底层使用数组保存所有元素，其操作基本上是对数组的操作。\nensureCapacity()方法在容量不够时，默认增加50%+1，代码如下：\n\n```\nint newCapacity = (oldCapacity * 3)/2 + 1;\n```\n与之相比，Vector默认是增加一倍。\n\n## 链表\n\nLinkedList适用于查询少、修改多的场景。\n在Java中，所有的链表都是双向链表，即每个结点都保存了它的前驱与后继，从中插入或删除一个元素非常容易，只需要更新附近元素的前驱与后继即可。\n链表是一个有序集合，每个对象的位置十分重要。\n\n## 散列集\n\n### HashSet\n\n### HashMap\n\nHashMap可以快速地查找所需要的对象。HashMap为每个对象计算一个整数，即hash code，如果是自定义类，就要负责实现这个类的hashCode方法。\n\n## 树集\n\n## 映射表\n\n### \n\n## 队列\n\n### 双端队列\n\n### 优先级队列\n","source":"_posts/java-core-collections.md","raw":"---\ntitle: 集合总结\ndate: 2016-04-19 15:50:37\ntoc: true\ntags:\n- Java\n- 集合\ncategories:\n- Java基础\n\n---\n\n在实现方法时，选择不同的数据结构会导致其实现风格以及性能存存着很大差异，JDK帮我们实现了传统的数据结构，我们称之为collection(集合)。\ncollection（集合）表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些而不允许。一些collection是有序的，而另一些则是无序的。\n\n# 接口\n\n## Collection接口\n\nCollection接口是Java集合的根接口，JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。\nCollection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用\"for each\"循环。\n\n## Iterator接口\n\nIterator接口包含如下方法：\n\n```\npublic interface Iterator<E> {\n    boolean hasNext();\n    E next();\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n* 通过反复调用next()方法，可以逐个访问集合中的每个元素，但是如果到了集合的末尾，next()方法将抛出一个NoSuchElementException。因为在调用next之前需要调用hasNext()方法。\n* 元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而如果访问HashSet中的元素，每个元素会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。\n* remove()方法将删除上次调用next()方法时返回的值。如果调用remove()之前没有调用next()将会抛出IllegalStateException异常。如果想删除相邻的两个元素，不能直接这样调用：\n\n```\nit.remove();\nit.remove(); // Error!\n```\n而应该是：\n\n```\nit.remove();\nit.next();\nit.remove();\n```\n\n# 具体的集合\n\nJava库中的具体集合如下表所示：\n\n集合类型|描述\n-|-\nArrayList|一种可以动态增长和缩减的索引序列\nLinkedList|一种可以在任何位置进行高效地插入和删除操作的有序序列\nArrayDeque|一种用循环数组实现的双端队列\nHashSet|一种没有重复元素的无序集合\nTreeSet|一种有序集\nEnumSet|一种包含枚举类型的集合\nLinkedHashSet|一种可以记住元素插入次序的集合\nPriorityQueue|一种允许高效删除最小元素的集合\nHashMap|一种存储键/值关联的数据结构\nTreeMap|一种键值有序排队的映射表\nEnumMap|一种键值属于枚举类型的映射表\nLinkedHashMap|一种可以记住键/值项添加次序的映射表\nWeakHashMap|一种其值无用武之地后可以被垃圾回收的映射表\nIdentityHashMap|一种用==而不是用equals比较键值的映射表\n\n## 数组列表\n\nArrayList封装了一个动态再分配的对象数组。主要适用于查询多、修改少的场景。\nArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以使用如下几种办法：\n\n1. Collections.synchronizedList(List l);\n2. 使用concurrent包下的CopyOnWriteArrayList类；\n3. 使用Vector类；\n\nArrayList实现了List接口、底层使用数组保存所有元素，其操作基本上是对数组的操作。\nensureCapacity()方法在容量不够时，默认增加50%+1，代码如下：\n\n```\nint newCapacity = (oldCapacity * 3)/2 + 1;\n```\n与之相比，Vector默认是增加一倍。\n\n## 链表\n\nLinkedList适用于查询少、修改多的场景。\n在Java中，所有的链表都是双向链表，即每个结点都保存了它的前驱与后继，从中插入或删除一个元素非常容易，只需要更新附近元素的前驱与后继即可。\n链表是一个有序集合，每个对象的位置十分重要。\n\n## 散列集\n\n### HashSet\n\n### HashMap\n\nHashMap可以快速地查找所需要的对象。HashMap为每个对象计算一个整数，即hash code，如果是自定义类，就要负责实现这个类的hashCode方法。\n\n## 树集\n\n## 映射表\n\n### \n\n## 队列\n\n### 双端队列\n\n### 优先级队列\n","slug":"java-core-collections","published":1,"updated":"2016-08-14T07:34:47.000Z","_id":"cinb2xtm6000cbgv0ppo70sa2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存存着很大差异，JDK帮我们实现了传统的数据结构，我们称之为collection(集合)。<br>collection（集合）表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些而不允许。一些collection是有序的，而另一些则是无序的。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><p>Collection接口是Java集合的根接口，JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。<br>Collection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用”for each”循环。</p>\n<h2 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h2><p>Iterator接口包含如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"remove\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">forEachRemaining</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (hasNext())</span><br><span class=\"line\">            action.accept(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过反复调用next()方法，可以逐个访问集合中的每个元素，但是如果到了集合的末尾，next()方法将抛出一个NoSuchElementException。因为在调用next之前需要调用hasNext()方法。</li>\n<li>元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而如果访问HashSet中的元素，每个元素会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。</li>\n<li>remove()方法将删除上次调用next()方法时返回的值。如果调用remove()之前没有调用next()将会抛出IllegalStateException异常。如果想删除相邻的两个元素，不能直接这样调用：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.remove</span>(); <span class=\"comment\">// Error!</span></span><br></pre></td></tr></table></figure>\n<p>而应该是：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.next</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br></pre></td></tr></table></figure>\n<h1 id=\"具体的集合\"><a href=\"#具体的集合\" class=\"headerlink\" title=\"具体的集合\"></a>具体的集合</h1><p>Java库中的具体集合如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>集合类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ArrayList</td>\n<td>一种可以动态增长和缩减的索引序列</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td>\n</tr>\n<tr>\n<td>ArrayDeque</td>\n<td>一种用循环数组实现的双端队列</td>\n</tr>\n<tr>\n<td>HashSet</td>\n<td>一种没有重复元素的无序集合</td>\n</tr>\n<tr>\n<td>TreeSet</td>\n<td>一种有序集</td>\n</tr>\n<tr>\n<td>EnumSet</td>\n<td>一种包含枚举类型的集合</td>\n</tr>\n<tr>\n<td>LinkedHashSet</td>\n<td>一种可以记住元素插入次序的集合</td>\n</tr>\n<tr>\n<td>PriorityQueue</td>\n<td>一种允许高效删除最小元素的集合</td>\n</tr>\n<tr>\n<td>HashMap</td>\n<td>一种存储键/值关联的数据结构</td>\n</tr>\n<tr>\n<td>TreeMap</td>\n<td>一种键值有序排队的映射表</td>\n</tr>\n<tr>\n<td>EnumMap</td>\n<td>一种键值属于枚举类型的映射表</td>\n</tr>\n<tr>\n<td>LinkedHashMap</td>\n<td>一种可以记住键/值项添加次序的映射表</td>\n</tr>\n<tr>\n<td>WeakHashMap</td>\n<td>一种其值无用武之地后可以被垃圾回收的映射表</td>\n</tr>\n<tr>\n<td>IdentityHashMap</td>\n<td>一种用==而不是用equals比较键值的映射表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数组列表\"><a href=\"#数组列表\" class=\"headerlink\" title=\"数组列表\"></a>数组列表</h2><p>ArrayList封装了一个动态再分配的对象数组。主要适用于查询多、修改少的场景。<br>ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以使用如下几种办法：</p>\n<ol>\n<li>Collections.synchronizedList(List l);</li>\n<li>使用concurrent包下的CopyOnWriteArrayList类；</li>\n<li>使用Vector类；</li>\n</ol>\n<p>ArrayList实现了List接口、底层使用数组保存所有元素，其操作基本上是对数组的操作。<br>ensureCapacity()方法在容量不够时，默认增加50%+1，代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>)/<span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>与之相比，Vector默认是增加一倍。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>LinkedList适用于查询少、修改多的场景。<br>在Java中，所有的链表都是双向链表，即每个结点都保存了它的前驱与后继，从中插入或删除一个元素非常容易，只需要更新附近元素的前驱与后继即可。<br>链表是一个有序集合，每个对象的位置十分重要。</p>\n<h2 id=\"散列集\"><a href=\"#散列集\" class=\"headerlink\" title=\"散列集\"></a>散列集</h2><h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap可以快速地查找所需要的对象。HashMap为每个对象计算一个整数，即hash code，如果是自定义类，就要负责实现这个类的hashCode方法。</p>\n<h2 id=\"树集\"><a href=\"#树集\" class=\"headerlink\" title=\"树集\"></a>树集</h2><h2 id=\"映射表\"><a href=\"#映射表\" class=\"headerlink\" title=\"映射表\"></a>映射表</h2><p>### </p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><h3 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h3>","excerpt":"","more":"<p>在实现方法时，选择不同的数据结构会导致其实现风格以及性能存存着很大差异，JDK帮我们实现了传统的数据结构，我们称之为collection(集合)。<br>collection（集合）表示一组对象，这些对象也称为collection的元素。一些collection允许有重复的元素，而另一些而不允许。一些collection是有序的，而另一些则是无序的。</p>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><p>Collection接口是Java集合的根接口，JDK不提供此接口的任何直接实现：它提供更具体的子接口（如Set和List）实现。<br>Collection接口扩展了Iterable接口，因此，对于标准类库中的任何集合都可以使用”for each”循环。</p>\n<h2 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h2><p>Iterator接口包含如下方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"remove\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">forEachRemaining</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</span><br><span class=\"line\">        Objects.requireNonNull(action);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (hasNext())</span><br><span class=\"line\">            action.accept(next());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>通过反复调用next()方法，可以逐个访问集合中的每个元素，但是如果到了集合的末尾，next()方法将抛出一个NoSuchElementException。因为在调用next之前需要调用hasNext()方法。</li>\n<li>元素被访问的顺序取决于集合类型。如果对ArrayList进行迭代，迭代器将从索引0开始，每迭代一次，索引值加1。然而如果访问HashSet中的元素，每个元素会按照某种随机的次序出现。虽然可以确定在迭代过程中能够遍历到集合中的所有元素，但却无法预知元素被访问的次序。</li>\n<li>remove()方法将删除上次调用next()方法时返回的值。如果调用remove()之前没有调用next()将会抛出IllegalStateException异常。如果想删除相邻的两个元素，不能直接这样调用：</li>\n</ul>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.remove</span>(); <span class=\"comment\">// Error!</span></span><br></pre></td></tr></table></figure>\n<p>而应该是：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.next</span>();</span><br><span class=\"line\">it<span class=\"selector-class\">.remove</span>();</span><br></pre></td></tr></table></figure>\n<h1 id=\"具体的集合\"><a href=\"#具体的集合\" class=\"headerlink\" title=\"具体的集合\"></a>具体的集合</h1><p>Java库中的具体集合如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>集合类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ArrayList</td>\n<td>一种可以动态增长和缩减的索引序列</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>一种可以在任何位置进行高效地插入和删除操作的有序序列</td>\n</tr>\n<tr>\n<td>ArrayDeque</td>\n<td>一种用循环数组实现的双端队列</td>\n</tr>\n<tr>\n<td>HashSet</td>\n<td>一种没有重复元素的无序集合</td>\n</tr>\n<tr>\n<td>TreeSet</td>\n<td>一种有序集</td>\n</tr>\n<tr>\n<td>EnumSet</td>\n<td>一种包含枚举类型的集合</td>\n</tr>\n<tr>\n<td>LinkedHashSet</td>\n<td>一种可以记住元素插入次序的集合</td>\n</tr>\n<tr>\n<td>PriorityQueue</td>\n<td>一种允许高效删除最小元素的集合</td>\n</tr>\n<tr>\n<td>HashMap</td>\n<td>一种存储键/值关联的数据结构</td>\n</tr>\n<tr>\n<td>TreeMap</td>\n<td>一种键值有序排队的映射表</td>\n</tr>\n<tr>\n<td>EnumMap</td>\n<td>一种键值属于枚举类型的映射表</td>\n</tr>\n<tr>\n<td>LinkedHashMap</td>\n<td>一种可以记住键/值项添加次序的映射表</td>\n</tr>\n<tr>\n<td>WeakHashMap</td>\n<td>一种其值无用武之地后可以被垃圾回收的映射表</td>\n</tr>\n<tr>\n<td>IdentityHashMap</td>\n<td>一种用==而不是用equals比较键值的映射表</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"数组列表\"><a href=\"#数组列表\" class=\"headerlink\" title=\"数组列表\"></a>数组列表</h2><p>ArrayList封装了一个动态再分配的对象数组。主要适用于查询多、修改少的场景。<br>ArrayList不是线程安全的，只能用在单线程环境下，多线程环境下可以使用如下几种办法：</p>\n<ol>\n<li>Collections.synchronizedList(List l);</li>\n<li>使用concurrent包下的CopyOnWriteArrayList类；</li>\n<li>使用Vector类；</li>\n</ol>\n<p>ArrayList实现了List接口、底层使用数组保存所有元素，其操作基本上是对数组的操作。<br>ensureCapacity()方法在容量不够时，默认增加50%+1，代码如下：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> newCapacity = (oldCapacity * <span class=\"number\">3</span>)/<span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>与之相比，Vector默认是增加一倍。</p>\n<h2 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h2><p>LinkedList适用于查询少、修改多的场景。<br>在Java中，所有的链表都是双向链表，即每个结点都保存了它的前驱与后继，从中插入或删除一个元素非常容易，只需要更新附近元素的前驱与后继即可。<br>链表是一个有序集合，每个对象的位置十分重要。</p>\n<h2 id=\"散列集\"><a href=\"#散列集\" class=\"headerlink\" title=\"散列集\"></a>散列集</h2><h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>HashMap可以快速地查找所需要的对象。HashMap为每个对象计算一个整数，即hash code，如果是自定义类，就要负责实现这个类的hashCode方法。</p>\n<h2 id=\"树集\"><a href=\"#树集\" class=\"headerlink\" title=\"树集\"></a>树集</h2><h2 id=\"映射表\"><a href=\"#映射表\" class=\"headerlink\" title=\"映射表\"></a>映射表</h2><p>### </p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h3><h3 id=\"优先级队列\"><a href=\"#优先级队列\" class=\"headerlink\" title=\"优先级队列\"></a>优先级队列</h3>"},{"title":"IO总结","date":"2016-04-19T07:48:35.000Z","toc":true,"_content":"","source":"_posts/java-core-io.md","raw":"---\ntitle: IO总结\ndate: 2016-04-19 15:48:35\ntoc: true\ntags:\n- Java\n- io\ncategories:\n- Java基础\n\n---\n","slug":"java-core-io","published":1,"updated":"2016-04-19T08:04:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinb2xtmg000gbgv0sve8arbo","content":"","excerpt":"","more":""},{"title":"多线程总结","date":"2016-04-19T07:48:26.000Z","toc":true,"_content":"\n线程是程序执行流的最小单元，多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。\n\n# 线程的状态\n\nJava的线程如下有6种状态：\nNEW（新建）\nRUNNABLE（就绪，可运行）\nBLOCKED（被阻塞）\nWAITING（等待）\nTIMED_WAITING（计时等待）\nTERMINATED（被终止）\n\n可以使用Thread.getState()方法获取线程的当前状态。在Thread类中线程状态由一个整型变量threadStatus表示，getState()方法调用VM类的toThreadState()方法，根据threadStatus某个位置上是否为1来判断线程状态，代码如下：\n\n```\n(var0 & 4) != 0?State.RUNNABLE:((var0 & 1024) != 0?State.BLOCKED:((var0 & 16) != 0?State.WAITING:((var0 & 32) != 0?State.TIMED_WAITING:((var0 & 2) != 0?State.TERMINATED:((var0 & 1) == 0?State.NEW:State.RUNNABLE)))));\n```\n\n## NEW\n\n当用new操作符创建一个新线程时，如new Thread()，该线程还没有运行，此时线程状态是NEW。\n\n## RUNNABLE\n\n一旦调用start()方法，线程处于RUNNABLE状态。\n`一个RUNNABLE状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间`。\n\n## BLOCKED\n\n当一个线程试图获取一个内部对象锁，而该锁被其他线程持有，则该线程进入BLOCKED状态。\n\n## WAITING\n\n当一个线程等待另一个线程通知调度器一个条件时，进入WAITING状态，如调用：Object.wait(), Thread.join(), Lock.lock(), Condition.await()时。\n\n## TIMED_WAITING\n\n有几个方法有超时参数，调用它们将导致线程进入TIMED_WAITING状态，如调用：Thread.sleep(long millis), Object.wait(long timeout), Lock.tryLock(), Condition.await(long time, TimeUnit unit)时。\n\n## TERMINATED\n\n* 因为run方法正常退出而自然终止。\n* 因为一个没有捕获的异常而终止。\n\n`stop()、suspend()、resume()已过时，不要使用。`\n\n# 线程属性\n\n线程属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。\n\n## 线程优先级\n\n在Java中每一个线程都有一个优先级，使用setPriority()方法可以设置线程的优先级，可以将优先级置为在MIN_PRIORITY(在Thread类中定义为0)和MAX_PRIORITY（在Thread类中定义为10）之间的任何值。NORM_PRIORITY被定义为5。\n\n`注意：线程优先级高度依赖于系统，Windows有7个优先级，Sun为Linux提供的Java虚拟机，线程的优先级被忽略——所有的线程具有相同的优先级。`\n\n## 守护线程\n\n通过调用方法setDaemon(true)来将线程设置为守护线程，守护线程的唯一作用是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，所以守护线程中永远不应该去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。\n\n## 未捕获异常处理器\n\n该处理器必须实现Thead.UncaughtExceptionHandler接口，该接口只有一个方法：void uncaughtException(Thread t, Throwable e)。\n使用setUncaughtExceptionHandler()方法为线程安装一个处理器，也可以使用静态方法Thread.setUncaughtExceptionHandler()为所有线程安装一个默认的处理器。\n\n# 线程的创建\n\n创建线程有三种方法：\n* 继承Thread类\n* 实现Runnable接口\n* 实现Callable接口\n\n## 继承Thread类\n\n步骤如下\n1. 继承Thread类，重写run方法\n2. 创建线程对象\n3. 执行start方法\n\n```\npublic class ExtendsThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(getName());\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String args[]) {\n        ExtendsThread subThread1 = new ExtendsThread();\n        subThread1.setName(\"subThread1\");\n        ExtendsThread subThread2 = new ExtendsThread();\n        subThread2.setName(\"subThread2\");\n        subThread1.start();\n        subThread2.start();\n    }\n}\n```\n\n输出结果(不固定)：\n\n```\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\n```\n\n`注意：不要调用Thread类或Runnable对象的run方法，直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。`\n\n## 实现Runnable接口\n\n1. 创建Runnable的实现类，重写run方法\n2. 创建该Runnable实现类的对象，并以该对象为参数创建Thread实例\n3. 执行start方法\n\n```\npublic class ImplRunnable {\n    public static void main(String args[]){\n        MyRunnable myRunnable = new MyRunnable();\n        Thread subThread1 = new Thread(myRunnable, \"subThread1\");\n        Thread subThread2 = new Thread(myRunnable, \"subThread2\");\n        subThread1.start();\n        subThread2.start();\n    }\n    static class MyRunnable implements Runnable{\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName());\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n输出结果（不固定）：\n\n```\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread2\nsubThread1\n```\n\n## 实现Callable接口\n\n1. 创建Callable的实现类，重写call()方法\n2. 创建该Callable实现类的对象，并以该对象为参数创建FutureTask对象\n3. 以该FutureTask对象为参数，创建Thread实例\n4. 执行start方法，并可调用FutureTask对象的方法获取线程执行的状态及返回结果。\n\n```\npublic class ImplCallable {\n    \n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable1 = new MyCallable(10);\n        MyCallable myCallable2 = new MyCallable(20);\n        FutureTask<Integer> futureTask1 = new FutureTask(myCallable1);\n        FutureTask<Integer> futureTask2 = new FutureTask(myCallable2);\n        Thread subThread1 = new Thread(futureTask1);\n        Thread subThread2 = new Thread(futureTask2);\n        subThread1.start();\n        subThread2.start();\n        System.out.println(futureTask1.get());\n        System.out.println(futureTask2.get());\n    }\n\n    static class MyCallable implements Callable<Integer>{\n        private int num;\n\n        public MyCallable(int num) {\n            this.num = num;\n        }\n\n        public int getNum() {\n            return num;\n        }\n\n        public void setNum(int num) {\n            this.num = num;\n        }\n\n        @Override\n        public Integer call() throws Exception {\n            for (int i = 0; i < num; i++) {\n                System.out.println(Thread.currentThread().getName());\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            return num;\n        }\n    }\n    \n}\n```\n\n输出结果（不固定）：\n\n```\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\n10\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\n20\n```\n\n## 三种方式的比较\n\n1. Java中没有多重继承，因此在使用继承Thread类的方式创建线程时，不能再继承其他类；使用Runnable、Callable接口创建多线程时，还可以继承其他类，在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况； \n2. 使用Callable接口可以从线程中获取返回值。\n\n# 线程同步\n\n## synchronized关键字\n\n从1.0版本开始，Java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字声明，线程将获得对象的内部锁。\nsynchronized有两种方式：锁方法、锁对象。\n\n1. 锁方法，即用synchronized关键字修饰方法：\n\n```\n// 获得的是对象的内部锁\npublic synchronized void method(){\n\tmethod body\n}\n```\n\n```\n// 获得的是类锁，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁。\npublic static synchronized void(){\n\tmethod body\n}\n```\n\n2. 锁对象：\n\n```\npublic void method(){\n\t// 获得的是对象的内部锁\n\tsynchronized(this){\n\t\tcode block\n\t}\t\n}\n```\n\n```\nObject obj = new Object();\npublic void method(){\n\t// 获得的是obj的内部锁\n\tsynchronized(obj){\n\t\tcode block\n\t}\n}\n```\n\n```\npublic void method(){\n\t// 获得的是类锁\n\tsynchronized(xxx.class){\n\t\tcode block\n\t}\t\n}\n```\n\n```\npublic void method(){\n\t// 获得的是类锁\n\tsynchronized(Class.forName(\"xxx\")){\n\t\tcode block\n\t}\t\n}\n```\n\n## Lock\n\nLock(锁对象)允许把锁的实现作为Java类，而不是作为语言的特性来实现，这就为Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。\n\n### 方法摘要\n\n返回值|方法|解释\n--|--|--\nvoid|lock()|获取锁。\nvoid|lockInterruptibly()|如果当前线程未被中断，则获取锁。\nCondition|newCondition()|返回绑定到此 Lock 实例的新 Condition 实例。\nboolean|tryLock()|仅在调用时锁为空闲状态才获取该锁。\nboolean|tryLock(long time, TimeUnit unit)|如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。\nvoid|unlock()|释放锁。\n\n### ReentrantLock\n\nReentrantLock类是Lock的一个实现，使用ReentrantLock的代码块结构如下：\n\n```\nmyLock.lock();\ntry{\n\t......\n} finally {\n\tmyLock.unlock();\n}\n```\n\n`ReentrantLock(true)可以构造一个带有公平策略的锁，听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。`\n\n## ReadWriteLock\n\nReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。\n与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。\n\n### 方法摘要\n返回值|方法|解释\n--|--|--\nLock|readLock()|返回用于读取操作的锁。\nLock|writeLock()|返回用于写入操作的锁。\n\n### ReentrantReadWriteLock\n\nReentrantReadWriteLock是ReadWriteLock的实现类，其使用方式如下：\n\n```\nReentrantReadWriteLock lock = new ReentrantReadWriteLock();\nlock.readLock().lock();\t\t// 获得读锁\nlock.readLock().unLock();\t// 释放读锁\nlock.writeLock().lock();\t// 获得写锁\nlock.writeLock().unLock();\t// 释放写锁\n```\n\n下面来看一个实际的例子，使用读写锁来实现查询、存钱、取钱：\n例：\n\n```\npublic class ReadWriteLockStudy {\n\n    static class Account {\n\n        private long balance;\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n        private Lock readLock = lock.readLock();\n        private Lock writeLock = lock.writeLock();\n\n        public void show() {\n            readLock.lock();\n            System.out.println(\"获得readLock -- \" + Thread.currentThread().getName());\n            try {\n                System.out.println(\"显示余额:\" + balance);\n            } finally {\n                readLock.unlock();\n            }\n            System.out.println(\"释放readLock -- \" + Thread.currentThread().getName());\n        }\n\n        public void put(long money) {\n            writeLock.lock();\n            System.out.println(\"获得writeLock -- \" + Thread.currentThread().getName());\n            try {\n                balance += money;\n                System.out.println(\"存入:\" + money + \",余额:\" + balance);\n            } finally {\n                writeLock.unlock();\n                System.out.println(\"释放writeLock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take(long money) {\n            writeLock.lock();\n            System.out.println(\"获得writeLock -- \" + Thread.currentThread().getName());\n            try {\n                if (balance < money)\n                    System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance);\n                else {\n                    balance -= money;\n                    System.out.println(\"取出:\" + money + \",余额:\" + balance);\n                }\n            } finally {\n                writeLock.unlock();\n                System.out.println(\"释放writeLock -- \" + Thread.currentThread().getName());\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            int i = 0;\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class ShowThread extends Thread {\n        private Account account;\n\n        public ShowThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                account.show();\n                try {\n                    sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        Account account = new Account();\n        PutThread putThread = new PutThread(account);\n        putThread.setName(\"putThread\");\n        TakeThread takeThread = new TakeThread(account);\n        takeThread.setName(\"takeThread\");\n        ShowThread showThread1 = new ShowThread(account);\n        showThread1.setName(\"showThread1\");\n        ShowThread showThread2 = new ShowThread(account);\n        showThread2.setName(\"showThread2\");\n\n        putThread.start();\n        takeThread.start();\n        showThread1.start();\n        showThread2.start();\n    }\n\n}\n```\n\n输出结果（不固定）：\n\n```\n获得writeLock -- putThread\n存入:46,余额:46\n释放writeLock -- putThread\n获得writeLock -- takeThread\n余额不足, 需取: 95; 余额: 46\n释放writeLock -- takeThread\n获得readLock -- showThread1\n显示余额:46\n释放readLock -- showThread1\n获得readLock -- showThread2\n显示余额:46\n释放readLock -- showThread2\n...\n...\n...\n获得readLock -- showThread2\n获得readLock -- showThread1\n显示余额:46\n显示余额:46\n释放readLock -- showThread1\n释放readLock -- showThread2\n```\n\n可以看到读-读不互斥，读-写互斥，写-写互斥。\n\n### Condition\n\n条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。\nCondition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。\n`不直接使用wait(), notify(), notifyAll()是因为 这几个方法是final方法。`\n可以为多个线程间建立不同的Condition。\n\n将上面的例子修改一下，增加两个功能：\n1. 当余额少于100时，马上存入100；\n2. 当余额大于200时，马上取出100；\n\n代码如下：\n\n```\npublic class ConditionStudy {\n\n    static class Account {\n\n        private long balance;\n\n        private Lock lock = new ReentrantLock();\n        private Condition condition100 = lock.newCondition();\n        private Condition condition200 = lock.newCondition();\n\n        public void put(long money) {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                balance += money;\n                System.out.println(\"存入:\" + money + \",余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n                condition200.signal();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take(long money) {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                if (balance < money)\n                    System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance + \" -- \" + Thread.currentThread().getName());\n                else {\n                    balance -= money;\n                    System.out.println(\"取出:\" + money + \",余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n                    condition100.signal();\n                }\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void put100() {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                while (balance >= 100) {\n                    System.out.println(\"余额大于等于100, 等待, 释放锁\" + \" -- \" + Thread.currentThread().getName());\n                    condition100.await();\n                }\n                balance += 100;\n                System.out.println(\"存入100, 余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take100() {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                while (balance < 200) {\n                    System.out.println(\"余额小于200, 等待, 释放锁\" + \" -- \" + Thread.currentThread().getName());\n                    condition200.await();\n                }\n                balance -= 100;\n                System.out.println(\"取出100, 余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            int i = 0;\n            while (i++ < 10) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class Put100Thread extends Thread {\n        private Account account;\n\n        public Put100Thread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    account.put100();\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class Take100Thread extends Thread {\n        private Account account;\n\n        public Take100Thread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    account.take100();\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        Account account = new Account();\n        PutThread putThread = new PutThread(account);\n        putThread.setName(\"putThread\");\n        TakeThread takeThread = new TakeThread(account);\n        takeThread.setName(\"takeThread\");\n        Put100Thread put100Thread = new Put100Thread(account);\n        put100Thread.setName(\"put100Thread\");\n        Take100Thread take100Thread = new Take100Thread(account);\n        take100Thread.setName(\"take100Thread\");\n\n        putThread.start();\n        takeThread.start();\n        put100Thread.start();\n        take100Thread.start();\n    }\n\n}\n```\n\n## volatile\n\nvolatile可以保证每次都从主内存中读取数据，且每次数据修改都写回主内存。如果一个变量声明为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。\n\n## 死锁\n\n死锁是指多个线程相互等待它方占有的资源而导致的每个线程都无法执行下去的情况。\n下面是一个简单的死锁例子：\n\n```\npublic class DeadLock {\n\n    static class MemStore {\n\n        Lock lock1 = new ReentrantLock();\n        Lock lock2 = new ReentrantLock();\n\n        public void method1() {\n            lock1.lock();\n            System.out.println(\"获得lock1 -- \" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n                lock2.lock();\n                try {\n                    System.out.println(\"获得lock2 -- \" + Thread.currentThread().getName());\n                } finally {\n                    lock2.unlock();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock1.unlock();\n            }\n        }\n\n        public void method2() {\n            lock2.lock();\n            System.out.println(\"获得lock2 -- \" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n                lock1.lock();\n                try {\n                    System.out.println(\"获得lock1 -- \" + Thread.currentThread().getName());\n                } finally {\n                    lock1.unlock();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock2.unlock();\n            }\n        }\n    }\n\n    static class Thread1 extends Thread {\n        private MemStore memStore;\n\n        public Thread1(MemStore memStore) {\n            this.memStore = memStore;\n        }\n\n        @Override\n        public void run(){\n            memStore.method1();\n        }\n    }\n\n    static class Thread2 extends Thread {\n        private MemStore memStore;\n\n        public Thread2(MemStore memStore) {\n            this.memStore = memStore;\n        }\n\n        @Override\n        public void run(){\n            memStore.method2();\n        }\n    }\n\n    public static void main(String args[]) {\n        MemStore memStore = new MemStore();\n        Thread1 thread1 = new Thread1(memStore);\n        thread1.setName(\"thread1\");\n        Thread2 thread2 = new Thread2(memStore);\n        thread2.setName(\"thread2\");\n        thread1.start();\n        thread2.start();\n    }\n\n}\n```\n\n输出结果：\n\n```\n获得lock1 -- thread1\n获得lock2 -- thread2\n```\n可以看到thread1获得了lock1，等待获得lock2，而thread2获得了lock2，等待获得lock1，从而死锁。\n\n# 线程池\n\n多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。\n\n## 线程池原理\n\n假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。\n\n一个线程池包括以下四个基本组成部分：\n\n1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；\n2. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；\n3. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；\n4. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。\n\n线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。\n\n## 简单线程池的实现\n\n```\npublic class SimpleThreadPool {\n\n    // 线程数\n    private int threadNum = 10;\n    // 工作线程\n    private WorkThread[] workThreads;\n    // 任务队列, 待执行的线程\n    private BlockingQueue<Runnable> taskQueue;\n\n    public SimpleThreadPool(int threadNum) {\n        if (threadNum > 0)\n            this.threadNum = threadNum;\n        // 初始化任务队列\n        taskQueue = new LinkedBlockingDeque<>();\n        // 初始化工作线程\n        workThreads = new WorkThread[this.threadNum];\n        int i = 0;\n        while (i < threadNum) {\n            workThreads[i] = new WorkThread();\n            workThreads[i].setName(\"workThread-\" + i);\n            // 启动工作线程\n            workThreads[i].start();\n            i++;\n        }\n    }\n\n    public void execute(Runnable runnable) {\n        taskQueue.add(runnable);\n    }\n\n    public void execute(Runnable[] runnableList) {\n        for (Runnable runnable : runnableList)\n            execute(runnable);\n    }\n\n    public void destroy(){\n        for(WorkThread workThread: workThreads)\n            workThread.stopRun();\n    }\n\n    class WorkThread extends Thread {\n        private volatile boolean runFlag = true;\n\n        @Override\n        public void run() {\n            while (runFlag)\n                try {\n                    Runnable task = taskQueue.take();\n                    task.run();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n        }\n\n        public void stopRun() {\n            runFlag = false;\n        }\n    }\n\n    private static class Task implements Runnable {\n\n        private String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(name + \" run.\" + \"current thread: \" + Thread.currentThread().getName());\n        }\n    }\n\n    public static void main(String args[]) throws InterruptedException {\n        SimpleThreadPool simpleThreadPool = new SimpleThreadPool(3);\n        simpleThreadPool.execute(new Task(\"task0\"));\n        simpleThreadPool.execute(new Runnable[]{new Task(\"task1\"), new Task(\"task2\"), new Task(\"task3\"), new Task(\"task4\")});\n        simpleThreadPool.execute(new Runnable[]{new Task(\"task4\"), new Task(\"task5\"), new Task(\"task6\")});\n        Thread.sleep(1000);\n        simpleThreadPool.destroy();\n    }\n\n}\n```\n\n输出结果（不固定）：\n\n```\ntask0 run.current thread: workThread-0\ntask2 run.current thread: workThread-2\ntask1 run.current thread: workThread-1\ntask3 run.current thread: workThread-0\ntask4 run.current thread: workThread-2\ntask4 run.current thread: workThread-1\ntask5 run.current thread: workThread-0\ntask6 run.current thread: workThread-2\n```\n\n# concurrent包\n\njava.util.concurrent包是在并发编程中很常用的实用工具包。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。\n\n## 执行器\n\n接口。Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用execute()的线程中执行任务，并且可能顺序或并发执行。ExecutorService 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。Future 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。\n\n实现。类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 FutureTask，它提供 Future 的常见可扩展实现，以及 ExecutorCompletionService，它有助于协调对异步任务组的处理。\n\n## 队列\n\njava.util.concurrent.ConcurrentLinkedQueue类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 BlockingQueue 接口，该接口定义了 put 和 take 的阻塞版本：LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、PriorityBlockingQueue 和 DelayQueue。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。BlockingDeque 接口扩展 BlockingQueue，以支持 FIFO 和 LIFO（基于堆栈）操作。LinkedBlockingDeque 类提供一个实现。\n\n## 计时\n\nTimeUnit 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会“尽力”检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。\n\n## 同步器\n\n四个类可协助实现常见的专用同步语句。Semaphore 是一个经典的并发工具。CountDownLatch 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用。Exchanger 允许两个线程在 collection 点交换对象，它在多流水线设计中是有用的。\n\n## 并发 Collection\n\n除队列外，此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。\n此包中与某些类一起使用的“Concurrent&rdquo前缀;是一种简写，表明与类似的“同步”类有所不同。例如，java.util.Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步的，但 ConcurrentHashMap 则是“并发的”。并发 collection 是线程安全的，但是不受单个排他锁的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁不允许对 collection 的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共 collection 的其他情况中，通常“并发”版本要更好一些。当 collection 是未共享的，或者仅保持其他锁时 collection 是可访问的情况下，非同步 collection 则要更好一些。\n\n大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了弱一致的，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结 collection，所以它不一定反映自迭代器创建以来的所有更新。\n\n## 内存一致性属性\n\n只有写入操作 happen-before 读取操作时，才保证一个线程写入的结果对另一个线程的读取是可视的。synchronized 和 volatile 构造 happen-before 关系，Thread.start() 和 Thread.join() 方法形成 happen-before 关系。尤其是：\n线程中的每个操作 happen-before 稍后按程序顺序传入的该线程中的每个操作。\n一个解除锁监视器的（synchronized 阻塞或方法退出）happen-before 相同监视器的每个后续锁（synchronized 阻塞或方法进入）。并且因为 happen-before 关系是可传递的，所以解除锁定之前的线程的所有操作 happen-before 锁定该监视器的任何线程后续的所有操作。\n写入 volatile 字段 happen-before 每个后续读取相同字段。volatile 字段的读取和写入与进入和退出监视器具有相似的内存一致性效果，但不 需要互斥锁。\n在线程上调用 start happen-before 已启动的线程中的任何线程。\n线程中的所有操作 happen-before 从该线程上的 join 成功返回的任何其他线程。\njava.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：\n线程中将一个对象放入任何并发 collection 之前的操作 happen-before 从另一线程中的 collection 访问或移除该元素的后续操作。\n线程中向 Executor 提交 Runnable 之前的操作 happen-before 其执行开始。同样适用于向 ExecutorService 提交 Callables。\n异步计算（由 Future 表示）所采取的操作 happen-before 通过另一线程中 Future.get() 获取结果后续的操作。\n“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。\n对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 happen-before 另一线程中对应 exchange() 后续的操作。\n调用 CyclicBarrier.await 之前的操作 happen-before 屏障操作所执行的操作，屏障操作所执行的操作 happen-before 从另一线程中对应 await 成功返回的后续操作。\n\n# 关于线程个数\n\n我们的应用程序应该创建多少个线程会使得性能得到比较好的提升呢？以下代码可以计算一个合适的线程个数：\n\n```\npublic abstract class PoolSizeCalculator {\n\n    /**\n     * The sample queue size to calculate the size of a single {@link Runnable} element.\n     */\n    private final int SAMPLE_QUEUE_SIZE = 1000;\n\n    /**\n     * Accuracy of test run. It must finish within 20ms of the testTime otherwise we retry the test. This could be\n     * configurable.\n     */\n    private final int EPSYLON = 20;\n\n    /**\n     * Control variable for the CPU time investigation.\n     */\n    private volatile boolean expired;\n\n    /**\n     * Time (millis) of the test run in the CPU time calculation.\n     */\n    private final long testtime = 3000;\n\n    /**\n     * Calculates the boundaries of a thread pool for a given {@link Runnable}.\n     *\n     * @param targetUtilization    the desired utilization of the CPUs (0 <= targetUtilization <= 1)\n     * @param targetQueueSizeBytes the desired maximum work queue size of the thread pool (bytes)\n     */\n    protected void calculateBoundaries(BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes) {\n        calculateOptimalCapacity(targetQueueSizeBytes);\n        Runnable task = createTask();\n        start(task);\n        start(task); // warm up phase\n        long cputime = getCurrentThreadCPUTime();\n        start(task); // test intervall\n        cputime = getCurrentThreadCPUTime() - cputime;\n        long waittime = (testtime * 1000000) - cputime;\n        calculateOptimalThreadCount(cputime, waittime, targetUtilization);\n    }\n\n    private void calculateOptimalCapacity(BigDecimal targetQueueSizeBytes) {\n        long mem = calculateMemoryUsage();\n        BigDecimal queueCapacity = targetQueueSizeBytes.divide(new BigDecimal(mem), RoundingMode.HALF_UP);\n        System.out.println(\"Target queue memory usage (bytes): \" + targetQueueSizeBytes);\n        System.out.println(\"createTask() produced \" + createTask().getClass().getName() + \" which took \" + mem\n                + \" bytes in a queue\");\n        System.out.println(\"Formula: \" + targetQueueSizeBytes + \" / \" + mem);\n        System.out.println(\"* Recommended queue capacity (bytes): \" + queueCapacity);\n    }\n\n    /**\n     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in Practice' (chapter 8.2)\n     *\n     * @param cpu               cpu time consumed by considered task\n     * @param wait              wait time of considered task\n     * @param targetUtilization target utilization of the system\n     */\n    private void calculateOptimalThreadCount(long cpu, long wait, BigDecimal targetUtilization) {\n        BigDecimal waitTime = new BigDecimal(wait);\n        BigDecimal computeTime = new BigDecimal(cpu);\n        BigDecimal numberOfCPU = new BigDecimal(Runtime.getRuntime().availableProcessors());\n        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization).multiply(\n                new BigDecimal(1).add(waitTime.divide(computeTime, RoundingMode.HALF_UP)));\n        System.out.println(\"Number of CPU: \" + numberOfCPU);\n        System.out.println(\"Target utilization: \" + targetUtilization);\n        System.out.println(\"Elapsed time (nanos): \" + (testtime * 1000000));\n        System.out.println(\"Compute time (nanos): \" + cpu);\n        System.out.println(\"Wait time (nanos): \" + wait);\n        System.out.println(\"Formula: \" + numberOfCPU + \" * \" + targetUtilization + \" * (1 + \" + waitTime + \" / \"\n                + computeTime + \")\");\n        System.out.println(\"* Optimal thread count: \" + optimalthreadcount);\n    }\n\n    /**\n     * Runs the {@link Runnable} over a period defined in {@link #testtime}. Based on Heinz Kabbutz' ideas\n     * (http://www.javaspecialists.eu/archive/Issue124.html).\n     *\n     * @param task the runnable under investigation\n     */\n    public void start(Runnable task) {\n        long start = 0;\n        int runs = 0;\n        do {\n            if (++runs > 5) {\n                throw new IllegalStateException(\"Test not accurate\");\n            }\n            expired = false;\n            start = System.currentTimeMillis();\n            Timer timer = new Timer();\n            timer.schedule(new TimerTask() {\n                public void run() {\n                    expired = true;\n                }\n            }, testtime);\n            while (!expired) {\n                task.run();\n            }\n            start = System.currentTimeMillis() - start;\n            timer.cancel();\n        } while (Math.abs(start - testtime) > EPSYLON);\n        collectGarbage(3);\n    }\n\n    private void collectGarbage(int times) {\n        for (int i = 0; i < times; i++) {\n            System.gc();\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates the memory usage of a single element in a work queue. Based on Heinz Kabbutz' ideas\n     * (http://www.javaspecialists.eu/archive/Issue029.html).\n     *\n     * @return memory usage of a single {@link Runnable} element in the thread pools work queue\n     */\n    public long calculateMemoryUsage() {\n        BlockingQueue<Runnable> queue = createWorkQueue();\n        for (int i = 0; i < SAMPLE_QUEUE_SIZE; i++) {\n            queue.add(createTask());\n        }\n        long mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        long mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        queue = null;\n        collectGarbage(15);\n        mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        queue = createWorkQueue();\n        for (int i = 0; i < SAMPLE_QUEUE_SIZE; i++) {\n            queue.add(createTask());\n        }\n        collectGarbage(15);\n        mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        return (mem1 - mem0) / SAMPLE_QUEUE_SIZE;\n    }\n\n    /**\n     * Create your runnable task here.\n     *\n     * @return an instance of your runnable task under investigation\n     */\n    protected abstract Runnable createTask();\n\n    /**\n     * Return an instance of the queue used in the thread pool.\n     *\n     * @return queue instance\n     */\n    protected abstract BlockingQueue<Runnable> createWorkQueue();\n\n    /**\n     * Calculate current cpu time. Various frameworks may be used here, depending on the operating system in use. (e.g.\n     * http://www.hyperic.com/products/sigar). The more accurate the CPU time measurement, the more accurate the results\n     * for thread count boundaries.\n     *\n     * @return current cpu time of current thread\n     */\n    protected abstract long getCurrentThreadCPUTime();\n\n}\n```\n\n```\npublic class MyPoolSizeCalculator extends PoolSizeCalculator {\n\n    public static void main(String[] args) throws InterruptedException,\n            InstantiationException,\n            IllegalAccessException,\n            ClassNotFoundException {\n        MyPoolSizeCalculator calculator = new MyPoolSizeCalculator();\n        calculator.calculateBoundaries(new BigDecimal(1.0),\n                new BigDecimal(100000));\n    }\n\n    protected long getCurrentThreadCPUTime() {\n        return ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();\n    }\n\n    protected Runnable createTask() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++)\n                    System.out.println(i);\n            }\n        };\n    }\n\n    protected BlockingQueue<Runnable> createWorkQueue() {\n        return new LinkedBlockingQueue<>();\n    }\n\n}\n```\n\n`createTask的方法根据自己的实际需要进行修改。`\n\n得到类似如下结果 ：\n\n```\nNumber of CPU: 4\nTarget utilization: 1\nElapsed time (nanos): 3000000000\nCompute time (nanos): 2017495000\nWait time (nanos): 982505000\nFormula: 4 * 1 * (1 + 982505000 / 2017495000)\n* Optimal thread count: 4\n```\n由此可知，在上述场景中，创建4个线程比较合适。\n","source":"_posts/java-core-thread.md","raw":"---\ntitle: 多线程总结\ndate: 2016-04-19 15:48:26\ntoc: true\ntags:\n- Java\n- 多线程\ncategories:\n- Java基础\n\n---\n\n线程是程序执行流的最小单元，多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。\n\n# 线程的状态\n\nJava的线程如下有6种状态：\nNEW（新建）\nRUNNABLE（就绪，可运行）\nBLOCKED（被阻塞）\nWAITING（等待）\nTIMED_WAITING（计时等待）\nTERMINATED（被终止）\n\n可以使用Thread.getState()方法获取线程的当前状态。在Thread类中线程状态由一个整型变量threadStatus表示，getState()方法调用VM类的toThreadState()方法，根据threadStatus某个位置上是否为1来判断线程状态，代码如下：\n\n```\n(var0 & 4) != 0?State.RUNNABLE:((var0 & 1024) != 0?State.BLOCKED:((var0 & 16) != 0?State.WAITING:((var0 & 32) != 0?State.TIMED_WAITING:((var0 & 2) != 0?State.TERMINATED:((var0 & 1) == 0?State.NEW:State.RUNNABLE)))));\n```\n\n## NEW\n\n当用new操作符创建一个新线程时，如new Thread()，该线程还没有运行，此时线程状态是NEW。\n\n## RUNNABLE\n\n一旦调用start()方法，线程处于RUNNABLE状态。\n`一个RUNNABLE状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间`。\n\n## BLOCKED\n\n当一个线程试图获取一个内部对象锁，而该锁被其他线程持有，则该线程进入BLOCKED状态。\n\n## WAITING\n\n当一个线程等待另一个线程通知调度器一个条件时，进入WAITING状态，如调用：Object.wait(), Thread.join(), Lock.lock(), Condition.await()时。\n\n## TIMED_WAITING\n\n有几个方法有超时参数，调用它们将导致线程进入TIMED_WAITING状态，如调用：Thread.sleep(long millis), Object.wait(long timeout), Lock.tryLock(), Condition.await(long time, TimeUnit unit)时。\n\n## TERMINATED\n\n* 因为run方法正常退出而自然终止。\n* 因为一个没有捕获的异常而终止。\n\n`stop()、suspend()、resume()已过时，不要使用。`\n\n# 线程属性\n\n线程属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。\n\n## 线程优先级\n\n在Java中每一个线程都有一个优先级，使用setPriority()方法可以设置线程的优先级，可以将优先级置为在MIN_PRIORITY(在Thread类中定义为0)和MAX_PRIORITY（在Thread类中定义为10）之间的任何值。NORM_PRIORITY被定义为5。\n\n`注意：线程优先级高度依赖于系统，Windows有7个优先级，Sun为Linux提供的Java虚拟机，线程的优先级被忽略——所有的线程具有相同的优先级。`\n\n## 守护线程\n\n通过调用方法setDaemon(true)来将线程设置为守护线程，守护线程的唯一作用是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，所以守护线程中永远不应该去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。\n\n## 未捕获异常处理器\n\n该处理器必须实现Thead.UncaughtExceptionHandler接口，该接口只有一个方法：void uncaughtException(Thread t, Throwable e)。\n使用setUncaughtExceptionHandler()方法为线程安装一个处理器，也可以使用静态方法Thread.setUncaughtExceptionHandler()为所有线程安装一个默认的处理器。\n\n# 线程的创建\n\n创建线程有三种方法：\n* 继承Thread类\n* 实现Runnable接口\n* 实现Callable接口\n\n## 继承Thread类\n\n步骤如下\n1. 继承Thread类，重写run方法\n2. 创建线程对象\n3. 执行start方法\n\n```\npublic class ExtendsThread extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            System.out.println(getName());\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    public static void main(String args[]) {\n        ExtendsThread subThread1 = new ExtendsThread();\n        subThread1.setName(\"subThread1\");\n        ExtendsThread subThread2 = new ExtendsThread();\n        subThread2.setName(\"subThread2\");\n        subThread1.start();\n        subThread2.start();\n    }\n}\n```\n\n输出结果(不固定)：\n\n```\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\n```\n\n`注意：不要调用Thread类或Runnable对象的run方法，直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。`\n\n## 实现Runnable接口\n\n1. 创建Runnable的实现类，重写run方法\n2. 创建该Runnable实现类的对象，并以该对象为参数创建Thread实例\n3. 执行start方法\n\n```\npublic class ImplRunnable {\n    public static void main(String args[]){\n        MyRunnable myRunnable = new MyRunnable();\n        Thread subThread1 = new Thread(myRunnable, \"subThread1\");\n        Thread subThread2 = new Thread(myRunnable, \"subThread2\");\n        subThread1.start();\n        subThread2.start();\n    }\n    static class MyRunnable implements Runnable{\n        @Override\n        public void run() {\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName());\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n\n输出结果（不固定）：\n\n```\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread1\nsubThread2\nsubThread1\nsubThread2\nsubThread2\nsubThread1\nsubThread2\nsubThread1\n```\n\n## 实现Callable接口\n\n1. 创建Callable的实现类，重写call()方法\n2. 创建该Callable实现类的对象，并以该对象为参数创建FutureTask对象\n3. 以该FutureTask对象为参数，创建Thread实例\n4. 执行start方法，并可调用FutureTask对象的方法获取线程执行的状态及返回结果。\n\n```\npublic class ImplCallable {\n    \n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable myCallable1 = new MyCallable(10);\n        MyCallable myCallable2 = new MyCallable(20);\n        FutureTask<Integer> futureTask1 = new FutureTask(myCallable1);\n        FutureTask<Integer> futureTask2 = new FutureTask(myCallable2);\n        Thread subThread1 = new Thread(futureTask1);\n        Thread subThread2 = new Thread(futureTask2);\n        subThread1.start();\n        subThread2.start();\n        System.out.println(futureTask1.get());\n        System.out.println(futureTask2.get());\n    }\n\n    static class MyCallable implements Callable<Integer>{\n        private int num;\n\n        public MyCallable(int num) {\n            this.num = num;\n        }\n\n        public int getNum() {\n            return num;\n        }\n\n        public void setNum(int num) {\n            this.num = num;\n        }\n\n        @Override\n        public Integer call() throws Exception {\n            for (int i = 0; i < num; i++) {\n                System.out.println(Thread.currentThread().getName());\n                try {\n                    Thread.sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            return num;\n        }\n    }\n    \n}\n```\n\n输出结果（不固定）：\n\n```\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\nThread-8\nThread-9\n10\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\nThread-9\n20\n```\n\n## 三种方式的比较\n\n1. Java中没有多重继承，因此在使用继承Thread类的方式创建线程时，不能再继承其他类；使用Runnable、Callable接口创建多线程时，还可以继承其他类，在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况； \n2. 使用Callable接口可以从线程中获取返回值。\n\n# 线程同步\n\n## synchronized关键字\n\n从1.0版本开始，Java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字声明，线程将获得对象的内部锁。\nsynchronized有两种方式：锁方法、锁对象。\n\n1. 锁方法，即用synchronized关键字修饰方法：\n\n```\n// 获得的是对象的内部锁\npublic synchronized void method(){\n\tmethod body\n}\n```\n\n```\n// 获得的是类锁，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁。\npublic static synchronized void(){\n\tmethod body\n}\n```\n\n2. 锁对象：\n\n```\npublic void method(){\n\t// 获得的是对象的内部锁\n\tsynchronized(this){\n\t\tcode block\n\t}\t\n}\n```\n\n```\nObject obj = new Object();\npublic void method(){\n\t// 获得的是obj的内部锁\n\tsynchronized(obj){\n\t\tcode block\n\t}\n}\n```\n\n```\npublic void method(){\n\t// 获得的是类锁\n\tsynchronized(xxx.class){\n\t\tcode block\n\t}\t\n}\n```\n\n```\npublic void method(){\n\t// 获得的是类锁\n\tsynchronized(Class.forName(\"xxx\")){\n\t\tcode block\n\t}\t\n}\n```\n\n## Lock\n\nLock(锁对象)允许把锁的实现作为Java类，而不是作为语言的特性来实现，这就为Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。\n\n### 方法摘要\n\n返回值|方法|解释\n--|--|--\nvoid|lock()|获取锁。\nvoid|lockInterruptibly()|如果当前线程未被中断，则获取锁。\nCondition|newCondition()|返回绑定到此 Lock 实例的新 Condition 实例。\nboolean|tryLock()|仅在调用时锁为空闲状态才获取该锁。\nboolean|tryLock(long time, TimeUnit unit)|如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。\nvoid|unlock()|释放锁。\n\n### ReentrantLock\n\nReentrantLock类是Lock的一个实现，使用ReentrantLock的代码块结构如下：\n\n```\nmyLock.lock();\ntry{\n\t......\n} finally {\n\tmyLock.unlock();\n}\n```\n\n`ReentrantLock(true)可以构造一个带有公平策略的锁，听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。`\n\n## ReadWriteLock\n\nReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。\n与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。\n\n### 方法摘要\n返回值|方法|解释\n--|--|--\nLock|readLock()|返回用于读取操作的锁。\nLock|writeLock()|返回用于写入操作的锁。\n\n### ReentrantReadWriteLock\n\nReentrantReadWriteLock是ReadWriteLock的实现类，其使用方式如下：\n\n```\nReentrantReadWriteLock lock = new ReentrantReadWriteLock();\nlock.readLock().lock();\t\t// 获得读锁\nlock.readLock().unLock();\t// 释放读锁\nlock.writeLock().lock();\t// 获得写锁\nlock.writeLock().unLock();\t// 释放写锁\n```\n\n下面来看一个实际的例子，使用读写锁来实现查询、存钱、取钱：\n例：\n\n```\npublic class ReadWriteLockStudy {\n\n    static class Account {\n\n        private long balance;\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n        private Lock readLock = lock.readLock();\n        private Lock writeLock = lock.writeLock();\n\n        public void show() {\n            readLock.lock();\n            System.out.println(\"获得readLock -- \" + Thread.currentThread().getName());\n            try {\n                System.out.println(\"显示余额:\" + balance);\n            } finally {\n                readLock.unlock();\n            }\n            System.out.println(\"释放readLock -- \" + Thread.currentThread().getName());\n        }\n\n        public void put(long money) {\n            writeLock.lock();\n            System.out.println(\"获得writeLock -- \" + Thread.currentThread().getName());\n            try {\n                balance += money;\n                System.out.println(\"存入:\" + money + \",余额:\" + balance);\n            } finally {\n                writeLock.unlock();\n                System.out.println(\"释放writeLock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take(long money) {\n            writeLock.lock();\n            System.out.println(\"获得writeLock -- \" + Thread.currentThread().getName());\n            try {\n                if (balance < money)\n                    System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance);\n                else {\n                    balance -= money;\n                    System.out.println(\"取出:\" + money + \",余额:\" + balance);\n                }\n            } finally {\n                writeLock.unlock();\n                System.out.println(\"释放writeLock -- \" + Thread.currentThread().getName());\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            int i = 0;\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class ShowThread extends Thread {\n        private Account account;\n\n        public ShowThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                account.show();\n                try {\n                    sleep(10);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        Account account = new Account();\n        PutThread putThread = new PutThread(account);\n        putThread.setName(\"putThread\");\n        TakeThread takeThread = new TakeThread(account);\n        takeThread.setName(\"takeThread\");\n        ShowThread showThread1 = new ShowThread(account);\n        showThread1.setName(\"showThread1\");\n        ShowThread showThread2 = new ShowThread(account);\n        showThread2.setName(\"showThread2\");\n\n        putThread.start();\n        takeThread.start();\n        showThread1.start();\n        showThread2.start();\n    }\n\n}\n```\n\n输出结果（不固定）：\n\n```\n获得writeLock -- putThread\n存入:46,余额:46\n释放writeLock -- putThread\n获得writeLock -- takeThread\n余额不足, 需取: 95; 余额: 46\n释放writeLock -- takeThread\n获得readLock -- showThread1\n显示余额:46\n释放readLock -- showThread1\n获得readLock -- showThread2\n显示余额:46\n释放readLock -- showThread2\n...\n...\n...\n获得readLock -- showThread2\n获得readLock -- showThread1\n显示余额:46\n显示余额:46\n释放readLock -- showThread1\n释放readLock -- showThread2\n```\n\n可以看到读-读不互斥，读-写互斥，写-写互斥。\n\n### Condition\n\n条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。\nCondition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。\n`不直接使用wait(), notify(), notifyAll()是因为 这几个方法是final方法。`\n可以为多个线程间建立不同的Condition。\n\n将上面的例子修改一下，增加两个功能：\n1. 当余额少于100时，马上存入100；\n2. 当余额大于200时，马上取出100；\n\n代码如下：\n\n```\npublic class ConditionStudy {\n\n    static class Account {\n\n        private long balance;\n\n        private Lock lock = new ReentrantLock();\n        private Condition condition100 = lock.newCondition();\n        private Condition condition200 = lock.newCondition();\n\n        public void put(long money) {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                balance += money;\n                System.out.println(\"存入:\" + money + \",余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n                condition200.signal();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take(long money) {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                if (balance < money)\n                    System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance + \" -- \" + Thread.currentThread().getName());\n                else {\n                    balance -= money;\n                    System.out.println(\"取出:\" + money + \",余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n                    condition100.signal();\n                }\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void put100() {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                while (balance >= 100) {\n                    System.out.println(\"余额大于等于100, 等待, 释放锁\" + \" -- \" + Thread.currentThread().getName());\n                    condition100.await();\n                }\n                balance += 100;\n                System.out.println(\"存入100, 余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n\n        public void take100() {\n            lock.lock();\n            System.out.println(\"获得lock -- \" + Thread.currentThread().getName());\n            try {\n                while (balance < 200) {\n                    System.out.println(\"余额小于200, 等待, 释放锁\" + \" -- \" + Thread.currentThread().getName());\n                    condition200.await();\n                }\n                balance -= 100;\n                System.out.println(\"取出100, 余额:\" + balance + \" -- \" + Thread.currentThread().getName());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n                System.out.println(\"释放lock -- \" + Thread.currentThread().getName());\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            Random random = new Random();\n            int i = 0;\n            while (i++ < 10) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class Put100Thread extends Thread {\n        private Account account;\n\n        public Put100Thread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    account.put100();\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class Take100Thread extends Thread {\n        private Account account;\n\n        public Take100Thread(Account account) {\n            this.account = account;\n        }\n\n        @Override\n        public void run() {\n            while (true) {\n                try {\n                    account.take100();\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String args[]) {\n        Account account = new Account();\n        PutThread putThread = new PutThread(account);\n        putThread.setName(\"putThread\");\n        TakeThread takeThread = new TakeThread(account);\n        takeThread.setName(\"takeThread\");\n        Put100Thread put100Thread = new Put100Thread(account);\n        put100Thread.setName(\"put100Thread\");\n        Take100Thread take100Thread = new Take100Thread(account);\n        take100Thread.setName(\"take100Thread\");\n\n        putThread.start();\n        takeThread.start();\n        put100Thread.start();\n        take100Thread.start();\n    }\n\n}\n```\n\n## volatile\n\nvolatile可以保证每次都从主内存中读取数据，且每次数据修改都写回主内存。如果一个变量声明为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。\n\n## 死锁\n\n死锁是指多个线程相互等待它方占有的资源而导致的每个线程都无法执行下去的情况。\n下面是一个简单的死锁例子：\n\n```\npublic class DeadLock {\n\n    static class MemStore {\n\n        Lock lock1 = new ReentrantLock();\n        Lock lock2 = new ReentrantLock();\n\n        public void method1() {\n            lock1.lock();\n            System.out.println(\"获得lock1 -- \" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n                lock2.lock();\n                try {\n                    System.out.println(\"获得lock2 -- \" + Thread.currentThread().getName());\n                } finally {\n                    lock2.unlock();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock1.unlock();\n            }\n        }\n\n        public void method2() {\n            lock2.lock();\n            System.out.println(\"获得lock2 -- \" + Thread.currentThread().getName());\n            try {\n                Thread.sleep(1000);\n                lock1.lock();\n                try {\n                    System.out.println(\"获得lock1 -- \" + Thread.currentThread().getName());\n                } finally {\n                    lock1.unlock();\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock2.unlock();\n            }\n        }\n    }\n\n    static class Thread1 extends Thread {\n        private MemStore memStore;\n\n        public Thread1(MemStore memStore) {\n            this.memStore = memStore;\n        }\n\n        @Override\n        public void run(){\n            memStore.method1();\n        }\n    }\n\n    static class Thread2 extends Thread {\n        private MemStore memStore;\n\n        public Thread2(MemStore memStore) {\n            this.memStore = memStore;\n        }\n\n        @Override\n        public void run(){\n            memStore.method2();\n        }\n    }\n\n    public static void main(String args[]) {\n        MemStore memStore = new MemStore();\n        Thread1 thread1 = new Thread1(memStore);\n        thread1.setName(\"thread1\");\n        Thread2 thread2 = new Thread2(memStore);\n        thread2.setName(\"thread2\");\n        thread1.start();\n        thread2.start();\n    }\n\n}\n```\n\n输出结果：\n\n```\n获得lock1 -- thread1\n获得lock2 -- thread2\n```\n可以看到thread1获得了lock1，等待获得lock2，而thread2获得了lock2，等待获得lock1，从而死锁。\n\n# 线程池\n\n多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。\n\n## 线程池原理\n\n假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。\n\n一个线程池包括以下四个基本组成部分：\n\n1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；\n2. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；\n3. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；\n4. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。\n\n线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。\n\n## 简单线程池的实现\n\n```\npublic class SimpleThreadPool {\n\n    // 线程数\n    private int threadNum = 10;\n    // 工作线程\n    private WorkThread[] workThreads;\n    // 任务队列, 待执行的线程\n    private BlockingQueue<Runnable> taskQueue;\n\n    public SimpleThreadPool(int threadNum) {\n        if (threadNum > 0)\n            this.threadNum = threadNum;\n        // 初始化任务队列\n        taskQueue = new LinkedBlockingDeque<>();\n        // 初始化工作线程\n        workThreads = new WorkThread[this.threadNum];\n        int i = 0;\n        while (i < threadNum) {\n            workThreads[i] = new WorkThread();\n            workThreads[i].setName(\"workThread-\" + i);\n            // 启动工作线程\n            workThreads[i].start();\n            i++;\n        }\n    }\n\n    public void execute(Runnable runnable) {\n        taskQueue.add(runnable);\n    }\n\n    public void execute(Runnable[] runnableList) {\n        for (Runnable runnable : runnableList)\n            execute(runnable);\n    }\n\n    public void destroy(){\n        for(WorkThread workThread: workThreads)\n            workThread.stopRun();\n    }\n\n    class WorkThread extends Thread {\n        private volatile boolean runFlag = true;\n\n        @Override\n        public void run() {\n            while (runFlag)\n                try {\n                    Runnable task = taskQueue.take();\n                    task.run();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n        }\n\n        public void stopRun() {\n            runFlag = false;\n        }\n    }\n\n    private static class Task implements Runnable {\n\n        private String name;\n\n        public Task(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public void run() {\n            System.out.println(name + \" run.\" + \"current thread: \" + Thread.currentThread().getName());\n        }\n    }\n\n    public static void main(String args[]) throws InterruptedException {\n        SimpleThreadPool simpleThreadPool = new SimpleThreadPool(3);\n        simpleThreadPool.execute(new Task(\"task0\"));\n        simpleThreadPool.execute(new Runnable[]{new Task(\"task1\"), new Task(\"task2\"), new Task(\"task3\"), new Task(\"task4\")});\n        simpleThreadPool.execute(new Runnable[]{new Task(\"task4\"), new Task(\"task5\"), new Task(\"task6\")});\n        Thread.sleep(1000);\n        simpleThreadPool.destroy();\n    }\n\n}\n```\n\n输出结果（不固定）：\n\n```\ntask0 run.current thread: workThread-0\ntask2 run.current thread: workThread-2\ntask1 run.current thread: workThread-1\ntask3 run.current thread: workThread-0\ntask4 run.current thread: workThread-2\ntask4 run.current thread: workThread-1\ntask5 run.current thread: workThread-0\ntask6 run.current thread: workThread-2\n```\n\n# concurrent包\n\njava.util.concurrent包是在并发编程中很常用的实用工具包。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。\n\n## 执行器\n\n接口。Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用execute()的线程中执行任务，并且可能顺序或并发执行。ExecutorService 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。Future 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。\n\n实现。类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 FutureTask，它提供 Future 的常见可扩展实现，以及 ExecutorCompletionService，它有助于协调对异步任务组的处理。\n\n## 队列\n\njava.util.concurrent.ConcurrentLinkedQueue类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 BlockingQueue 接口，该接口定义了 put 和 take 的阻塞版本：LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、PriorityBlockingQueue 和 DelayQueue。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。BlockingDeque 接口扩展 BlockingQueue，以支持 FIFO 和 LIFO（基于堆栈）操作。LinkedBlockingDeque 类提供一个实现。\n\n## 计时\n\nTimeUnit 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会“尽力”检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。\n\n## 同步器\n\n四个类可协助实现常见的专用同步语句。Semaphore 是一个经典的并发工具。CountDownLatch 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用。Exchanger 允许两个线程在 collection 点交换对象，它在多流水线设计中是有用的。\n\n## 并发 Collection\n\n除队列外，此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。\n此包中与某些类一起使用的“Concurrent&rdquo前缀;是一种简写，表明与类似的“同步”类有所不同。例如，java.util.Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步的，但 ConcurrentHashMap 则是“并发的”。并发 collection 是线程安全的，但是不受单个排他锁的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁不允许对 collection 的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共 collection 的其他情况中，通常“并发”版本要更好一些。当 collection 是未共享的，或者仅保持其他锁时 collection 是可访问的情况下，非同步 collection 则要更好一些。\n\n大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了弱一致的，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结 collection，所以它不一定反映自迭代器创建以来的所有更新。\n\n## 内存一致性属性\n\n只有写入操作 happen-before 读取操作时，才保证一个线程写入的结果对另一个线程的读取是可视的。synchronized 和 volatile 构造 happen-before 关系，Thread.start() 和 Thread.join() 方法形成 happen-before 关系。尤其是：\n线程中的每个操作 happen-before 稍后按程序顺序传入的该线程中的每个操作。\n一个解除锁监视器的（synchronized 阻塞或方法退出）happen-before 相同监视器的每个后续锁（synchronized 阻塞或方法进入）。并且因为 happen-before 关系是可传递的，所以解除锁定之前的线程的所有操作 happen-before 锁定该监视器的任何线程后续的所有操作。\n写入 volatile 字段 happen-before 每个后续读取相同字段。volatile 字段的读取和写入与进入和退出监视器具有相似的内存一致性效果，但不 需要互斥锁。\n在线程上调用 start happen-before 已启动的线程中的任何线程。\n线程中的所有操作 happen-before 从该线程上的 join 成功返回的任何其他线程。\njava.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：\n线程中将一个对象放入任何并发 collection 之前的操作 happen-before 从另一线程中的 collection 访问或移除该元素的后续操作。\n线程中向 Executor 提交 Runnable 之前的操作 happen-before 其执行开始。同样适用于向 ExecutorService 提交 Callables。\n异步计算（由 Future 表示）所采取的操作 happen-before 通过另一线程中 Future.get() 获取结果后续的操作。\n“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。\n对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 happen-before 另一线程中对应 exchange() 后续的操作。\n调用 CyclicBarrier.await 之前的操作 happen-before 屏障操作所执行的操作，屏障操作所执行的操作 happen-before 从另一线程中对应 await 成功返回的后续操作。\n\n# 关于线程个数\n\n我们的应用程序应该创建多少个线程会使得性能得到比较好的提升呢？以下代码可以计算一个合适的线程个数：\n\n```\npublic abstract class PoolSizeCalculator {\n\n    /**\n     * The sample queue size to calculate the size of a single {@link Runnable} element.\n     */\n    private final int SAMPLE_QUEUE_SIZE = 1000;\n\n    /**\n     * Accuracy of test run. It must finish within 20ms of the testTime otherwise we retry the test. This could be\n     * configurable.\n     */\n    private final int EPSYLON = 20;\n\n    /**\n     * Control variable for the CPU time investigation.\n     */\n    private volatile boolean expired;\n\n    /**\n     * Time (millis) of the test run in the CPU time calculation.\n     */\n    private final long testtime = 3000;\n\n    /**\n     * Calculates the boundaries of a thread pool for a given {@link Runnable}.\n     *\n     * @param targetUtilization    the desired utilization of the CPUs (0 <= targetUtilization <= 1)\n     * @param targetQueueSizeBytes the desired maximum work queue size of the thread pool (bytes)\n     */\n    protected void calculateBoundaries(BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes) {\n        calculateOptimalCapacity(targetQueueSizeBytes);\n        Runnable task = createTask();\n        start(task);\n        start(task); // warm up phase\n        long cputime = getCurrentThreadCPUTime();\n        start(task); // test intervall\n        cputime = getCurrentThreadCPUTime() - cputime;\n        long waittime = (testtime * 1000000) - cputime;\n        calculateOptimalThreadCount(cputime, waittime, targetUtilization);\n    }\n\n    private void calculateOptimalCapacity(BigDecimal targetQueueSizeBytes) {\n        long mem = calculateMemoryUsage();\n        BigDecimal queueCapacity = targetQueueSizeBytes.divide(new BigDecimal(mem), RoundingMode.HALF_UP);\n        System.out.println(\"Target queue memory usage (bytes): \" + targetQueueSizeBytes);\n        System.out.println(\"createTask() produced \" + createTask().getClass().getName() + \" which took \" + mem\n                + \" bytes in a queue\");\n        System.out.println(\"Formula: \" + targetQueueSizeBytes + \" / \" + mem);\n        System.out.println(\"* Recommended queue capacity (bytes): \" + queueCapacity);\n    }\n\n    /**\n     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in Practice' (chapter 8.2)\n     *\n     * @param cpu               cpu time consumed by considered task\n     * @param wait              wait time of considered task\n     * @param targetUtilization target utilization of the system\n     */\n    private void calculateOptimalThreadCount(long cpu, long wait, BigDecimal targetUtilization) {\n        BigDecimal waitTime = new BigDecimal(wait);\n        BigDecimal computeTime = new BigDecimal(cpu);\n        BigDecimal numberOfCPU = new BigDecimal(Runtime.getRuntime().availableProcessors());\n        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization).multiply(\n                new BigDecimal(1).add(waitTime.divide(computeTime, RoundingMode.HALF_UP)));\n        System.out.println(\"Number of CPU: \" + numberOfCPU);\n        System.out.println(\"Target utilization: \" + targetUtilization);\n        System.out.println(\"Elapsed time (nanos): \" + (testtime * 1000000));\n        System.out.println(\"Compute time (nanos): \" + cpu);\n        System.out.println(\"Wait time (nanos): \" + wait);\n        System.out.println(\"Formula: \" + numberOfCPU + \" * \" + targetUtilization + \" * (1 + \" + waitTime + \" / \"\n                + computeTime + \")\");\n        System.out.println(\"* Optimal thread count: \" + optimalthreadcount);\n    }\n\n    /**\n     * Runs the {@link Runnable} over a period defined in {@link #testtime}. Based on Heinz Kabbutz' ideas\n     * (http://www.javaspecialists.eu/archive/Issue124.html).\n     *\n     * @param task the runnable under investigation\n     */\n    public void start(Runnable task) {\n        long start = 0;\n        int runs = 0;\n        do {\n            if (++runs > 5) {\n                throw new IllegalStateException(\"Test not accurate\");\n            }\n            expired = false;\n            start = System.currentTimeMillis();\n            Timer timer = new Timer();\n            timer.schedule(new TimerTask() {\n                public void run() {\n                    expired = true;\n                }\n            }, testtime);\n            while (!expired) {\n                task.run();\n            }\n            start = System.currentTimeMillis() - start;\n            timer.cancel();\n        } while (Math.abs(start - testtime) > EPSYLON);\n        collectGarbage(3);\n    }\n\n    private void collectGarbage(int times) {\n        for (int i = 0; i < times; i++) {\n            System.gc();\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates the memory usage of a single element in a work queue. Based on Heinz Kabbutz' ideas\n     * (http://www.javaspecialists.eu/archive/Issue029.html).\n     *\n     * @return memory usage of a single {@link Runnable} element in the thread pools work queue\n     */\n    public long calculateMemoryUsage() {\n        BlockingQueue<Runnable> queue = createWorkQueue();\n        for (int i = 0; i < SAMPLE_QUEUE_SIZE; i++) {\n            queue.add(createTask());\n        }\n        long mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        long mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        queue = null;\n        collectGarbage(15);\n        mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        queue = createWorkQueue();\n        for (int i = 0; i < SAMPLE_QUEUE_SIZE; i++) {\n            queue.add(createTask());\n        }\n        collectGarbage(15);\n        mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n        return (mem1 - mem0) / SAMPLE_QUEUE_SIZE;\n    }\n\n    /**\n     * Create your runnable task here.\n     *\n     * @return an instance of your runnable task under investigation\n     */\n    protected abstract Runnable createTask();\n\n    /**\n     * Return an instance of the queue used in the thread pool.\n     *\n     * @return queue instance\n     */\n    protected abstract BlockingQueue<Runnable> createWorkQueue();\n\n    /**\n     * Calculate current cpu time. Various frameworks may be used here, depending on the operating system in use. (e.g.\n     * http://www.hyperic.com/products/sigar). The more accurate the CPU time measurement, the more accurate the results\n     * for thread count boundaries.\n     *\n     * @return current cpu time of current thread\n     */\n    protected abstract long getCurrentThreadCPUTime();\n\n}\n```\n\n```\npublic class MyPoolSizeCalculator extends PoolSizeCalculator {\n\n    public static void main(String[] args) throws InterruptedException,\n            InstantiationException,\n            IllegalAccessException,\n            ClassNotFoundException {\n        MyPoolSizeCalculator calculator = new MyPoolSizeCalculator();\n        calculator.calculateBoundaries(new BigDecimal(1.0),\n                new BigDecimal(100000));\n    }\n\n    protected long getCurrentThreadCPUTime() {\n        return ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();\n    }\n\n    protected Runnable createTask() {\n        return new Runnable() {\n            @Override\n            public void run() {\n                for (int i = 0; i < 10000; i++)\n                    System.out.println(i);\n            }\n        };\n    }\n\n    protected BlockingQueue<Runnable> createWorkQueue() {\n        return new LinkedBlockingQueue<>();\n    }\n\n}\n```\n\n`createTask的方法根据自己的实际需要进行修改。`\n\n得到类似如下结果 ：\n\n```\nNumber of CPU: 4\nTarget utilization: 1\nElapsed time (nanos): 3000000000\nCompute time (nanos): 2017495000\nWait time (nanos): 982505000\nFormula: 4 * 1 * (1 + 982505000 / 2017495000)\n* Optimal thread count: 4\n```\n由此可知，在上述场景中，创建4个线程比较合适。\n","slug":"java-core-thread","published":1,"updated":"2016-04-28T10:04:45.000Z","_id":"cinb2xtmv000ibgv027p5xd2v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>线程是程序执行流的最小单元，多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。</p>\n<h1 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h1><p>Java的线程如下有6种状态：<br>NEW（新建）<br>RUNNABLE（就绪，可运行）<br>BLOCKED（被阻塞）<br>WAITING（等待）<br>TIMED_WAITING（计时等待）<br>TERMINATED（被终止）</p>\n<p>可以使用Thread.getState()方法获取线程的当前状态。在Thread类中线程状态由一个整型变量threadStatus表示，getState()方法调用VM类的toThreadState()方法，根据threadStatus某个位置上是否为1来判断线程状态，代码如下：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(var0 &amp; <span class=\"number\">4</span>) != <span class=\"number\">0</span>?State.RUNNABLE:((var0 &amp; <span class=\"number\">1024</span>) != <span class=\"number\">0</span>?State.BLOCKED:((var0 &amp; <span class=\"number\">16</span>) != <span class=\"number\">0</span>?State.WAITING:((var0 &amp; <span class=\"number\">32</span>) != <span class=\"number\">0</span>?State.TIMED_WAITING:((var0 &amp; <span class=\"number\">2</span>) != <span class=\"number\">0</span>?State.TERMINATED:((var0 &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>?State.NEW:State.RUNNABLE)))));</span><br></pre></td></tr></table></figure>\n<h2 id=\"NEW\"><a href=\"#NEW\" class=\"headerlink\" title=\"NEW\"></a>NEW</h2><p>当用new操作符创建一个新线程时，如new Thread()，该线程还没有运行，此时线程状态是NEW。</p>\n<h2 id=\"RUNNABLE\"><a href=\"#RUNNABLE\" class=\"headerlink\" title=\"RUNNABLE\"></a>RUNNABLE</h2><p>一旦调用start()方法，线程处于RUNNABLE状态。<br><code>一个RUNNABLE状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间</code>。</p>\n<h2 id=\"BLOCKED\"><a href=\"#BLOCKED\" class=\"headerlink\" title=\"BLOCKED\"></a>BLOCKED</h2><p>当一个线程试图获取一个内部对象锁，而该锁被其他线程持有，则该线程进入BLOCKED状态。</p>\n<h2 id=\"WAITING\"><a href=\"#WAITING\" class=\"headerlink\" title=\"WAITING\"></a>WAITING</h2><p>当一个线程等待另一个线程通知调度器一个条件时，进入WAITING状态，如调用：Object.wait(), Thread.join(), Lock.lock(), Condition.await()时。</p>\n<h2 id=\"TIMED-WAITING\"><a href=\"#TIMED-WAITING\" class=\"headerlink\" title=\"TIMED_WAITING\"></a>TIMED_WAITING</h2><p>有几个方法有超时参数，调用它们将导致线程进入TIMED_WAITING状态，如调用：Thread.sleep(long millis), Object.wait(long timeout), Lock.tryLock(), Condition.await(long time, TimeUnit unit)时。</p>\n<h2 id=\"TERMINATED\"><a href=\"#TERMINATED\" class=\"headerlink\" title=\"TERMINATED\"></a>TERMINATED</h2><ul>\n<li>因为run方法正常退出而自然终止。</li>\n<li>因为一个没有捕获的异常而终止。</li>\n</ul>\n<p><code>stop()、suspend()、resume()已过时，不要使用。</code></p>\n<h1 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h1><p>线程属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。</p>\n<h2 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h2><p>在Java中每一个线程都有一个优先级，使用setPriority()方法可以设置线程的优先级，可以将优先级置为在MIN_PRIORITY(在Thread类中定义为0)和MAX_PRIORITY（在Thread类中定义为10）之间的任何值。NORM_PRIORITY被定义为5。</p>\n<p><code>注意：线程优先级高度依赖于系统，Windows有7个优先级，Sun为Linux提供的Java虚拟机，线程的优先级被忽略——所有的线程具有相同的优先级。</code></p>\n<h2 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h2><p>通过调用方法setDaemon(true)来将线程设置为守护线程，守护线程的唯一作用是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，所以守护线程中永远不应该去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</p>\n<h2 id=\"未捕获异常处理器\"><a href=\"#未捕获异常处理器\" class=\"headerlink\" title=\"未捕获异常处理器\"></a>未捕获异常处理器</h2><p>该处理器必须实现Thead.UncaughtExceptionHandler接口，该接口只有一个方法：void uncaughtException(Thread t, Throwable e)。<br>使用setUncaughtExceptionHandler()方法为线程安装一个处理器，也可以使用静态方法Thread.setUncaughtExceptionHandler()为所有线程安装一个默认的处理器。</p>\n<h1 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h1><p>创建线程有三种方法：</p>\n<ul>\n<li>继承Thread类</li>\n<li>实现Runnable接口</li>\n<li>实现Callable接口</li>\n</ul>\n<h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><p>步骤如下</p>\n<ol>\n<li>继承Thread类，重写run方法</li>\n<li>创建线程对象</li>\n<li>执行start方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendsThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        ExtendsThread subThread1 = <span class=\"keyword\">new</span> ExtendsThread();</span><br><span class=\"line\">        subThread1.setName(<span class=\"string\">\"subThread1\"</span>);</span><br><span class=\"line\">        ExtendsThread subThread2 = <span class=\"keyword\">new</span> ExtendsThread();</span><br><span class=\"line\">        subThread2.setName(<span class=\"string\">\"subThread2\"</span>);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果(不固定)：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span></span><br></pre></td></tr></table></figure>\n<p><code>注意：不要调用Thread类或Runnable对象的run方法，直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。</code></p>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><ol>\n<li>创建Runnable的实现类，重写run方法</li>\n<li>创建该Runnable实现类的对象，并以该对象为参数创建Thread实例</li>\n<li>执行start方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplRunnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        MyRunnable myRunnable = <span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">        Thread subThread1 = <span class=\"keyword\">new</span> Thread(myRunnable, <span class=\"string\">\"subThread1\"</span>);</span><br><span class=\"line\">        Thread subThread2 = <span class=\"keyword\">new</span> Thread(myRunnable, <span class=\"string\">\"subThread2\"</span>);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实现Callable接口\"><a href=\"#实现Callable接口\" class=\"headerlink\" title=\"实现Callable接口\"></a>实现Callable接口</h2><ol>\n<li>创建Callable的实现类，重写call()方法</li>\n<li>创建该Callable实现类的对象，并以该对象为参数创建FutureTask对象</li>\n<li>以该FutureTask对象为参数，创建Thread实例</li>\n<li>执行start方法，并可调用FutureTask对象的方法获取线程执行的状态及返回结果。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplCallable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        MyCallable myCallable1 = <span class=\"keyword\">new</span> MyCallable(<span class=\"number\">10</span>);</span><br><span class=\"line\">        MyCallable myCallable2 = <span class=\"keyword\">new</span> MyCallable(<span class=\"number\">20</span>);</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask1 = <span class=\"keyword\">new</span> FutureTask(myCallable1);</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask2 = <span class=\"keyword\">new</span> FutureTask(myCallable2);</span><br><span class=\"line\">        Thread subThread1 = <span class=\"keyword\">new</span> Thread(futureTask1);</span><br><span class=\"line\">        Thread subThread2 = <span class=\"keyword\">new</span> Thread(futureTask2);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">        System.out.println(futureTask1.get());</span><br><span class=\"line\">        System.out.println(futureTask2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCallable</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"三种方式的比较\"><a href=\"#三种方式的比较\" class=\"headerlink\" title=\"三种方式的比较\"></a>三种方式的比较</h2><ol>\n<li>Java中没有多重继承，因此在使用继承Thread类的方式创建线程时，不能再继承其他类；使用Runnable、Callable接口创建多线程时，还可以继承其他类，在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况； </li>\n<li>使用Callable接口可以从线程中获取返回值。</li>\n</ol>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><p>从1.0版本开始，Java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字声明，线程将获得对象的内部锁。<br>synchronized有两种方式：锁方法、锁对象。</p>\n<ol>\n<li>锁方法，即用synchronized关键字修饰方法：</li>\n</ol>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得的是对象的内部锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> synchronized void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\tmethod body</span><br><span class=\"line\">&#125;</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得的是类锁，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>()&#123;</span><br><span class=\"line\">\tmethod <span class=\"keyword\">body</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>锁对象：</li>\n</ol>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是对象的内部锁</span><br><span class=\"line\">\tsynchronized(this)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是obj的内部锁</span><br><span class=\"line\">\tsynchronized(obj)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span></span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是类锁</span><br><span class=\"line\">\tsynchronized(xxx.class)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是类锁</span><br><span class=\"line\">\tsynchronized(Class.forName(\"xxx\"))&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>Lock(锁对象)允许把锁的实现作为Java类，而不是作为语言的特性来实现，这就为Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</p>\n<h3 id=\"方法摘要\"><a href=\"#方法摘要\" class=\"headerlink\" title=\"方法摘要\"></a>方法摘要</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td>lock()</td>\n<td>获取锁。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>lockInterruptibly()</td>\n<td>如果当前线程未被中断，则获取锁。</td>\n</tr>\n<tr>\n<td>Condition</td>\n<td>newCondition()</td>\n<td>返回绑定到此 Lock 实例的新 Condition 实例。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>tryLock()</td>\n<td>仅在调用时锁为空闲状态才获取该锁。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>tryLock(long time, TimeUnit unit)</td>\n<td>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>unlock()</td>\n<td>释放锁。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p>ReentrantLock类是Lock的一个实现，使用ReentrantLock的代码块结构如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myLock<span class=\"selector-class\">.lock</span>();</span><br><span class=\"line\"><span class=\"selector-tag\">try</span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125; <span class=\"selector-tag\">finally</span> &#123;</span><br><span class=\"line\">\tmyLock<span class=\"selector-class\">.unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReentrantLock(true)可以构造一个带有公平策略的锁，听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。</code></p>\n<h2 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h2><p>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。<br>与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。</p>\n<h3 id=\"方法摘要-1\"><a href=\"#方法摘要-1\" class=\"headerlink\" title=\"方法摘要\"></a>方法摘要</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Lock</td>\n<td>readLock()</td>\n<td>返回用于读取操作的锁。</td>\n</tr>\n<tr>\n<td>Lock</td>\n<td>writeLock()</td>\n<td>返回用于写入操作的锁。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是ReadWriteLock的实现类，其使用方式如下：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantReadWriteLock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"><span class=\"keyword\">lock</span>.readLock().<span class=\"keyword\">lock</span>();\t\t<span class=\"comment\">// 获得读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.readLock().unLock();\t<span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.writeLock().<span class=\"keyword\">lock</span>();\t<span class=\"comment\">// 获得写锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.writeLock().unLock();\t<span class=\"comment\">// 释放写锁</span></span><br></pre></td></tr></table></figure>\n<p>下面来看一个实际的例子，使用读写锁来实现查询、存钱、取钱：<br>例：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ReadWriteLockStudy</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> ReadWriteLock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock readLock = <span class=\"keyword\">lock</span>.readLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock writeLock = <span class=\"keyword\">lock</span>.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            readLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得readLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"显示余额:\"</span> + balance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                readLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放readLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            writeLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                balance += money;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            writeLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (balance &lt; money)</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    balance -= money;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">ShowThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShowThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                account.show();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">        PutThread putThread = <span class=\"keyword\">new</span> PutThread(account);</span><br><span class=\"line\">        putThread.setName(<span class=\"string\">\"putThread\"</span>);</span><br><span class=\"line\">        TakeThread takeThread = <span class=\"keyword\">new</span> TakeThread(account);</span><br><span class=\"line\">        takeThread.setName(<span class=\"string\">\"takeThread\"</span>);</span><br><span class=\"line\">        ShowThread showThread1 = <span class=\"keyword\">new</span> ShowThread(account);</span><br><span class=\"line\">        showThread1.setName(<span class=\"string\">\"showThread1\"</span>);</span><br><span class=\"line\">        ShowThread showThread2 = <span class=\"keyword\">new</span> ShowThread(account);</span><br><span class=\"line\">        showThread2.setName(<span class=\"string\">\"showThread2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        putThread.start();</span><br><span class=\"line\">        takeThread.start();</span><br><span class=\"line\">        showThread1.start();</span><br><span class=\"line\">        showThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得writeLock <span class=\"comment\">-- putThread</span></span><br><span class=\"line\">存入:<span class=\"number\">46</span>,余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放writeLock <span class=\"comment\">-- putThread</span></span><br><span class=\"line\">获得writeLock <span class=\"comment\">-- takeThread</span></span><br><span class=\"line\">余额不足, 需取: <span class=\"number\">95</span>; 余额: <span class=\"number\">46</span></span><br><span class=\"line\">释放writeLock <span class=\"comment\">-- takeThread</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到读-读不互斥，读-写互斥，写-写互斥。</p>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。<br>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。<br><code>不直接使用wait(), notify(), notifyAll()是因为 这几个方法是final方法。</code><br>可以为多个线程间建立不同的Condition。</p>\n<p>将上面的例子修改一下，增加两个功能：</p>\n<ol>\n<li>当余额少于100时，马上存入100；</li>\n<li>当余额大于200时，马上取出100；</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ConditionStudy</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Condition condition100 = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Condition condition200 = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                balance += money;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                condition200.signal();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (balance &lt; money)</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    balance -= money;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition100.signal();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put100</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (balance &gt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额大于等于100, 等待, 释放锁\"</span> + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition100.await();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                balance += <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入100, 余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take100</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (balance &lt; <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额小于200, 等待, 释放锁\"</span> + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition200.await();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                balance -= <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出100, 余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i++ &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Put100Thread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Put100Thread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put100();</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Take100Thread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Take100Thread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take100();</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">        PutThread putThread = <span class=\"keyword\">new</span> PutThread(account);</span><br><span class=\"line\">        putThread.setName(<span class=\"string\">\"putThread\"</span>);</span><br><span class=\"line\">        TakeThread takeThread = <span class=\"keyword\">new</span> TakeThread(account);</span><br><span class=\"line\">        takeThread.setName(<span class=\"string\">\"takeThread\"</span>);</span><br><span class=\"line\">        Put100Thread put100Thread = <span class=\"keyword\">new</span> Put100Thread(account);</span><br><span class=\"line\">        put100Thread.setName(<span class=\"string\">\"put100Thread\"</span>);</span><br><span class=\"line\">        Take100Thread take100Thread = <span class=\"keyword\">new</span> Take100Thread(account);</span><br><span class=\"line\">        take100Thread.setName(<span class=\"string\">\"take100Thread\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        putThread.start();</span><br><span class=\"line\">        takeThread.start();</span><br><span class=\"line\">        put100Thread.start();</span><br><span class=\"line\">        take100Thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>volatile可以保证每次都从主内存中读取数据，且每次数据修改都写回主内存。如果一个变量声明为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指多个线程相互等待它方占有的资源而导致的每个线程都无法执行下去的情况。<br>下面是一个简单的死锁例子：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">MemStore</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock1 = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        Lock lock2 = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            lock1.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock1 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                lock2.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock2 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock2.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock1.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            lock2.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock2 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                lock1.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock1 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock1.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock2.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MemStore memStore;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread1</span>(<span class=\"params\">MemStore memStore</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.memStore = memStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            memStore.method1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Thread2</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MemStore memStore;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread2</span>(<span class=\"params\">MemStore memStore</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.memStore = memStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            memStore.method2();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        MemStore memStore = <span class=\"keyword\">new</span> MemStore();</span><br><span class=\"line\">        Thread1 thread1 = <span class=\"keyword\">new</span> Thread1(memStore);</span><br><span class=\"line\">        thread1.setName(<span class=\"string\">\"thread1\"</span>);</span><br><span class=\"line\">        Thread2 thread2 = <span class=\"keyword\">new</span> Thread2(memStore);</span><br><span class=\"line\">        thread2.setName(<span class=\"string\">\"thread2\"</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得lock1 <span class=\"comment\">-- thread1</span></span><br><span class=\"line\">获得lock2 <span class=\"comment\">-- thread2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到thread1获得了lock1，等待获得lock2，而thread2获得了lock2，等待获得lock1，从而死锁。</p>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p>\n<h2 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h2><p>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</p>\n<p>一个线程池包括以下四个基本组成部分：</p>\n<ol>\n<li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>\n<li>工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li>\n<li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li>\n<li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>\n</ol>\n<p>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>\n<h2 id=\"简单线程池的实现\"><a href=\"#简单线程池的实现\" class=\"headerlink\" title=\"简单线程池的实现\"></a>简单线程池的实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleThreadPool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadNum = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 工作线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WorkThread[] workThreads;</span><br><span class=\"line\">    <span class=\"comment\">// 任务队列, 待执行的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadNum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.threadNum = threadNum;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化任务队列</span></span><br><span class=\"line\">        taskQueue = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 初始化工作线程</span></span><br><span class=\"line\">        workThreads = <span class=\"keyword\">new</span> WorkThread[<span class=\"keyword\">this</span>.threadNum];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; threadNum) &#123;</span><br><span class=\"line\">            workThreads[i] = <span class=\"keyword\">new</span> WorkThread();</span><br><span class=\"line\">            workThreads[i].setName(<span class=\"string\">\"workThread-\"</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">// 启动工作线程</span></span><br><span class=\"line\">            workThreads[i].start();</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">        taskQueue.add(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable[] runnableList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Runnable runnable : runnableList)</span><br><span class=\"line\">            execute(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(WorkThread workThread: workThreads)</span><br><span class=\"line\">            workThread.stopRun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> runFlag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (runFlag)</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Runnable task = taskQueue.take();</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopRun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            runFlag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">\" run.\"</span> + <span class=\"string\">\"current thread: \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        SimpleThreadPool simpleThreadPool = <span class=\"keyword\">new</span> SimpleThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task0\"</span>));</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Runnable[]&#123;<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task1\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task2\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task3\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task4\"</span>)&#125;);</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Runnable[]&#123;<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task4\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task5\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task6\"</span>)&#125;);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        simpleThreadPool.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task0 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task2 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br><span class=\"line\">task1 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">1</span></span><br><span class=\"line\">task3 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task4 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br><span class=\"line\">task4 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">1</span></span><br><span class=\"line\">task5 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task6 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"concurrent包\"><a href=\"#concurrent包\" class=\"headerlink\" title=\"concurrent包\"></a>concurrent包</h1><p>java.util.concurrent包是在并发编程中很常用的实用工具包。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。</p>\n<h2 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h2><p>接口。Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用execute()的线程中执行任务，并且可能顺序或并发执行。ExecutorService 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。Future 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。</p>\n<p>实现。类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 FutureTask，它提供 Future 的常见可扩展实现，以及 ExecutorCompletionService，它有助于协调对异步任务组的处理。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>java.util.concurrent.ConcurrentLinkedQueue类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 BlockingQueue 接口，该接口定义了 put 和 take 的阻塞版本：LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、PriorityBlockingQueue 和 DelayQueue。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。BlockingDeque 接口扩展 BlockingQueue，以支持 FIFO 和 LIFO（基于堆栈）操作。LinkedBlockingDeque 类提供一个实现。</p>\n<h2 id=\"计时\"><a href=\"#计时\" class=\"headerlink\" title=\"计时\"></a>计时</h2><p>TimeUnit 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会“尽力”检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。</p>\n<h2 id=\"同步器\"><a href=\"#同步器\" class=\"headerlink\" title=\"同步器\"></a>同步器</h2><p>四个类可协助实现常见的专用同步语句。Semaphore 是一个经典的并发工具。CountDownLatch 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用。Exchanger 允许两个线程在 collection 点交换对象，它在多流水线设计中是有用的。</p>\n<h2 id=\"并发-Collection\"><a href=\"#并发-Collection\" class=\"headerlink\" title=\"并发 Collection\"></a>并发 Collection</h2><p>除队列外，此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。<br>此包中与某些类一起使用的“Concurrent&amp;rdquo前缀;是一种简写，表明与类似的“同步”类有所不同。例如，java.util.Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步的，但 ConcurrentHashMap 则是“并发的”。并发 collection 是线程安全的，但是不受单个排他锁的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁不允许对 collection 的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共 collection 的其他情况中，通常“并发”版本要更好一些。当 collection 是未共享的，或者仅保持其他锁时 collection 是可访问的情况下，非同步 collection 则要更好一些。</p>\n<p>大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了弱一致的，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结 collection，所以它不一定反映自迭代器创建以来的所有更新。</p>\n<h2 id=\"内存一致性属性\"><a href=\"#内存一致性属性\" class=\"headerlink\" title=\"内存一致性属性\"></a>内存一致性属性</h2><p>只有写入操作 happen-before 读取操作时，才保证一个线程写入的结果对另一个线程的读取是可视的。synchronized 和 volatile 构造 happen-before 关系，Thread.start() 和 Thread.join() 方法形成 happen-before 关系。尤其是：<br>线程中的每个操作 happen-before 稍后按程序顺序传入的该线程中的每个操作。<br>一个解除锁监视器的（synchronized 阻塞或方法退出）happen-before 相同监视器的每个后续锁（synchronized 阻塞或方法进入）。并且因为 happen-before 关系是可传递的，所以解除锁定之前的线程的所有操作 happen-before 锁定该监视器的任何线程后续的所有操作。<br>写入 volatile 字段 happen-before 每个后续读取相同字段。volatile 字段的读取和写入与进入和退出监视器具有相似的内存一致性效果，但不 需要互斥锁。<br>在线程上调用 start happen-before 已启动的线程中的任何线程。<br>线程中的所有操作 happen-before 从该线程上的 join 成功返回的任何其他线程。<br>java.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：<br>线程中将一个对象放入任何并发 collection 之前的操作 happen-before 从另一线程中的 collection 访问或移除该元素的后续操作。<br>线程中向 Executor 提交 Runnable 之前的操作 happen-before 其执行开始。同样适用于向 ExecutorService 提交 Callables。<br>异步计算（由 Future 表示）所采取的操作 happen-before 通过另一线程中 Future.get() 获取结果后续的操作。<br>“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。<br>对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 happen-before 另一线程中对应 exchange() 后续的操作。<br>调用 CyclicBarrier.await 之前的操作 happen-before 屏障操作所执行的操作，屏障操作所执行的操作 happen-before 从另一线程中对应 await 成功返回的后续操作。</p>\n<h1 id=\"关于线程个数\"><a href=\"#关于线程个数\" class=\"headerlink\" title=\"关于线程个数\"></a>关于线程个数</h1><p>我们的应用程序应该创建多少个线程会使得性能得到比较好的提升呢？以下代码可以计算一个合适的线程个数：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">PoolSizeCalculator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * The sample queue size to calculate the size of a single &#123;@link Runnable&#125; element.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">int</span> SAMPLE_QUEUE_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Accuracy of test run. It must finish within 20ms of the testTime otherwise we retry the test. This could be</span><br><span class=\"line\">     * configurable.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">int</span> EPSYLON = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Control variable for the CPU time investigation.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> boolean expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Time (millis) of the test run in the CPU time calculation.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">long</span> testtime = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculates the boundaries of a thread pool for a given &#123;@link Runnable&#125;.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param targetUtilization    the desired utilization of the CPUs (0 &lt;= targetUtilization &lt;= 1)</span><br><span class=\"line\">     * @param targetQueueSizeBytes the desired maximum work queue size of the thread pool (bytes)</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateBoundaries</span>(<span class=\"params\">BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes</span>) </span>&#123;</span><br><span class=\"line\">        calculateOptimalCapacity(targetQueueSizeBytes);</span><br><span class=\"line\">        Runnable task = createTask();</span><br><span class=\"line\">        start(task);</span><br><span class=\"line\">        start(task); <span class=\"comment\">// warm up phase</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> cputime = getCurrentThreadCPUTime();</span><br><span class=\"line\">        start(task); <span class=\"comment\">// test intervall</span></span><br><span class=\"line\">        cputime = getCurrentThreadCPUTime() - cputime;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waittime = (testtime * <span class=\"number\">1000000</span>) - cputime;</span><br><span class=\"line\">        calculateOptimalThreadCount(cputime, waittime, targetUtilization);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateOptimalCapacity</span>(<span class=\"params\">BigDecimal targetQueueSizeBytes</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem = calculateMemoryUsage();</span><br><span class=\"line\">        BigDecimal queueCapacity = targetQueueSizeBytes.divide(<span class=\"keyword\">new</span> BigDecimal(mem), RoundingMode.HALF_UP);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Target queue memory usage (bytes): \"</span> + targetQueueSizeBytes);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"createTask() produced \"</span> + createTask().getClass().getName() + <span class=\"string\">\" which took \"</span> + mem</span><br><span class=\"line\">                + <span class=\"string\">\" bytes in a queue\"</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Formula: \"</span> + targetQueueSizeBytes + <span class=\"string\">\" / \"</span> + mem);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"* Recommended queue capacity (bytes): \"</span> + queueCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in Practice' (chapter 8.2)</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param cpu               cpu time consumed by considered task</span><br><span class=\"line\">     * @param wait              wait time of considered task</span><br><span class=\"line\">     * @param targetUtilization target utilization of the system</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateOptimalThreadCount</span>(<span class=\"params\"><span class=\"keyword\">long</span> cpu, <span class=\"keyword\">long</span> wait, BigDecimal targetUtilization</span>) </span>&#123;</span><br><span class=\"line\">        BigDecimal waitTime = <span class=\"keyword\">new</span> BigDecimal(wait);</span><br><span class=\"line\">        BigDecimal computeTime = <span class=\"keyword\">new</span> BigDecimal(cpu);</span><br><span class=\"line\">        BigDecimal numberOfCPU = <span class=\"keyword\">new</span> BigDecimal(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization).multiply(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">1</span>).add(waitTime.divide(computeTime, RoundingMode.HALF_UP)));</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Number of CPU: \"</span> + numberOfCPU);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Target utilization: \"</span> + targetUtilization);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Elapsed time (nanos): \"</span> + (testtime * <span class=\"number\">1000000</span>));</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Compute time (nanos): \"</span> + cpu);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Wait time (nanos): \"</span> + wait);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Formula: \"</span> + numberOfCPU + <span class=\"string\">\" * \"</span> + targetUtilization + <span class=\"string\">\" * (1 + \"</span> + waitTime + <span class=\"string\">\" / \"</span></span><br><span class=\"line\">                + computeTime + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"* Optimal thread count: \"</span> + optimalthreadcount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Runs the &#123;@link Runnable&#125; over a period defined in &#123;@link #testtime&#125;. Based on Heinz Kabbutz' ideas</span><br><span class=\"line\">     * (http://www.javaspecialists.eu/archive/Issue124.html).</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param task the runnable under investigation</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span>(<span class=\"params\">Runnable task</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> runs = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++runs &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Test not accurate\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            expired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            start = System.currentTimeMillis();</span><br><span class=\"line\">            Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">            timer.schedule(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    expired = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, testtime);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!expired) &#123;</span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            start = System.currentTimeMillis() - start;</span><br><span class=\"line\">            timer.cancel();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (Math.abs(start - testtime) &gt; EPSYLON);</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">collectGarbage</span>(<span class=\"params\"><span class=\"keyword\">int</span> times</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">            System.gc();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculates the memory usage of a single element in a work queue. Based on Heinz Kabbutz' ideas</span><br><span class=\"line\">     * (http://www.javaspecialists.eu/archive/Issue029.html).</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return memory usage of a single &#123;@link Runnable&#125; element in the thread pools work queue</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">calculateMemoryUsage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; queue = createWorkQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class=\"line\">            queue.add(createTask());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        queue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">15</span>);</span><br><span class=\"line\">        mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        queue = createWorkQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class=\"line\">            queue.add(createTask());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">15</span>);</span><br><span class=\"line\">        mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (mem1 - mem0) / SAMPLE_QUEUE_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Create your runnable task here.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return an instance of your runnable task under investigation</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Runnable <span class=\"title\">createTask</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Return an instance of the queue used in the thread pool.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return queue instance</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> BlockingQueue&lt;Runnable&gt; <span class=\"title\">createWorkQueue</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculate current cpu time. Various frameworks may be used here, depending on the operating system in use. (e.g.</span><br><span class=\"line\">     * http://www.hyperic.com/products/sigar). The more accurate the CPU time measurement, the more accurate the results</span><br><span class=\"line\">     * for thread count boundaries.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return current cpu time of current thread</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">getCurrentThreadCPUTime</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPoolSizeCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">PoolSizeCalculator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException,</span><br><span class=\"line\">            InstantiationException,</span><br><span class=\"line\">            IllegalAccessException,</span><br><span class=\"line\">            ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        MyPoolSizeCalculator calculator = <span class=\"keyword\">new</span> MyPoolSizeCalculator();</span><br><span class=\"line\">        calculator.calculateBoundaries(<span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">1.0</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">getCurrentThreadCPUTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Runnable <span class=\"title\">createTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">                    System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> BlockingQueue&lt;Runnable&gt; <span class=\"title\">createWorkQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>createTask的方法根据自己的实际需要进行修改。</code></p>\n<p>得到类似如下结果 ：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number <span class=\"keyword\">of</span> CPU: <span class=\"number\">4</span></span><br><span class=\"line\">Target utilization: <span class=\"number\">1</span></span><br><span class=\"line\">Elapsed <span class=\"built_in\">time</span> (nanos): <span class=\"number\">3000000000</span></span><br><span class=\"line\">Compute <span class=\"built_in\">time</span> (nanos): <span class=\"number\">2017495000</span></span><br><span class=\"line\">Wait <span class=\"built_in\">time</span> (nanos): <span class=\"number\">982505000</span></span><br><span class=\"line\">Formula: <span class=\"number\">4</span> * <span class=\"number\">1</span> * (<span class=\"number\">1</span> + <span class=\"number\">982505000</span> / <span class=\"number\">2017495000</span>)</span><br><span class=\"line\">* Optimal thread <span class=\"built_in\">count</span>: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>由此可知，在上述场景中，创建4个线程比较合适。</p>\n","excerpt":"","more":"<p>线程是程序执行流的最小单元，多线程程序在较低层次上扩展了多任务的概念：一个程序同时执行多个任务。通常每一个任务称为一个线程(thread)，它是线程控制的简称。可以同时运行一个以上线程的程序称为多线程程序(multithreaded)。</p>\n<h1 id=\"线程的状态\"><a href=\"#线程的状态\" class=\"headerlink\" title=\"线程的状态\"></a>线程的状态</h1><p>Java的线程如下有6种状态：<br>NEW（新建）<br>RUNNABLE（就绪，可运行）<br>BLOCKED（被阻塞）<br>WAITING（等待）<br>TIMED_WAITING（计时等待）<br>TERMINATED（被终止）</p>\n<p>可以使用Thread.getState()方法获取线程的当前状态。在Thread类中线程状态由一个整型变量threadStatus表示，getState()方法调用VM类的toThreadState()方法，根据threadStatus某个位置上是否为1来判断线程状态，代码如下：</p>\n<figure class=\"highlight erlang-repl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(var0 &amp; <span class=\"number\">4</span>) != <span class=\"number\">0</span>?State.RUNNABLE:((var0 &amp; <span class=\"number\">1024</span>) != <span class=\"number\">0</span>?State.BLOCKED:((var0 &amp; <span class=\"number\">16</span>) != <span class=\"number\">0</span>?State.WAITING:((var0 &amp; <span class=\"number\">32</span>) != <span class=\"number\">0</span>?State.TIMED_WAITING:((var0 &amp; <span class=\"number\">2</span>) != <span class=\"number\">0</span>?State.TERMINATED:((var0 &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>?State.NEW:State.RUNNABLE)))));</span><br></pre></td></tr></table></figure>\n<h2 id=\"NEW\"><a href=\"#NEW\" class=\"headerlink\" title=\"NEW\"></a>NEW</h2><p>当用new操作符创建一个新线程时，如new Thread()，该线程还没有运行，此时线程状态是NEW。</p>\n<h2 id=\"RUNNABLE\"><a href=\"#RUNNABLE\" class=\"headerlink\" title=\"RUNNABLE\"></a>RUNNABLE</h2><p>一旦调用start()方法，线程处于RUNNABLE状态。<br><code>一个RUNNABLE状态的线程可能正在运行也可能没有运行，这取决于操作系统给线程提供运行的时间</code>。</p>\n<h2 id=\"BLOCKED\"><a href=\"#BLOCKED\" class=\"headerlink\" title=\"BLOCKED\"></a>BLOCKED</h2><p>当一个线程试图获取一个内部对象锁，而该锁被其他线程持有，则该线程进入BLOCKED状态。</p>\n<h2 id=\"WAITING\"><a href=\"#WAITING\" class=\"headerlink\" title=\"WAITING\"></a>WAITING</h2><p>当一个线程等待另一个线程通知调度器一个条件时，进入WAITING状态，如调用：Object.wait(), Thread.join(), Lock.lock(), Condition.await()时。</p>\n<h2 id=\"TIMED-WAITING\"><a href=\"#TIMED-WAITING\" class=\"headerlink\" title=\"TIMED_WAITING\"></a>TIMED_WAITING</h2><p>有几个方法有超时参数，调用它们将导致线程进入TIMED_WAITING状态，如调用：Thread.sleep(long millis), Object.wait(long timeout), Lock.tryLock(), Condition.await(long time, TimeUnit unit)时。</p>\n<h2 id=\"TERMINATED\"><a href=\"#TERMINATED\" class=\"headerlink\" title=\"TERMINATED\"></a>TERMINATED</h2><ul>\n<li>因为run方法正常退出而自然终止。</li>\n<li>因为一个没有捕获的异常而终止。</li>\n</ul>\n<p><code>stop()、suspend()、resume()已过时，不要使用。</code></p>\n<h1 id=\"线程属性\"><a href=\"#线程属性\" class=\"headerlink\" title=\"线程属性\"></a>线程属性</h1><p>线程属性包括：线程优先级、守护线程、线程组以及处理未捕获异常的处理器。</p>\n<h2 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h2><p>在Java中每一个线程都有一个优先级，使用setPriority()方法可以设置线程的优先级，可以将优先级置为在MIN_PRIORITY(在Thread类中定义为0)和MAX_PRIORITY（在Thread类中定义为10）之间的任何值。NORM_PRIORITY被定义为5。</p>\n<p><code>注意：线程优先级高度依赖于系统，Windows有7个优先级，Sun为Linux提供的Java虚拟机，线程的优先级被忽略——所有的线程具有相同的优先级。</code></p>\n<h2 id=\"守护线程\"><a href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"></a>守护线程</h2><p>通过调用方法setDaemon(true)来将线程设置为守护线程，守护线程的唯一作用是为其他线程提供服务。当只剩下守护线程时，虚拟机就退出了，所以守护线程中永远不应该去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。</p>\n<h2 id=\"未捕获异常处理器\"><a href=\"#未捕获异常处理器\" class=\"headerlink\" title=\"未捕获异常处理器\"></a>未捕获异常处理器</h2><p>该处理器必须实现Thead.UncaughtExceptionHandler接口，该接口只有一个方法：void uncaughtException(Thread t, Throwable e)。<br>使用setUncaughtExceptionHandler()方法为线程安装一个处理器，也可以使用静态方法Thread.setUncaughtExceptionHandler()为所有线程安装一个默认的处理器。</p>\n<h1 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h1><p>创建线程有三种方法：</p>\n<ul>\n<li>继承Thread类</li>\n<li>实现Runnable接口</li>\n<li>实现Callable接口</li>\n</ul>\n<h2 id=\"继承Thread类\"><a href=\"#继承Thread类\" class=\"headerlink\" title=\"继承Thread类\"></a>继承Thread类</h2><p>步骤如下</p>\n<ol>\n<li>继承Thread类，重写run方法</li>\n<li>创建线程对象</li>\n<li>执行start方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtendsThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">            System.out.println(getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> </span>&#123;</span><br><span class=\"line\">        ExtendsThread subThread1 = <span class=\"keyword\">new</span> ExtendsThread();</span><br><span class=\"line\">        subThread1.setName(<span class=\"string\">\"subThread1\"</span>);</span><br><span class=\"line\">        ExtendsThread subThread2 = <span class=\"keyword\">new</span> ExtendsThread();</span><br><span class=\"line\">        subThread2.setName(<span class=\"string\">\"subThread2\"</span>);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果(不固定)：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span></span><br></pre></td></tr></table></figure>\n<p><code>注意：不要调用Thread类或Runnable对象的run方法，直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。应该调用Thread.start方法，这个方法将创建一个执行run方法的新线程。</code></p>\n<h2 id=\"实现Runnable接口\"><a href=\"#实现Runnable接口\" class=\"headerlink\" title=\"实现Runnable接口\"></a>实现Runnable接口</h2><ol>\n<li>创建Runnable的实现类，重写run方法</li>\n<li>创建该Runnable实现类的对象，并以该对象为参数创建Thread实例</li>\n<li>执行start方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplRunnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span></span>&#123;</span><br><span class=\"line\">        MyRunnable myRunnable = <span class=\"keyword\">new</span> MyRunnable();</span><br><span class=\"line\">        Thread subThread1 = <span class=\"keyword\">new</span> Thread(myRunnable, <span class=\"string\">\"subThread1\"</span>);</span><br><span class=\"line\">        Thread subThread2 = <span class=\"keyword\">new</span> Thread(myRunnable, <span class=\"string\">\"subThread2\"</span>);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyRunnable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span></span>&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span><br><span class=\"line\"></span><span class=\"keyword\">subThread2</span><br><span class=\"line\"></span><span class=\"keyword\">subThread1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实现Callable接口\"><a href=\"#实现Callable接口\" class=\"headerlink\" title=\"实现Callable接口\"></a>实现Callable接口</h2><ol>\n<li>创建Callable的实现类，重写call()方法</li>\n<li>创建该Callable实现类的对象，并以该对象为参数创建FutureTask对象</li>\n<li>以该FutureTask对象为参数，创建Thread实例</li>\n<li>执行start方法，并可调用FutureTask对象的方法获取线程执行的状态及返回结果。</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplCallable</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class=\"line\">        MyCallable myCallable1 = <span class=\"keyword\">new</span> MyCallable(<span class=\"number\">10</span>);</span><br><span class=\"line\">        MyCallable myCallable2 = <span class=\"keyword\">new</span> MyCallable(<span class=\"number\">20</span>);</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask1 = <span class=\"keyword\">new</span> FutureTask(myCallable1);</span><br><span class=\"line\">        FutureTask&lt;Integer&gt; futureTask2 = <span class=\"keyword\">new</span> FutureTask(myCallable2);</span><br><span class=\"line\">        Thread subThread1 = <span class=\"keyword\">new</span> Thread(futureTask1);</span><br><span class=\"line\">        Thread subThread2 = <span class=\"keyword\">new</span> Thread(futureTask2);</span><br><span class=\"line\">        subThread1.start();</span><br><span class=\"line\">        subThread2.start();</span><br><span class=\"line\">        System.out.println(futureTask1.get());</span><br><span class=\"line\">        System.out.println(futureTask2.get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCallable</span> <span class=\"keyword\">implements</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">Integer</span>&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> num;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyCallable</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getNum</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNum</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.num = num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; num; i++) &#123;</span><br><span class=\"line\">                System.out.println(Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-8</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"keyword\">Thread</span><span class=\"number\">-9</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"三种方式的比较\"><a href=\"#三种方式的比较\" class=\"headerlink\" title=\"三种方式的比较\"></a>三种方式的比较</h2><ol>\n<li>Java中没有多重继承，因此在使用继承Thread类的方式创建线程时，不能再继承其他类；使用Runnable、Callable接口创建多线程时，还可以继承其他类，在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况； </li>\n<li>使用Callable接口可以从线程中获取返回值。</li>\n</ol>\n<h1 id=\"线程同步\"><a href=\"#线程同步\" class=\"headerlink\" title=\"线程同步\"></a>线程同步</h1><h2 id=\"synchronized关键字\"><a href=\"#synchronized关键字\" class=\"headerlink\" title=\"synchronized关键字\"></a>synchronized关键字</h2><p>从1.0版本开始，Java中的每一个对象都有一个内部锁，如果一个方法使用synchronized关键字声明，线程将获得对象的内部锁。<br>synchronized有两种方式：锁方法、锁对象。</p>\n<ol>\n<li>锁方法，即用synchronized关键字修饰方法：</li>\n</ol>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得的是对象的内部锁</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> synchronized void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\tmethod body</span><br><span class=\"line\">&#125;</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获得的是类锁，由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>()&#123;</span><br><span class=\"line\">\tmethod <span class=\"keyword\">body</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>锁对象：</li>\n</ol>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是对象的内部锁</span><br><span class=\"line\">\tsynchronized(this)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object obj = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是obj的内部锁</span><br><span class=\"line\">\tsynchronized(obj)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span></span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是类锁</span><br><span class=\"line\">\tsynchronized(xxx.class)&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> void <span class=\"function\"><span class=\"keyword\">method</span><span class=\"params\">()</span><span class=\"comment\">&#123;</span><br><span class=\"line\">\t// 获得的是类锁</span><br><span class=\"line\">\tsynchronized(Class.forName(\"xxx\"))&#123;</span><br><span class=\"line\">\t\tcode block</span><br><span class=\"line\">\t&#125;</span>\t</span><br><span class=\"line\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h2><p>Lock(锁对象)允许把锁的实现作为Java类，而不是作为语言的特性来实现，这就为Lock的多种实现留下了空间，各种实现可能有不同的调度算法、性能特性或者锁定语义。</p>\n<h3 id=\"方法摘要\"><a href=\"#方法摘要\" class=\"headerlink\" title=\"方法摘要\"></a>方法摘要</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td>lock()</td>\n<td>获取锁。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>lockInterruptibly()</td>\n<td>如果当前线程未被中断，则获取锁。</td>\n</tr>\n<tr>\n<td>Condition</td>\n<td>newCondition()</td>\n<td>返回绑定到此 Lock 实例的新 Condition 实例。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>tryLock()</td>\n<td>仅在调用时锁为空闲状态才获取该锁。</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td>tryLock(long time, TimeUnit unit)</td>\n<td>如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</td>\n</tr>\n<tr>\n<td>void</td>\n<td>unlock()</td>\n<td>释放锁。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h3><p>ReentrantLock类是Lock的一个实现，使用ReentrantLock的代码块结构如下：</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myLock<span class=\"selector-class\">.lock</span>();</span><br><span class=\"line\"><span class=\"selector-tag\">try</span>&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">&#125; <span class=\"selector-tag\">finally</span> &#123;</span><br><span class=\"line\">\tmyLock<span class=\"selector-class\">.unlock</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ReentrantLock(true)可以构造一个带有公平策略的锁，听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。</code></p>\n<h2 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h2><p>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。<br>与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程），读-写锁利用了这一点。从理论上讲，与互斥锁相比，使用读-写锁所允许的并发性增强将带来更大的性能提高。在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。</p>\n<h3 id=\"方法摘要-1\"><a href=\"#方法摘要-1\" class=\"headerlink\" title=\"方法摘要\"></a>方法摘要</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th>方法</th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Lock</td>\n<td>readLock()</td>\n<td>返回用于读取操作的锁。</td>\n</tr>\n<tr>\n<td>Lock</td>\n<td>writeLock()</td>\n<td>返回用于写入操作的锁。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"ReentrantReadWriteLock\"><a href=\"#ReentrantReadWriteLock\" class=\"headerlink\" title=\"ReentrantReadWriteLock\"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是ReadWriteLock的实现类，其使用方式如下：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReentrantReadWriteLock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\"><span class=\"keyword\">lock</span>.readLock().<span class=\"keyword\">lock</span>();\t\t<span class=\"comment\">// 获得读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.readLock().unLock();\t<span class=\"comment\">// 释放读锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.writeLock().<span class=\"keyword\">lock</span>();\t<span class=\"comment\">// 获得写锁</span></span><br><span class=\"line\"><span class=\"keyword\">lock</span>.writeLock().unLock();\t<span class=\"comment\">// 释放写锁</span></span><br></pre></td></tr></table></figure>\n<p>下面来看一个实际的例子，使用读写锁来实现查询、存钱、取钱：<br>例：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ReadWriteLockStudy</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> ReadWriteLock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantReadWriteLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock readLock = <span class=\"keyword\">lock</span>.readLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock writeLock = <span class=\"keyword\">lock</span>.writeLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            readLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得readLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"显示余额:\"</span> + balance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                readLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放readLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            writeLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                balance += money;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            writeLock.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (balance &lt; money)</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    balance -= money;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                writeLock.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放writeLock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">ShowThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ShowThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                account.show();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">        PutThread putThread = <span class=\"keyword\">new</span> PutThread(account);</span><br><span class=\"line\">        putThread.setName(<span class=\"string\">\"putThread\"</span>);</span><br><span class=\"line\">        TakeThread takeThread = <span class=\"keyword\">new</span> TakeThread(account);</span><br><span class=\"line\">        takeThread.setName(<span class=\"string\">\"takeThread\"</span>);</span><br><span class=\"line\">        ShowThread showThread1 = <span class=\"keyword\">new</span> ShowThread(account);</span><br><span class=\"line\">        showThread1.setName(<span class=\"string\">\"showThread1\"</span>);</span><br><span class=\"line\">        ShowThread showThread2 = <span class=\"keyword\">new</span> ShowThread(account);</span><br><span class=\"line\">        showThread2.setName(<span class=\"string\">\"showThread2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        putThread.start();</span><br><span class=\"line\">        takeThread.start();</span><br><span class=\"line\">        showThread1.start();</span><br><span class=\"line\">        showThread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得writeLock <span class=\"comment\">-- putThread</span></span><br><span class=\"line\">存入:<span class=\"number\">46</span>,余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放writeLock <span class=\"comment\">-- putThread</span></span><br><span class=\"line\">获得writeLock <span class=\"comment\">-- takeThread</span></span><br><span class=\"line\">余额不足, 需取: <span class=\"number\">95</span>; 余额: <span class=\"number\">46</span></span><br><span class=\"line\">释放writeLock <span class=\"comment\">-- takeThread</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread2</span></span><br><span class=\"line\">获得readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">显示余额:<span class=\"number\">46</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread1</span></span><br><span class=\"line\">释放readLock <span class=\"comment\">-- showThread2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到读-读不互斥，读-写互斥，写-写互斥。</p>\n<h3 id=\"Condition\"><a href=\"#Condition\" class=\"headerlink\" title=\"Condition\"></a>Condition</h3><p>条件（也称为条件队列 或条件变量）为线程提供了一个含义，以便在某个状态条件现在可能为 true 的另一个线程通知它之前，一直挂起该线程（即让其“等待”）。因为访问此共享状态信息发生在不同的线程中，所以它必须受保护，因此要将某种形式的锁与该条件相关联。等待提供一个条件的主要属性是：以原子方式 释放相关的锁，并挂起当前线程，就像 Object.wait 做的那样。<br>Condition可以替代传统的线程间通信，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()。<br><code>不直接使用wait(), notify(), notifyAll()是因为 这几个方法是final方法。</code><br>可以为多个线程间建立不同的Condition。</p>\n<p>将上面的例子修改一下，增加两个功能：</p>\n<ol>\n<li>当余额少于100时，马上存入100；</li>\n<li>当余额大于200时，马上取出100；</li>\n</ol>\n<p>代码如下：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">ConditionStudy</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Lock <span class=\"keyword\">lock</span> = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Condition condition100 = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Condition condition200 = <span class=\"keyword\">lock</span>.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                balance += money;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                condition200.signal();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span>(<span class=\"params\"><span class=\"keyword\">long</span> money</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (balance &lt; money)</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    balance -= money;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出:\"</span> + money + <span class=\"string\">\",余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition100.signal();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put100</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (balance &gt;= <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额大于等于100, 等待, 释放锁\"</span> + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition100.await();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                balance += <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"存入100, 余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take100</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">lock</span>.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span> (balance &lt; <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"余额小于200, 等待, 释放锁\"</span> + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                    condition200.await();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                balance -= <span class=\"number\">100</span>;</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"取出100, 余额:\"</span> + balance + <span class=\"string\">\" -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">lock</span>.unlock();</span><br><span class=\"line\">                System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"释放lock -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i++ &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take(money);</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Put100Thread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Put100Thread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.put100();</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Take100Thread</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Take100Thread</span>(<span class=\"params\">Account account</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    account.take100();</span><br><span class=\"line\">                    sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">        PutThread putThread = <span class=\"keyword\">new</span> PutThread(account);</span><br><span class=\"line\">        putThread.setName(<span class=\"string\">\"putThread\"</span>);</span><br><span class=\"line\">        TakeThread takeThread = <span class=\"keyword\">new</span> TakeThread(account);</span><br><span class=\"line\">        takeThread.setName(<span class=\"string\">\"takeThread\"</span>);</span><br><span class=\"line\">        Put100Thread put100Thread = <span class=\"keyword\">new</span> Put100Thread(account);</span><br><span class=\"line\">        put100Thread.setName(<span class=\"string\">\"put100Thread\"</span>);</span><br><span class=\"line\">        Take100Thread take100Thread = <span class=\"keyword\">new</span> Take100Thread(account);</span><br><span class=\"line\">        take100Thread.setName(<span class=\"string\">\"take100Thread\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        putThread.start();</span><br><span class=\"line\">        takeThread.start();</span><br><span class=\"line\">        put100Thread.start();</span><br><span class=\"line\">        take100Thread.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>volatile可以保证每次都从主内存中读取数据，且每次数据修改都写回主内存。如果一个变量声明为volatile，那么编译器和虚拟机就知道该域是可能被另一个线程并发更新的。</p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是指多个线程相互等待它方占有的资源而导致的每个线程都无法执行下去的情况。<br>下面是一个简单的死锁例子：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">MemStore</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        Lock lock1 = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">        Lock lock2 = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            lock1.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock1 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                lock2.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock2 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock2.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock1.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">method2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            lock2.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">            System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock2 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">                lock1.<span class=\"keyword\">lock</span>();</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"获得lock1 -- \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    lock1.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                lock2.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Thread1</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MemStore memStore;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread1</span>(<span class=\"params\">MemStore memStore</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.memStore = memStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            memStore.method1();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title\">Thread2</span> <span class=\"title\">extends</span> <span class=\"title\">Thread</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> MemStore memStore;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Thread2</span>(<span class=\"params\">MemStore memStore</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.memStore = memStore;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        @<span class=\"function\">Override</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            memStore.method2();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span>(<span class=\"params\">String args[]</span>) </span>&#123;</span><br><span class=\"line\">        MemStore memStore = <span class=\"keyword\">new</span> MemStore();</span><br><span class=\"line\">        Thread1 thread1 = <span class=\"keyword\">new</span> Thread1(memStore);</span><br><span class=\"line\">        thread1.setName(<span class=\"string\">\"thread1\"</span>);</span><br><span class=\"line\">        Thread2 thread2 = <span class=\"keyword\">new</span> Thread2(memStore);</span><br><span class=\"line\">        thread2.setName(<span class=\"string\">\"thread2\"</span>);</span><br><span class=\"line\">        thread1.start();</span><br><span class=\"line\">        thread2.start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">获得lock1 <span class=\"comment\">-- thread1</span></span><br><span class=\"line\">获得lock2 <span class=\"comment\">-- thread2</span></span><br></pre></td></tr></table></figure>\n<p>可以看到thread1获得了lock1，等待获得lock2，而thread2获得了lock2，等待获得lock1，从而死锁。</p>\n<h1 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h1><p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。</p>\n<h2 id=\"线程池原理\"><a href=\"#线程池原理\" class=\"headerlink\" title=\"线程池原理\"></a>线程池原理</h2><p>假设一个服务器完成一项任务所需时间为：T1 创建线程时间，T2 在线程中执行任务的时间，T3 销毁线程时间。如果：T1 + T3 远大于 T2，则可以采用线程池，以提高服务器性能。</p>\n<p>一个线程池包括以下四个基本组成部分：</p>\n<ol>\n<li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括 创建线程池，销毁线程池，添加新任务；</li>\n<li>工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；</li>\n<li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行完后的收尾工作，任务的执行状态等；</li>\n<li>任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓冲机制。</li>\n</ol>\n<p>线程池技术正是关注如何缩短或调整T1,T3时间的技术，从而提高服务器程序性能的。它把T1，T3分别安排在服务器程序的启动和结束的时间段或者一些空闲的时间段，这样在服务器程序处理客户请求时，不会有T1，T3的开销了。</p>\n<h2 id=\"简单线程池的实现\"><a href=\"#简单线程池的实现\" class=\"headerlink\" title=\"简单线程池的实现\"></a>简单线程池的实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleThreadPool</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 线程数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threadNum = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 工作线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WorkThread[] workThreads;</span><br><span class=\"line\">    <span class=\"comment\">// 任务队列, 待执行的线程</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleThreadPool</span><span class=\"params\">(<span class=\"keyword\">int</span> threadNum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (threadNum &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.threadNum = threadNum;</span><br><span class=\"line\">        <span class=\"comment\">// 初始化任务队列</span></span><br><span class=\"line\">        taskQueue = <span class=\"keyword\">new</span> LinkedBlockingDeque&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 初始化工作线程</span></span><br><span class=\"line\">        workThreads = <span class=\"keyword\">new</span> WorkThread[<span class=\"keyword\">this</span>.threadNum];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; threadNum) &#123;</span><br><span class=\"line\">            workThreads[i] = <span class=\"keyword\">new</span> WorkThread();</span><br><span class=\"line\">            workThreads[i].setName(<span class=\"string\">\"workThread-\"</span> + i);</span><br><span class=\"line\">            <span class=\"comment\">// 启动工作线程</span></span><br><span class=\"line\">            workThreads[i].start();</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">        taskQueue.add(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable[] runnableList)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Runnable runnable : runnableList)</span><br><span class=\"line\">            execute(runnable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(WorkThread workThread: workThreads)</span><br><span class=\"line\">            workThread.stopRun();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">boolean</span> runFlag = <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (runFlag)</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Runnable task = taskQueue.take();</span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">stopRun</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            runFlag = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Task</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Task</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            System.out.println(name + <span class=\"string\">\" run.\"</span> + <span class=\"string\">\"current thread: \"</span> + Thread.currentThread().getName());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        SimpleThreadPool simpleThreadPool = <span class=\"keyword\">new</span> SimpleThreadPool(<span class=\"number\">3</span>);</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task0\"</span>));</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Runnable[]&#123;<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task1\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task2\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task3\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task4\"</span>)&#125;);</span><br><span class=\"line\">        simpleThreadPool.execute(<span class=\"keyword\">new</span> Runnable[]&#123;<span class=\"keyword\">new</span> Task(<span class=\"string\">\"task4\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task5\"</span>), <span class=\"keyword\">new</span> Task(<span class=\"string\">\"task6\"</span>)&#125;);</span><br><span class=\"line\">        Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">        simpleThreadPool.destroy();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果（不固定）：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">task0 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task2 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br><span class=\"line\">task1 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">1</span></span><br><span class=\"line\">task3 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task4 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br><span class=\"line\">task4 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">1</span></span><br><span class=\"line\">task5 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">0</span></span><br><span class=\"line\">task6 run<span class=\"selector-class\">.current</span> thread: workThread-<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"concurrent包\"><a href=\"#concurrent包\" class=\"headerlink\" title=\"concurrent包\"></a>concurrent包</h1><p>java.util.concurrent包是在并发编程中很常用的实用工具包。此包包括了几个小的、已标准化的可扩展框架，以及一些提供有用功能的类，没有这些类，这些功能会很难实现或实现起来冗长乏味。下面简要描述主要的组件。</p>\n<h2 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h2><p>接口。Executor是一个简单的标准化接口，用于定义类似于线程的自定义子系统，包括线程池、异步IO和轻量级任务框架。根据所使用的具体Executor类的不同，可能在新创建的线程中，现有的任务执行线程中，或者调用execute()的线程中执行任务，并且可能顺序或并发执行。ExecutorService 提供了多个完整的异步任务执行框架。ExecutorService 管理任务的排队和安排，并允许受控制的关闭。ScheduledExecutorService 子接口及相关的接口添加了对延迟的和定期任务执行的支持。ExecutorService 提供了安排异步执行的方法，可执行由 Callable 表示的任何函数，结果类似于 Runnable。Future 返回函数的结果，允许确定执行是否完成，并提供取消执行的方法。RunnableFuture 是拥有 run 方法的 Future，run 方法执行时将设置其结果。</p>\n<p>实现。类 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 提供可调的、灵活的线程池。Executors 类提供大多数 Executor 的常见类型和配置的工厂方法，以及使用它们的几种实用工具方法。其他基于 Executor 的实用工具包括具体类 FutureTask，它提供 Future 的常见可扩展实现，以及 ExecutorCompletionService，它有助于协调对异步任务组的处理。</p>\n<h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><p>java.util.concurrent.ConcurrentLinkedQueue类提供了高效的、可伸缩的、线程安全的非阻塞 FIFO 队列。java.util.concurrent 中的五个实现都支持扩展的 BlockingQueue 接口，该接口定义了 put 和 take 的阻塞版本：LinkedBlockingQueue、ArrayBlockingQueue、SynchronousQueue、PriorityBlockingQueue 和 DelayQueue。这些不同的类覆盖了生产者-使用者、消息传递、并行任务执行和相关并发设计的大多数常见使用的上下文。BlockingDeque 接口扩展 BlockingQueue，以支持 FIFO 和 LIFO（基于堆栈）操作。LinkedBlockingDeque 类提供一个实现。</p>\n<h2 id=\"计时\"><a href=\"#计时\" class=\"headerlink\" title=\"计时\"></a>计时</h2><p>TimeUnit 类为指定和控制基于超时的操作提供了多重粒度（包括纳秒级）。该包中的大多数类除了包含不确定的等待之外，还包含基于超时的操作。在使用超时的所有情况中，超时指定了在表明已超时前该方法应该等待的最少时间。在超时发生后，实现会“尽力”检测超时。但是，在检测超时与超时之后再次实际执行线程之间可能要经过不确定的时间。接受超时期参数的所有方法将小于等于 0 的值视为根本不会等待。要“永远”等待，可以使用 Long.MAX_VALUE 值。</p>\n<h2 id=\"同步器\"><a href=\"#同步器\" class=\"headerlink\" title=\"同步器\"></a>同步器</h2><p>四个类可协助实现常见的专用同步语句。Semaphore 是一个经典的并发工具。CountDownLatch 是一个极其简单但又极其常用的实用工具，用于在保持给定数目的信号、事件或条件前阻塞执行。CyclicBarrier 是一个可重置的多路同步点，在某些并行编程风格中很有用。Exchanger 允许两个线程在 collection 点交换对象，它在多流水线设计中是有用的。</p>\n<h2 id=\"并发-Collection\"><a href=\"#并发-Collection\" class=\"headerlink\" title=\"并发 Collection\"></a>并发 Collection</h2><p>除队列外，此包还提供了设计用于多线程上下文中的 Collection 实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。<br>此包中与某些类一起使用的“Concurrent&amp;rdquo前缀;是一种简写，表明与类似的“同步”类有所不同。例如，java.util.Hashtable 和 Collections.synchronizedMap(new HashMap()) 是同步的，但 ConcurrentHashMap 则是“并发的”。并发 collection 是线程安全的，但是不受单个排他锁的管理。在 ConcurrentHashMap 这一特定情况下，它可以安全地允许进行任意数目的并发读取，以及数目可调的并发写入。需要通过单个锁不允许对 collection 的所有访问时，“同步”类是很有用的，其代价是较差的可伸缩性。在期望多个线程访问公共 collection 的其他情况中，通常“并发”版本要更好一些。当 collection 是未共享的，或者仅保持其他锁时 collection 是可访问的情况下，非同步 collection 则要更好一些。</p>\n<p>大多数并发 Collection 实现（包括大多数 Queue）与常规的 java.util 约定也不同，因为它们的迭代器提供了弱一致的，而不是快速失败的遍历。弱一致的迭代器是线程安全的，但是在迭代时没有必要冻结 collection，所以它不一定反映自迭代器创建以来的所有更新。</p>\n<h2 id=\"内存一致性属性\"><a href=\"#内存一致性属性\" class=\"headerlink\" title=\"内存一致性属性\"></a>内存一致性属性</h2><p>只有写入操作 happen-before 读取操作时，才保证一个线程写入的结果对另一个线程的读取是可视的。synchronized 和 volatile 构造 happen-before 关系，Thread.start() 和 Thread.join() 方法形成 happen-before 关系。尤其是：<br>线程中的每个操作 happen-before 稍后按程序顺序传入的该线程中的每个操作。<br>一个解除锁监视器的（synchronized 阻塞或方法退出）happen-before 相同监视器的每个后续锁（synchronized 阻塞或方法进入）。并且因为 happen-before 关系是可传递的，所以解除锁定之前的线程的所有操作 happen-before 锁定该监视器的任何线程后续的所有操作。<br>写入 volatile 字段 happen-before 每个后续读取相同字段。volatile 字段的读取和写入与进入和退出监视器具有相似的内存一致性效果，但不 需要互斥锁。<br>在线程上调用 start happen-before 已启动的线程中的任何线程。<br>线程中的所有操作 happen-before 从该线程上的 join 成功返回的任何其他线程。<br>java.util.concurrent 中所有类的方法及其子包扩展了这些对更高级别同步的保证。尤其是：<br>线程中将一个对象放入任何并发 collection 之前的操作 happen-before 从另一线程中的 collection 访问或移除该元素的后续操作。<br>线程中向 Executor 提交 Runnable 之前的操作 happen-before 其执行开始。同样适用于向 ExecutorService 提交 Callables。<br>异步计算（由 Future 表示）所采取的操作 happen-before 通过另一线程中 Future.get() 获取结果后续的操作。<br>“释放”同步储存方法（如 Lock.unlock、Semaphore.release 和 CountDownLatch.countDown）之前的操作 happen-before 另一线程中相同同步储存对象成功“获取”方法（如 Lock.lock、Semaphore.acquire、Condition.await 和 CountDownLatch.await）的后续操作。<br>对于通过 Exchanger 成功交换对象的每个线程对，每个线程中 exchange() 之前的操作 happen-before 另一线程中对应 exchange() 后续的操作。<br>调用 CyclicBarrier.await 之前的操作 happen-before 屏障操作所执行的操作，屏障操作所执行的操作 happen-before 从另一线程中对应 await 成功返回的后续操作。</p>\n<h1 id=\"关于线程个数\"><a href=\"#关于线程个数\" class=\"headerlink\" title=\"关于线程个数\"></a>关于线程个数</h1><p>我们的应用程序应该创建多少个线程会使得性能得到比较好的提升呢？以下代码可以计算一个合适的线程个数：</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">class</span> <span class=\"title\">PoolSizeCalculator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * The sample queue size to calculate the size of a single &#123;@link Runnable&#125; element.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">int</span> SAMPLE_QUEUE_SIZE = <span class=\"number\">1000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Accuracy of test run. It must finish within 20ms of the testTime otherwise we retry the test. This could be</span><br><span class=\"line\">     * configurable.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">int</span> EPSYLON = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Control variable for the CPU time investigation.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> boolean expired;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Time (millis) of the test run in the CPU time calculation.</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> final <span class=\"keyword\">long</span> testtime = <span class=\"number\">3000</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculates the boundaries of a thread pool for a given &#123;@link Runnable&#125;.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param targetUtilization    the desired utilization of the CPUs (0 &lt;= targetUtilization &lt;= 1)</span><br><span class=\"line\">     * @param targetQueueSizeBytes the desired maximum work queue size of the thread pool (bytes)</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateBoundaries</span>(<span class=\"params\">BigDecimal targetUtilization, BigDecimal targetQueueSizeBytes</span>) </span>&#123;</span><br><span class=\"line\">        calculateOptimalCapacity(targetQueueSizeBytes);</span><br><span class=\"line\">        Runnable task = createTask();</span><br><span class=\"line\">        start(task);</span><br><span class=\"line\">        start(task); <span class=\"comment\">// warm up phase</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> cputime = getCurrentThreadCPUTime();</span><br><span class=\"line\">        start(task); <span class=\"comment\">// test intervall</span></span><br><span class=\"line\">        cputime = getCurrentThreadCPUTime() - cputime;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> waittime = (testtime * <span class=\"number\">1000000</span>) - cputime;</span><br><span class=\"line\">        calculateOptimalThreadCount(cputime, waittime, targetUtilization);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateOptimalCapacity</span>(<span class=\"params\">BigDecimal targetQueueSizeBytes</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem = calculateMemoryUsage();</span><br><span class=\"line\">        BigDecimal queueCapacity = targetQueueSizeBytes.divide(<span class=\"keyword\">new</span> BigDecimal(mem), RoundingMode.HALF_UP);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Target queue memory usage (bytes): \"</span> + targetQueueSizeBytes);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"createTask() produced \"</span> + createTask().getClass().getName() + <span class=\"string\">\" which took \"</span> + mem</span><br><span class=\"line\">                + <span class=\"string\">\" bytes in a queue\"</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Formula: \"</span> + targetQueueSizeBytes + <span class=\"string\">\" / \"</span> + mem);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"* Recommended queue capacity (bytes): \"</span> + queueCapacity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Brian Goetz' optimal thread count formula, see 'Java Concurrency in Practice' (chapter 8.2)</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param cpu               cpu time consumed by considered task</span><br><span class=\"line\">     * @param wait              wait time of considered task</span><br><span class=\"line\">     * @param targetUtilization target utilization of the system</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">calculateOptimalThreadCount</span>(<span class=\"params\"><span class=\"keyword\">long</span> cpu, <span class=\"keyword\">long</span> wait, BigDecimal targetUtilization</span>) </span>&#123;</span><br><span class=\"line\">        BigDecimal waitTime = <span class=\"keyword\">new</span> BigDecimal(wait);</span><br><span class=\"line\">        BigDecimal computeTime = <span class=\"keyword\">new</span> BigDecimal(cpu);</span><br><span class=\"line\">        BigDecimal numberOfCPU = <span class=\"keyword\">new</span> BigDecimal(Runtime.getRuntime().availableProcessors());</span><br><span class=\"line\">        BigDecimal optimalthreadcount = numberOfCPU.multiply(targetUtilization).multiply(</span><br><span class=\"line\">                <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">1</span>).add(waitTime.divide(computeTime, RoundingMode.HALF_UP)));</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Number of CPU: \"</span> + numberOfCPU);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Target utilization: \"</span> + targetUtilization);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Elapsed time (nanos): \"</span> + (testtime * <span class=\"number\">1000000</span>));</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Compute time (nanos): \"</span> + cpu);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Wait time (nanos): \"</span> + wait);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"Formula: \"</span> + numberOfCPU + <span class=\"string\">\" * \"</span> + targetUtilization + <span class=\"string\">\" * (1 + \"</span> + waitTime + <span class=\"string\">\" / \"</span></span><br><span class=\"line\">                + computeTime + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\">        System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"* Optimal thread count: \"</span> + optimalthreadcount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Runs the &#123;@link Runnable&#125; over a period defined in &#123;@link #testtime&#125;. Based on Heinz Kabbutz' ideas</span><br><span class=\"line\">     * (http://www.javaspecialists.eu/archive/Issue124.html).</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param task the runnable under investigation</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span>(<span class=\"params\">Runnable task</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> runs = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++runs &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Test not accurate\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            expired = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            start = System.currentTimeMillis();</span><br><span class=\"line\">            Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\">            timer.schedule(<span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                    expired = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, testtime);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!expired) &#123;</span><br><span class=\"line\">                task.run();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            start = System.currentTimeMillis() - start;</span><br><span class=\"line\">            timer.cancel();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (Math.abs(start - testtime) &gt; EPSYLON);</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">3</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">collectGarbage</span>(<span class=\"params\"><span class=\"keyword\">int</span> times</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; times; i++) &#123;</span><br><span class=\"line\">            System.gc();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread.sleep(<span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculates the memory usage of a single element in a work queue. Based on Heinz Kabbutz' ideas</span><br><span class=\"line\">     * (http://www.javaspecialists.eu/archive/Issue029.html).</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return memory usage of a single &#123;@link Runnable&#125; element in the thread pools work queue</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">long</span> <span class=\"title\">calculateMemoryUsage</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        BlockingQueue&lt;Runnable&gt; queue = createWorkQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class=\"line\">            queue.add(createTask());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        queue = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">15</span>);</span><br><span class=\"line\">        mem0 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        queue = createWorkQueue();</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; SAMPLE_QUEUE_SIZE; i++) &#123;</span><br><span class=\"line\">            queue.add(createTask());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        collectGarbage(<span class=\"number\">15</span>);</span><br><span class=\"line\">        mem1 = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (mem1 - mem0) / SAMPLE_QUEUE_SIZE;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Create your runnable task here.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return an instance of your runnable task under investigation</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> Runnable <span class=\"title\">createTask</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Return an instance of the queue used in the thread pool.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return queue instance</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> BlockingQueue&lt;Runnable&gt; <span class=\"title\">createWorkQueue</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span><br><span class=\"line\">     * Calculate current cpu time. Various frameworks may be used here, depending on the operating system in use. (e.g.</span><br><span class=\"line\">     * http://www.hyperic.com/products/sigar). The more accurate the CPU time measurement, the more accurate the results</span><br><span class=\"line\">     * for thread count boundaries.</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @return current cpu time of current thread</span><br><span class=\"line\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">long</span> <span class=\"title\">getCurrentThreadCPUTime</span>(<span class=\"params\"></span>)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyPoolSizeCalculator</span> <span class=\"keyword\">extends</span> <span class=\"title\">PoolSizeCalculator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException,</span><br><span class=\"line\">            InstantiationException,</span><br><span class=\"line\">            IllegalAccessException,</span><br><span class=\"line\">            ClassNotFoundException </span>&#123;</span><br><span class=\"line\">        MyPoolSizeCalculator calculator = <span class=\"keyword\">new</span> MyPoolSizeCalculator();</span><br><span class=\"line\">        calculator.calculateBoundaries(<span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">1.0</span>),</span><br><span class=\"line\">                <span class=\"keyword\">new</span> BigDecimal(<span class=\"number\">100000</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">long</span> <span class=\"title\">getCurrentThreadCPUTime</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ManagementFactory.getThreadMXBean().getCurrentThreadCpuTime();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> Runnable <span class=\"title\">createTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++)</span><br><span class=\"line\">                    System.out.println(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> BlockingQueue&lt;Runnable&gt; <span class=\"title\">createWorkQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>createTask的方法根据自己的实际需要进行修改。</code></p>\n<p>得到类似如下结果 ：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number <span class=\"keyword\">of</span> CPU: <span class=\"number\">4</span></span><br><span class=\"line\">Target utilization: <span class=\"number\">1</span></span><br><span class=\"line\">Elapsed <span class=\"built_in\">time</span> (nanos): <span class=\"number\">3000000000</span></span><br><span class=\"line\">Compute <span class=\"built_in\">time</span> (nanos): <span class=\"number\">2017495000</span></span><br><span class=\"line\">Wait <span class=\"built_in\">time</span> (nanos): <span class=\"number\">982505000</span></span><br><span class=\"line\">Formula: <span class=\"number\">4</span> * <span class=\"number\">1</span> * (<span class=\"number\">1</span> + <span class=\"number\">982505000</span> / <span class=\"number\">2017495000</span>)</span><br><span class=\"line\">* Optimal thread <span class=\"built_in\">count</span>: <span class=\"number\">4</span></span><br></pre></td></tr></table></figure>\n<p>由此可知，在上述场景中，创建4个线程比较合适。</p>\n"},{"title":"NIO总结","date":"2016-04-19T07:48:43.000Z","toc":true,"_content":"","source":"_posts/java-core-nio.md","raw":"---\ntitle: NIO总结\ndate: 2016-04-19 15:48:43\ntoc: true\ntags:\n- Java\n- nio\ncategories:\n- Java基础\n\n---\n","slug":"java-core-nio","published":1,"updated":"2016-04-19T08:03:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cinb2xtn0000kbgv0du1cr6q1","content":"","excerpt":"","more":""},{"title":"Object类详解","date":"2016-04-14T07:18:01.000Z","toc":true,"_content":"\nObject类是Java中所有类的祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，Object类就被认为是这个类的超类。\n可以使用Object类型的变量引用任何类型的对象：\n`Object obj = new MyObject();`\n但是，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的转化：\n`MyObject mObj = (MyObject) obj;`\n在Java中只有基本类型不是对象，例如：数值、字符和布尔型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。\n\n# 方法\n## public Object();\nJava中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的祖先，Object类自然要反映出此特性，在源代码中，未给出Object类构造函数定义，但实际上，此构造函数是存存的。\n\n## private static native void registerNatives()；\n将本地函数向VM进行登记，将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。\n此方法由其后紧跟的静态代码调用：\n```\n    static {\n        registerNatives();\n    }\n```\n\n## public final native Class<?> getClass()；\ngetClass()是一个native方法，返回这个对象的运行时类对象，效果与Object.class相同。\n首先解释下\"类对象\"的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为\"类对象\"。\n\n## public native int hashCode()\nhashCode()是一个native方法，返回一个整形数值，表示该对象的哈希码值。\nhashCode()具有如下约定：\n1. 在Java应用程序执行期间，对于同一个对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的信息未做修改。在某一应用程序的一次执行到同一应用程序的另一次执行，该整形数值无需保持一致。\n2. 如果根据equals（object）方法，两个对象是相等的，则hashcode必须相同。\n3. 如果两个对象的hashcode相同，这两个对象不一定相等。\n\n`需要注意的是：为不相等的对象生成不同的hashcode可以提高哈希表的性能。`\n\n## public boolean equals(Object obj)\nequals()方法判断两个对象是否相等，在Object类中，equals表示的是同一个对象。\n代码如下：\n\n```\n    public boolean equals(Object obj) {\n        return (this == obj);\n    }\n```\n`注意：重写了equals方法后需要重写hashCode方法。`\n\n## protected native Object clone() throws CloneNotSupportedException\nclone()是一个native方法，其作用是创建并返回此对象的副本，返回的是一个引用，指向的是新clone出来的对象，此对象与原对象分别占用不同的堆空间。此方法执行的是对象的浅拷贝而不是深拷贝。\n\n`\n注意：\n1. 不可在子类中创建Object对象，并直接clone，原因如下：clone()方法是protected的，protected关键字的含义是：在同一个包内或者不同包的子类可以访问，当两个类不在同一个包中的时候，在子类内部且子类的引用才可以访问父类的protected成员；在子类内部，父类的引用并不能访问protected成员。\n例：\n\n```\nObject obj = new Object();\nObject cloneObj = obj.clone();\n```\n报错为：\"The method clone() from the type Object is not visible\"\n2. 使用clone()方法的子类需要实现Cloneable接口，否则会抛出异常：java.lang.CloneNotSupportedException\n例：\n```\npublic class CloneTest implements Cloneable{\n\n    public static void main(String args[]) throws CloneNotSupportedException {\n        CloneTest obj = new CloneTest();\n        CloneTest cloneObj = (CloneTest) obj.clone();\n    }\n\n}\n```\n`\n\n## public String toString()\ntoString()方法返回该对象的字符串表示。代码如下：\n\n```\n    public String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n\n## public final native void notify()\n唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。\n\n## public final native void notifyAll()\n唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个wait方法，在对象的监视器上等待。\n\n## public final native void wait(long timeout) throws InterruptedException\n在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。\n`timeout单位为毫秒。`\n\n## public final void wait(long timeout, int nanos) throws InterruptedException\n在其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。\n此方法类似于一个参数的wait方法，但它允许更好地控制 在放弃之前等待通过的时间量。用毫微秒度量的实际时间量可以通过以下公式计算出来：\n`1000000 * timeout + nanos`\n在其他所有方面，此方法执行的操作与带有一个参数的wait(long)方法相同，需要特别指出的是，wait(0,0)与wait(0)相同。\n\n## 简单的生产消费模型\n一段简单的存钱/取钱代码，用来体现一下wait/notify的作用。\n\n```\n\n    static class Account {\n        private long balance;\n\n        public synchronized void take(long money) throws InterruptedException {\n            while (balance < money) {\n                System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance);\n                wait();\n            }\n            balance -= money;\n            System.out.println(\"取出: \" + money + \"; 余额: \" + balance);\n        }\n\n        public synchronized void put(long money) throws InterruptedException {\n            balance += money;\n            System.out.println(\"存入: \" + money + \"; 余额: \" + balance);\n            notifyAll();\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    \n```\n\n## public final void wait() throws InterruptedException\n= wait(0)\n\n## protected void finalize() throws Throwable\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾加收器调用此方法。子类重写finalize方法，以配置系统资源或执行其他清除。\n\n# 参考资料\n[Java总结篇系列：java.lang.Object](http://www.cnblogs.com/lwbqqyumidi/p/3693015.html)\n\njdk api\n\n","source":"_posts/java-core-object.md","raw":"---\ntitle: Object类详解\ndate: 2016-04-14 15:18:01\ntoc: true\ntags:\n- Java\ncategories:\n- Java基础\n\n---\n\nObject类是Java中所有类的祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，Object类就被认为是这个类的超类。\n可以使用Object类型的变量引用任何类型的对象：\n`Object obj = new MyObject();`\n但是，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的转化：\n`MyObject mObj = (MyObject) obj;`\n在Java中只有基本类型不是对象，例如：数值、字符和布尔型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。\n\n# 方法\n## public Object();\nJava中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的祖先，Object类自然要反映出此特性，在源代码中，未给出Object类构造函数定义，但实际上，此构造函数是存存的。\n\n## private static native void registerNatives()；\n将本地函数向VM进行登记，将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。\n此方法由其后紧跟的静态代码调用：\n```\n    static {\n        registerNatives();\n    }\n```\n\n## public final native Class<?> getClass()；\ngetClass()是一个native方法，返回这个对象的运行时类对象，效果与Object.class相同。\n首先解释下\"类对象\"的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为\"类对象\"。\n\n## public native int hashCode()\nhashCode()是一个native方法，返回一个整形数值，表示该对象的哈希码值。\nhashCode()具有如下约定：\n1. 在Java应用程序执行期间，对于同一个对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的信息未做修改。在某一应用程序的一次执行到同一应用程序的另一次执行，该整形数值无需保持一致。\n2. 如果根据equals（object）方法，两个对象是相等的，则hashcode必须相同。\n3. 如果两个对象的hashcode相同，这两个对象不一定相等。\n\n`需要注意的是：为不相等的对象生成不同的hashcode可以提高哈希表的性能。`\n\n## public boolean equals(Object obj)\nequals()方法判断两个对象是否相等，在Object类中，equals表示的是同一个对象。\n代码如下：\n\n```\n    public boolean equals(Object obj) {\n        return (this == obj);\n    }\n```\n`注意：重写了equals方法后需要重写hashCode方法。`\n\n## protected native Object clone() throws CloneNotSupportedException\nclone()是一个native方法，其作用是创建并返回此对象的副本，返回的是一个引用，指向的是新clone出来的对象，此对象与原对象分别占用不同的堆空间。此方法执行的是对象的浅拷贝而不是深拷贝。\n\n`\n注意：\n1. 不可在子类中创建Object对象，并直接clone，原因如下：clone()方法是protected的，protected关键字的含义是：在同一个包内或者不同包的子类可以访问，当两个类不在同一个包中的时候，在子类内部且子类的引用才可以访问父类的protected成员；在子类内部，父类的引用并不能访问protected成员。\n例：\n\n```\nObject obj = new Object();\nObject cloneObj = obj.clone();\n```\n报错为：\"The method clone() from the type Object is not visible\"\n2. 使用clone()方法的子类需要实现Cloneable接口，否则会抛出异常：java.lang.CloneNotSupportedException\n例：\n```\npublic class CloneTest implements Cloneable{\n\n    public static void main(String args[]) throws CloneNotSupportedException {\n        CloneTest obj = new CloneTest();\n        CloneTest cloneObj = (CloneTest) obj.clone();\n    }\n\n}\n```\n`\n\n## public String toString()\ntoString()方法返回该对象的字符串表示。代码如下：\n\n```\n    public String toString() {\n        return getClass().getName() + \"@\" + Integer.toHexString(hashCode());\n    }\n```\n\n## public final native void notify()\n唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。\n\n## public final native void notifyAll()\n唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个wait方法，在对象的监视器上等待。\n\n## public final native void wait(long timeout) throws InterruptedException\n在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。\n`timeout单位为毫秒。`\n\n## public final void wait(long timeout, int nanos) throws InterruptedException\n在其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。\n此方法类似于一个参数的wait方法，但它允许更好地控制 在放弃之前等待通过的时间量。用毫微秒度量的实际时间量可以通过以下公式计算出来：\n`1000000 * timeout + nanos`\n在其他所有方面，此方法执行的操作与带有一个参数的wait(long)方法相同，需要特别指出的是，wait(0,0)与wait(0)相同。\n\n## 简单的生产消费模型\n一段简单的存钱/取钱代码，用来体现一下wait/notify的作用。\n\n```\n\n    static class Account {\n        private long balance;\n\n        public synchronized void take(long money) throws InterruptedException {\n            while (balance < money) {\n                System.out.println(\"余额不足, 需取: \" + money + \"; 余额: \" + balance);\n                wait();\n            }\n            balance -= money;\n            System.out.println(\"取出: \" + money + \"; 余额: \" + balance);\n        }\n\n        public synchronized void put(long money) throws InterruptedException {\n            balance += money;\n            System.out.println(\"存入: \" + money + \"; 余额: \" + balance);\n            notifyAll();\n        }\n    }\n\n    static class TakeThread extends Thread {\n        private Account account;\n\n        public TakeThread(Account account) {\n            this.account = account;\n        }\n\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.take(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class PutThread extends Thread {\n        private Account account;\n\n        public PutThread(Account account) {\n            this.account = account;\n        }\n\n        public void run() {\n            Random random = new Random();\n            while (true) {\n                int money = random.nextInt(100);\n                try {\n                    account.put(money);\n                    sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    \n```\n\n## public final void wait() throws InterruptedException\n= wait(0)\n\n## protected void finalize() throws Throwable\n当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾加收器调用此方法。子类重写finalize方法，以配置系统资源或执行其他清除。\n\n# 参考资料\n[Java总结篇系列：java.lang.Object](http://www.cnblogs.com/lwbqqyumidi/p/3693015.html)\n\njdk api\n\n","slug":"java-core-object","published":1,"updated":"2016-04-26T03:38:53.000Z","_id":"cinb2xtn4000mbgv0bdfp7nsi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Object类是Java中所有类的祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，Object类就被认为是这个类的超类。<br>可以使用Object类型的变量引用任何类型的对象：<br><code>Object obj = new MyObject();</code><br>但是，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的转化：<br><code>MyObject mObj = (MyObject) obj;</code><br>在Java中只有基本类型不是对象，例如：数值、字符和布尔型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"public-Object\"><a href=\"#public-Object\" class=\"headerlink\" title=\"public Object();\"></a>public Object();</h2><p>Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的祖先，Object类自然要反映出此特性，在源代码中，未给出Object类构造函数定义，但实际上，此构造函数是存存的。</p>\n<h2 id=\"private-static-native-void-registerNatives-；\"><a href=\"#private-static-native-void-registerNatives-；\" class=\"headerlink\" title=\"private static native void registerNatives()；\"></a>private static native void registerNatives()；</h2><p>将本地函数向VM进行登记，将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。<br>此方法由其后紧跟的静态代码调用：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    registerNatives();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"public-final-native-Class-lt-gt-getClass-；\"><a href=\"#public-final-native-Class-lt-gt-getClass-；\" class=\"headerlink\" title=\"public final native Class&lt;?&gt; getClass()；\"></a>public final native Class&lt;?&gt; getClass()；</h2><p>getClass()是一个native方法，返回这个对象的运行时类对象，效果与Object.class相同。<br>首先解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</p>\n<h2 id=\"public-native-int-hashCode\"><a href=\"#public-native-int-hashCode\" class=\"headerlink\" title=\"public native int hashCode()\"></a>public native int hashCode()</h2><p>hashCode()是一个native方法，返回一个整形数值，表示该对象的哈希码值。<br>hashCode()具有如下约定：</p>\n<ol>\n<li>在Java应用程序执行期间，对于同一个对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的信息未做修改。在某一应用程序的一次执行到同一应用程序的另一次执行，该整形数值无需保持一致。</li>\n<li>如果根据equals（object）方法，两个对象是相等的，则hashcode必须相同。</li>\n<li>如果两个对象的hashcode相同，这两个对象不一定相等。</li>\n</ol>\n<p><code>需要注意的是：为不相等的对象生成不同的hashcode可以提高哈希表的性能。</code></p>\n<h2 id=\"public-boolean-equals-Object-obj\"><a href=\"#public-boolean-equals-Object-obj\" class=\"headerlink\" title=\"public boolean equals(Object obj)\"></a>public boolean equals(Object obj)</h2><p>equals()方法判断两个对象是否相等，在Object类中，equals表示的是同一个对象。<br>代码如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>注意：重写了equals方法后需要重写hashCode方法。</code></p>\n<h2 id=\"protected-native-Object-clone-throws-CloneNotSupportedException\"><a href=\"#protected-native-Object-clone-throws-CloneNotSupportedException\" class=\"headerlink\" title=\"protected native Object clone() throws CloneNotSupportedException\"></a>protected native Object clone() throws CloneNotSupportedException</h2><p>clone()是一个native方法，其作用是创建并返回此对象的副本，返回的是一个引用，指向的是新clone出来的对象，此对象与原对象分别占用不同的堆空间。此方法执行的是对象的浅拷贝而不是深拷贝。</p>\n<p>`<br>注意：</p>\n<ol>\n<li>不可在子类中创建Object对象，并直接clone，原因如下：clone()方法是protected的，protected关键字的含义是：在同一个包内或者不同包的子类可以访问，当两个类不在同一个包中的时候，在子类内部且子类的引用才可以访问父类的protected成员；在子类内部，父类的引用并不能访问protected成员。<br>例：</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">Object</span> cloneObj = obj.clone();</span><br></pre></td></tr></table></figure>\n<p>报错为：”The method clone() from the type Object is not visible”</p>\n<ol>\n<li>使用clone()方法的子类需要实现Cloneable接口，否则会抛出异常：java.lang.CloneNotSupportedException<br>例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        CloneTest obj = <span class=\"keyword\">new</span> CloneTest();</span><br><span class=\"line\">        CloneTest cloneObj = (CloneTest) obj.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>`</p>\n<h2 id=\"public-String-toString\"><a href=\"#public-String-toString\" class=\"headerlink\" title=\"public String toString()\"></a>public String toString()</h2><p>toString()方法返回该对象的字符串表示。代码如下：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getName() + <span class=\"string\">\"@\"</span> + <span class=\"built_in\">Integer</span>.toHexString(hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"public-final-native-void-notify\"><a href=\"#public-final-native-void-notify\" class=\"headerlink\" title=\"public final native void notify()\"></a>public final native void notify()</h2><p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。</p>\n<h2 id=\"public-final-native-void-notifyAll\"><a href=\"#public-final-native-void-notifyAll\" class=\"headerlink\" title=\"public final native void notifyAll()\"></a>public final native void notifyAll()</h2><p>唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个wait方法，在对象的监视器上等待。</p>\n<h2 id=\"public-final-native-void-wait-long-timeout-throws-InterruptedException\"><a href=\"#public-final-native-void-wait-long-timeout-throws-InterruptedException\" class=\"headerlink\" title=\"public final native void wait(long timeout) throws InterruptedException\"></a>public final native void wait(long timeout) throws InterruptedException</h2><p>在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。<br><code>timeout单位为毫秒。</code></p>\n<h2 id=\"public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException\"><a href=\"#public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException\" class=\"headerlink\" title=\"public final void wait(long timeout, int nanos) throws InterruptedException\"></a>public final void wait(long timeout, int nanos) throws InterruptedException</h2><p>在其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>此方法类似于一个参数的wait方法，但它允许更好地控制 在放弃之前等待通过的时间量。用毫微秒度量的实际时间量可以通过以下公式计算出来：<br><code>1000000 * timeout + nanos</code><br>在其他所有方面，此方法执行的操作与带有一个参数的wait(long)方法相同，需要特别指出的是，wait(0,0)与wait(0)相同。</p>\n<h2 id=\"简单的生产消费模型\"><a href=\"#简单的生产消费模型\" class=\"headerlink\" title=\"简单的生产消费模型\"></a>简单的生产消费模型</h2><p>一段简单的存钱/取钱代码，用来体现一下wait/notify的作用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(<span class=\"keyword\">long</span> money)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (balance &lt; money) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">            wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        balance -= money;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"取出: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">long</span> money)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        balance += money;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"存入: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span><span class=\"params\">(Account account)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                account.take(money);</span><br><span class=\"line\">                sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span><span class=\"params\">(Account account)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                account.put(money);</span><br><span class=\"line\">                sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"public-final-void-wait-throws-InterruptedException\"><a href=\"#public-final-void-wait-throws-InterruptedException\" class=\"headerlink\" title=\"public final void wait() throws InterruptedException\"></a>public final void wait() throws InterruptedException</h2><p>= wait(0)</p>\n<h2 id=\"protected-void-finalize-throws-Throwable\"><a href=\"#protected-void-finalize-throws-Throwable\" class=\"headerlink\" title=\"protected void finalize() throws Throwable\"></a>protected void finalize() throws Throwable</h2><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾加收器调用此方法。子类重写finalize方法，以配置系统资源或执行其他清除。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/lwbqqyumidi/p/3693015.html\" target=\"_blank\" rel=\"external\">Java总结篇系列：java.lang.Object</a></p>\n<p>jdk api</p>\n","excerpt":"","more":"<p>Object类是Java中所有类的祖先，在Java中每个类都是由它扩展而来的。如果没有明确地指出超类，Object类就被认为是这个类的超类。<br>可以使用Object类型的变量引用任何类型的对象：<br><code>Object obj = new MyObject();</code><br>但是，要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的转化：<br><code>MyObject mObj = (MyObject) obj;</code><br>在Java中只有基本类型不是对象，例如：数值、字符和布尔型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型数组都扩展于Object类。</p>\n<h1 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h1><h2 id=\"public-Object\"><a href=\"#public-Object\" class=\"headerlink\" title=\"public Object();\"></a>public Object();</h2><p>Java中规定：在类定义过程中，对于未定义构造函数的类，默认会有一个无参数的构造函数，作为所有类的祖先，Object类自然要反映出此特性，在源代码中，未给出Object类构造函数定义，但实际上，此构造函数是存存的。</p>\n<h2 id=\"private-static-native-void-registerNatives-；\"><a href=\"#private-static-native-void-registerNatives-；\" class=\"headerlink\" title=\"private static native void registerNatives()；\"></a>private static native void registerNatives()；</h2><p>将本地函数向VM进行登记，将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。<br>此方法由其后紧跟的静态代码调用：<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    registerNatives();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"public-final-native-Class-lt-gt-getClass-；\"><a href=\"#public-final-native-Class-lt-gt-getClass-；\" class=\"headerlink\" title=\"public final native Class&lt;?&gt; getClass()；\"></a>public final native Class&lt;?&gt; getClass()；</h2><p>getClass()是一个native方法，返回这个对象的运行时类对象，效果与Object.class相同。<br>首先解释下”类对象”的概念：在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</p>\n<h2 id=\"public-native-int-hashCode\"><a href=\"#public-native-int-hashCode\" class=\"headerlink\" title=\"public native int hashCode()\"></a>public native int hashCode()</h2><p>hashCode()是一个native方法，返回一个整形数值，表示该对象的哈希码值。<br>hashCode()具有如下约定：</p>\n<ol>\n<li>在Java应用程序执行期间，对于同一个对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的信息未做修改。在某一应用程序的一次执行到同一应用程序的另一次执行，该整形数值无需保持一致。</li>\n<li>如果根据equals（object）方法，两个对象是相等的，则hashcode必须相同。</li>\n<li>如果两个对象的hashcode相同，这两个对象不一定相等。</li>\n</ol>\n<p><code>需要注意的是：为不相等的对象生成不同的hashcode可以提高哈希表的性能。</code></p>\n<h2 id=\"public-boolean-equals-Object-obj\"><a href=\"#public-boolean-equals-Object-obj\" class=\"headerlink\" title=\"public boolean equals(Object obj)\"></a>public boolean equals(Object obj)</h2><p>equals()方法判断两个对象是否相等，在Object类中，equals表示的是同一个对象。<br>代码如下：</p>\n<figure class=\"highlight aspectj\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object obj)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"keyword\">this</span> == obj);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>注意：重写了equals方法后需要重写hashCode方法。</code></p>\n<h2 id=\"protected-native-Object-clone-throws-CloneNotSupportedException\"><a href=\"#protected-native-Object-clone-throws-CloneNotSupportedException\" class=\"headerlink\" title=\"protected native Object clone() throws CloneNotSupportedException\"></a>protected native Object clone() throws CloneNotSupportedException</h2><p>clone()是一个native方法，其作用是创建并返回此对象的副本，返回的是一个引用，指向的是新clone出来的对象，此对象与原对象分别占用不同的堆空间。此方法执行的是对象的浅拷贝而不是深拷贝。</p>\n<p>`<br>注意：</p>\n<ol>\n<li>不可在子类中创建Object对象，并直接clone，原因如下：clone()方法是protected的，protected关键字的含义是：在同一个包内或者不同包的子类可以访问，当两个类不在同一个包中的时候，在子类内部且子类的引用才可以访问父类的protected成员；在子类内部，父类的引用并不能访问protected成员。<br>例：</li>\n</ol>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</span><br><span class=\"line\"><span class=\"built_in\">Object</span> cloneObj = obj.clone();</span><br></pre></td></tr></table></figure>\n<p>报错为：”The method clone() from the type Object is not visible”</p>\n<ol>\n<li>使用clone()方法的子类需要实现Cloneable接口，否则会抛出异常：java.lang.CloneNotSupportedException<br>例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CloneTest</span> <span class=\"keyword\">implements</span> <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String args[])</span> <span class=\"keyword\">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class=\"line\">        CloneTest obj = <span class=\"keyword\">new</span> CloneTest();</span><br><span class=\"line\">        CloneTest cloneObj = (CloneTest) obj.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>`</p>\n<h2 id=\"public-String-toString\"><a href=\"#public-String-toString\" class=\"headerlink\" title=\"public String toString()\"></a>public String toString()</h2><p>toString()方法返回该对象的字符串表示。代码如下：</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"built_in\">String</span> toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> getClass().getName() + <span class=\"string\">\"@\"</span> + <span class=\"built_in\">Integer</span>.toHexString(hashCode());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"public-final-native-void-notify\"><a href=\"#public-final-native-void-notify\" class=\"headerlink\" title=\"public final native void notify()\"></a>public final native void notify()</h2><p>唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个wait方法，在对象的监视器上等待。</p>\n<h2 id=\"public-final-native-void-notifyAll\"><a href=\"#public-final-native-void-notifyAll\" class=\"headerlink\" title=\"public final native void notifyAll()\"></a>public final native void notifyAll()</h2><p>唤醒在此对象监视器上等待的所有线程。线程通过调用其中一个wait方法，在对象的监视器上等待。</p>\n<h2 id=\"public-final-native-void-wait-long-timeout-throws-InterruptedException\"><a href=\"#public-final-native-void-wait-long-timeout-throws-InterruptedException\" class=\"headerlink\" title=\"public final native void wait(long timeout) throws InterruptedException\"></a>public final native void wait(long timeout) throws InterruptedException</h2><p>在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待。<br><code>timeout单位为毫秒。</code></p>\n<h2 id=\"public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException\"><a href=\"#public-final-void-wait-long-timeout-int-nanos-throws-InterruptedException\" class=\"headerlink\" title=\"public final void wait(long timeout, int nanos) throws InterruptedException\"></a>public final void wait(long timeout, int nanos) throws InterruptedException</h2><p>在其他线程调用此对象的notify()方法或notifyAll()方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。<br>此方法类似于一个参数的wait方法，但它允许更好地控制 在放弃之前等待通过的时间量。用毫微秒度量的实际时间量可以通过以下公式计算出来：<br><code>1000000 * timeout + nanos</code><br>在其他所有方面，此方法执行的操作与带有一个参数的wait(long)方法相同，需要特别指出的是，wait(0,0)与wait(0)相同。</p>\n<h2 id=\"简单的生产消费模型\"><a href=\"#简单的生产消费模型\" class=\"headerlink\" title=\"简单的生产消费模型\"></a>简单的生产消费模型</h2><p>一段简单的存钱/取钱代码，用来体现一下wait/notify的作用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> balance;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(<span class=\"keyword\">long</span> money)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (balance &lt; money) &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"余额不足, 需取: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">            wait();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        balance -= money;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"取出: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">long</span> money)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        balance += money;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"存入: \"</span> + money + <span class=\"string\">\"; 余额: \"</span> + balance);</span><br><span class=\"line\">        notifyAll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TakeThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TakeThread</span><span class=\"params\">(Account account)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                account.take(money);</span><br><span class=\"line\">                sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PutThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">PutThread</span><span class=\"params\">(Account account)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.account = account;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Random random = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> money = random.nextInt(<span class=\"number\">100</span>);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                account.put(money);</span><br><span class=\"line\">                sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"public-final-void-wait-throws-InterruptedException\"><a href=\"#public-final-void-wait-throws-InterruptedException\" class=\"headerlink\" title=\"public final void wait() throws InterruptedException\"></a>public final void wait() throws InterruptedException</h2><p>= wait(0)</p>\n<h2 id=\"protected-void-finalize-throws-Throwable\"><a href=\"#protected-void-finalize-throws-Throwable\" class=\"headerlink\" title=\"protected void finalize() throws Throwable\"></a>protected void finalize() throws Throwable</h2><p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾加收器调用此方法。子类重写finalize方法，以配置系统资源或执行其他清除。</p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"http://www.cnblogs.com/lwbqqyumidi/p/3693015.html\">Java总结篇系列：java.lang.Object</a></p>\n<p>jdk api</p>\n"},{"title":"hadoop-trouble-shooting","date":"2015-02-14T07:58:18.000Z","toc":true,"_content":"\n此处记录工作过程中遇到的问题、原因及解决办法\n\n# hadoop集群中一节点在任务运行过程中负载非常高\n\n## 问题描述\n\n在执行HIVE进行查询时发现，有一个节点（12核、32G内存）的负载达到了60多，且在该节点上运行的Map和Reduce都非常慢，使用top命令看到其wa cpu占用达到50%以上，有时候甚至100%。\n\n## 原因\n\n经一系列测试与观察发现，在该节点上进行读取的速度非常慢，而写入的速度与其他节点相差无几。\n磁盘读写测试如下：\n\n写：\n```\n[hadoop@bis-newdatanode-s2b-78 czw]$ time dd if=/dev/zero of=/data/czw/test.dbf bs=8k count=300000\n300000+0 records in\n300000+0 records out\n2457600000 bytes (2.5 GB) copied, 2.94392 s, 835 MB/s\n\nreal    0m2.945s\nuser    0m0.040s\nsys     0m2.904s\n```\n```\n[hadoop@bis-newdatanode-s2b-77 czw]$ time dd if=/dev/zero of=/data/czw/test.dbf bs=8k count=300000\n300000+0 records in\n300000+0 records out\n2457600000 bytes (2.5 GB) copied, 2.67449 s, 919 MB/s\n\nreal    0m2.697s\nuser    0m0.041s\nsys     0m2.629s\n```\n\n读：\n```\n[hadoop@bis-newdatanode-s2b-78 czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k\n116913+0 records in\n116912+0 records out\n957743104 bytes (958 MB) copied, 108.427 s, 8.8 MB/s\n0.01user 0.99system 1:48.42elapsed 0%CPU (0avgtext+0avgdata 3344maxresident)k\n1381376inputs+0outputs (0major+243minor)pagefaults 0swaps\n```\n```\n[hadoop@bis-newdatanode-s2b-77 czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k\n8624017+0 records in\n8624016+0 records out\n70647939072 bytes (71 GB) copied, 98.3302 s, 718 MB/s\n0.94user 77.33system 1:38.34elapsed 79%CPU (0avgtext+0avgdata 3360maxresident)k\n137980240inputs+0outputs (2major+242minor)pagefaults 0swaps\n```\n\n# Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError\n\n## 问题描述\n\n发现一个job偶尔会出现ShuffleError错误，重新执行又可以正常运行，查看其错误日志为：\n```\norg.apache.hadoop.mapred.TaskAttemptListenerImpl: Task: attempt_1468643232136_15659_r_000044_0 - exited : org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in fetcher#1\n\tat org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:121)\n\tat org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:380)\n\tat org.apache.hadoop.mapred.YarnChild$2.run(YarnChild.java:162)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:415)\n\tat org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1491)\n\tat org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:157)\nCaused by: java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.hadoop.io.BoundedByteArrayOutputStream.<init>(BoundedByteArrayOutputStream.java:56)\n\tat org.apache.hadoop.io.BoundedByteArrayOutputStream.<init>(BoundedByteArrayOutputStream.java:46)\n\tat org.apache.hadoop.mapreduce.task.reduce.InMemoryMapOutput.<init>(InMemoryMapOutput.java:63)\n\tat org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.unconditionalReserve(MergeManagerImpl.java:297)\n\tat org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.reserve(MergeManagerImpl.java:287)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyMapOutput(Fetcher.java:411)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:341)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.run(Fetcher.java:165)\n```\n\n## 原因\n\n我们的参数设置：\nmapreduce.reduce.shuffle.parallelcopies=5`(reuduce shuffle阶段并行传输数据的Fetcher线程数)`\nmapreduce.reduce.shuffle.input.buffer.percent=0.9`(copy阶段内存使用的最大值)`\nmapreduce.reduce.shuffle.memory.limit.percent=0.25`(每个fetch取到的输出的大小能够占的内存比的大小)`\n\n综上，实际每个fetcher的输出能放在内存的大小是：`reducer的java heap size * 0.9 * 0.25`。\n若5个线程均需申请这么多内存，则需要的内存大小为：`reducer的java heap size * 0.9 * 0.25 * 5`，便超出了reducer的最大内存，从而报出`Java heap space OutOfMemoryError`。\n\n`因此，我们可以采取调整上述3个参数的大小，控制它们的积不超过1即可`。\n\n## 参考\n[hadoop Shuffle Error OOM错误分析和解决](http://brandnewuser.iteye.com/blog/2149176)\n\n","source":"_posts/hadoop-trouble-shooting.md","raw":"---\ntitle: hadoop-trouble-shooting\ndate: 2015-02-14 15:58:18\ntoc: true\ntags: \n- hadoop hive\ncategories: \n- hadoop\n---\n\n此处记录工作过程中遇到的问题、原因及解决办法\n\n# hadoop集群中一节点在任务运行过程中负载非常高\n\n## 问题描述\n\n在执行HIVE进行查询时发现，有一个节点（12核、32G内存）的负载达到了60多，且在该节点上运行的Map和Reduce都非常慢，使用top命令看到其wa cpu占用达到50%以上，有时候甚至100%。\n\n## 原因\n\n经一系列测试与观察发现，在该节点上进行读取的速度非常慢，而写入的速度与其他节点相差无几。\n磁盘读写测试如下：\n\n写：\n```\n[hadoop@bis-newdatanode-s2b-78 czw]$ time dd if=/dev/zero of=/data/czw/test.dbf bs=8k count=300000\n300000+0 records in\n300000+0 records out\n2457600000 bytes (2.5 GB) copied, 2.94392 s, 835 MB/s\n\nreal    0m2.945s\nuser    0m0.040s\nsys     0m2.904s\n```\n```\n[hadoop@bis-newdatanode-s2b-77 czw]$ time dd if=/dev/zero of=/data/czw/test.dbf bs=8k count=300000\n300000+0 records in\n300000+0 records out\n2457600000 bytes (2.5 GB) copied, 2.67449 s, 919 MB/s\n\nreal    0m2.697s\nuser    0m0.041s\nsys     0m2.629s\n```\n\n读：\n```\n[hadoop@bis-newdatanode-s2b-78 czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k\n116913+0 records in\n116912+0 records out\n957743104 bytes (958 MB) copied, 108.427 s, 8.8 MB/s\n0.01user 0.99system 1:48.42elapsed 0%CPU (0avgtext+0avgdata 3344maxresident)k\n1381376inputs+0outputs (0major+243minor)pagefaults 0swaps\n```\n```\n[hadoop@bis-newdatanode-s2b-77 czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k\n8624017+0 records in\n8624016+0 records out\n70647939072 bytes (71 GB) copied, 98.3302 s, 718 MB/s\n0.94user 77.33system 1:38.34elapsed 79%CPU (0avgtext+0avgdata 3360maxresident)k\n137980240inputs+0outputs (2major+242minor)pagefaults 0swaps\n```\n\n# Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError\n\n## 问题描述\n\n发现一个job偶尔会出现ShuffleError错误，重新执行又可以正常运行，查看其错误日志为：\n```\norg.apache.hadoop.mapred.TaskAttemptListenerImpl: Task: attempt_1468643232136_15659_r_000044_0 - exited : org.apache.hadoop.mapreduce.task.reduce.Shuffle$ShuffleError: error in shuffle in fetcher#1\n\tat org.apache.hadoop.mapreduce.task.reduce.Shuffle.run(Shuffle.java:121)\n\tat org.apache.hadoop.mapred.ReduceTask.run(ReduceTask.java:380)\n\tat org.apache.hadoop.mapred.YarnChild$2.run(YarnChild.java:162)\n\tat java.security.AccessController.doPrivileged(Native Method)\n\tat javax.security.auth.Subject.doAs(Subject.java:415)\n\tat org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:1491)\n\tat org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:157)\nCaused by: java.lang.OutOfMemoryError: Java heap space\n\tat org.apache.hadoop.io.BoundedByteArrayOutputStream.<init>(BoundedByteArrayOutputStream.java:56)\n\tat org.apache.hadoop.io.BoundedByteArrayOutputStream.<init>(BoundedByteArrayOutputStream.java:46)\n\tat org.apache.hadoop.mapreduce.task.reduce.InMemoryMapOutput.<init>(InMemoryMapOutput.java:63)\n\tat org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.unconditionalReserve(MergeManagerImpl.java:297)\n\tat org.apache.hadoop.mapreduce.task.reduce.MergeManagerImpl.reserve(MergeManagerImpl.java:287)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyMapOutput(Fetcher.java:411)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.copyFromHost(Fetcher.java:341)\n\tat org.apache.hadoop.mapreduce.task.reduce.Fetcher.run(Fetcher.java:165)\n```\n\n## 原因\n\n我们的参数设置：\nmapreduce.reduce.shuffle.parallelcopies=5`(reuduce shuffle阶段并行传输数据的Fetcher线程数)`\nmapreduce.reduce.shuffle.input.buffer.percent=0.9`(copy阶段内存使用的最大值)`\nmapreduce.reduce.shuffle.memory.limit.percent=0.25`(每个fetch取到的输出的大小能够占的内存比的大小)`\n\n综上，实际每个fetcher的输出能放在内存的大小是：`reducer的java heap size * 0.9 * 0.25`。\n若5个线程均需申请这么多内存，则需要的内存大小为：`reducer的java heap size * 0.9 * 0.25 * 5`，便超出了reducer的最大内存，从而报出`Java heap space OutOfMemoryError`。\n\n`因此，我们可以采取调整上述3个参数的大小，控制它们的积不超过1即可`。\n\n## 参考\n[hadoop Shuffle Error OOM错误分析和解决](http://brandnewuser.iteye.com/blog/2149176)\n\n","slug":"hadoop-trouble-shooting","published":1,"updated":"2016-08-14T07:34:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirub9ogb0000g7v0dw855eq5","content":"<p>此处记录工作过程中遇到的问题、原因及解决办法</p>\n<h1 id=\"hadoop集群中一节点在任务运行过程中负载非常高\"><a href=\"#hadoop集群中一节点在任务运行过程中负载非常高\" class=\"headerlink\" title=\"hadoop集群中一节点在任务运行过程中负载非常高\"></a>hadoop集群中一节点在任务运行过程中负载非常高</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>在执行HIVE进行查询时发现，有一个节点（12核、32G内存）的负载达到了60多，且在该节点上运行的Map和Reduce都非常慢，使用top命令看到其wa cpu占用达到50%以上，有时候甚至100%。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>经一系列测试与观察发现，在该节点上进行读取的速度非常慢，而写入的速度与其他节点相差无几。<br>磁盘读写测试如下：</p>\n<p>写：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[hadoop@bis-newdatanode-s2b-<span class=\"number\">78</span> czw]$ <span class=\"selector-tag\">time</span> <span class=\"selector-tag\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/data/czw/test<span class=\"selector-class\">.dbf</span> bs=<span class=\"number\">8</span>k count=<span class=\"number\">300000</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records out</span><br><span class=\"line\"><span class=\"number\">2457600000</span> bytes (<span class=\"number\">2.5</span> GB) copied, <span class=\"number\">2.94392</span> s, <span class=\"number\">835</span> MB/s</span><br><span class=\"line\"></span><br><span class=\"line\">real    <span class=\"number\">0</span>m2.<span class=\"number\">945s</span></span><br><span class=\"line\">user    <span class=\"number\">0</span>m0.<span class=\"number\">040s</span></span><br><span class=\"line\">sys     <span class=\"number\">0</span>m2.<span class=\"number\">904s</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[hadoop@bis-newdatanode-s2b-<span class=\"number\">77</span> czw]$ <span class=\"selector-tag\">time</span> <span class=\"selector-tag\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/data/czw/test<span class=\"selector-class\">.dbf</span> bs=<span class=\"number\">8</span>k count=<span class=\"number\">300000</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records out</span><br><span class=\"line\"><span class=\"number\">2457600000</span> bytes (<span class=\"number\">2.5</span> GB) copied, <span class=\"number\">2.67449</span> s, <span class=\"number\">919</span> MB/s</span><br><span class=\"line\"></span><br><span class=\"line\">real    <span class=\"number\">0</span>m2.<span class=\"number\">697s</span></span><br><span class=\"line\">user    <span class=\"number\">0</span>m0.<span class=\"number\">041s</span></span><br><span class=\"line\">sys     <span class=\"number\">0</span>m2.<span class=\"number\">629s</span></span><br></pre></td></tr></table></figure>\n<p>读：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">hadoop@bis-newdatanode-s2b-78</span> czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k</span><br><span class=\"line\"><span class=\"number\">116913</span><span class=\"number\">+0</span> records in</span><br><span class=\"line\"><span class=\"number\">116912</span><span class=\"number\">+0</span> records out</span><br><span class=\"line\"><span class=\"number\">957743104</span> bytes (<span class=\"name\">958</span> MB) copied, <span class=\"number\">108.427</span> s, <span class=\"number\">8.8</span> MB/s</span><br><span class=\"line\"><span class=\"number\">0.01</span>user <span class=\"number\">0.99</span>system <span class=\"number\">1</span>:48.42elapsed <span class=\"number\">0</span>%CPU (<span class=\"name\">0avgtext+0avgdata</span> <span class=\"number\">3344</span>maxresident)k</span><br><span class=\"line\"><span class=\"number\">1381376</span>inputs+0outputs (<span class=\"name\">0major+243minor</span>)pagefaults <span class=\"number\">0</span>swaps</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">hadoop@bis-newdatanode-s2b-77</span> czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k</span><br><span class=\"line\"><span class=\"number\">8624017</span><span class=\"number\">+0</span> records in</span><br><span class=\"line\"><span class=\"number\">8624016</span><span class=\"number\">+0</span> records out</span><br><span class=\"line\"><span class=\"number\">70647939072</span> bytes (<span class=\"name\">71</span> GB) copied, <span class=\"number\">98.3302</span> s, <span class=\"number\">718</span> MB/s</span><br><span class=\"line\"><span class=\"number\">0.94</span>user <span class=\"number\">77.33</span>system <span class=\"number\">1</span>:38.34elapsed <span class=\"number\">79</span>%CPU (<span class=\"name\">0avgtext+0avgdata</span> <span class=\"number\">3360</span>maxresident)k</span><br><span class=\"line\"><span class=\"number\">137980240</span>inputs+0outputs (<span class=\"name\">2major+242minor</span>)pagefaults <span class=\"number\">0</span>swaps</span><br></pre></td></tr></table></figure>\n<h1 id=\"Reduce-ShuffleError-error-in-shuffle-in-fetcher-OutOfMemoryError\"><a href=\"#Reduce-ShuffleError-error-in-shuffle-in-fetcher-OutOfMemoryError\" class=\"headerlink\" title=\"Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError\"></a>Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError</h1><h2 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>发现一个job偶尔会出现ShuffleError错误，重新执行又可以正常运行，查看其错误日志为：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.TaskAttemptListenerImpl</span>: Task: attempt_1468643232136_15659_r_000044_0 - exited : org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Shuffle</span><span class=\"variable\">$ShuffleError</span>: error <span class=\"keyword\">in</span> shuffle <span class=\"keyword\">in</span> fetcher#<span class=\"number\">1</span></span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Shuffle</span><span class=\"selector-class\">.run</span>(Shuffle<span class=\"selector-class\">.java</span>:<span class=\"number\">121</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.ReduceTask</span><span class=\"selector-class\">.run</span>(ReduceTask<span class=\"selector-class\">.java</span>:<span class=\"number\">380</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.YarnChild</span>$<span class=\"number\">2</span>.run(YarnChild<span class=\"selector-class\">.java</span>:<span class=\"number\">162</span>)</span><br><span class=\"line\">\tat java<span class=\"selector-class\">.security</span><span class=\"selector-class\">.AccessController</span><span class=\"selector-class\">.doPrivileged</span>(Native Method)</span><br><span class=\"line\">\tat javax<span class=\"selector-class\">.security</span><span class=\"selector-class\">.auth</span><span class=\"selector-class\">.Subject</span><span class=\"selector-class\">.doAs</span>(Subject<span class=\"selector-class\">.java</span>:<span class=\"number\">415</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.security</span><span class=\"selector-class\">.UserGroupInformation</span><span class=\"selector-class\">.doAs</span>(UserGroupInformation<span class=\"selector-class\">.java</span>:<span class=\"number\">1491</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.YarnChild</span><span class=\"selector-class\">.main</span>(YarnChild<span class=\"selector-class\">.java</span>:<span class=\"number\">157</span>)</span><br><span class=\"line\">Caused by: java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.OutOfMemoryError</span>: Java heap space</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.BoundedByteArrayOutputStream</span>.&lt;init&gt;(BoundedByteArrayOutputStream<span class=\"selector-class\">.java</span>:<span class=\"number\">56</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.BoundedByteArrayOutputStream</span>.&lt;init&gt;(BoundedByteArrayOutputStream<span class=\"selector-class\">.java</span>:<span class=\"number\">46</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.InMemoryMapOutput</span>.&lt;init&gt;(InMemoryMapOutput<span class=\"selector-class\">.java</span>:<span class=\"number\">63</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.MergeManagerImpl</span><span class=\"selector-class\">.unconditionalReserve</span>(MergeManagerImpl<span class=\"selector-class\">.java</span>:<span class=\"number\">297</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.MergeManagerImpl</span><span class=\"selector-class\">.reserve</span>(MergeManagerImpl<span class=\"selector-class\">.java</span>:<span class=\"number\">287</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.copyMapOutput</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.copyFromHost</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">341</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.run</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">165</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>我们的参数设置：<br>mapreduce.reduce.shuffle.parallelcopies=5<code>(reuduce shuffle阶段并行传输数据的Fetcher线程数)</code><br>mapreduce.reduce.shuffle.input.buffer.percent=0.9<code>(copy阶段内存使用的最大值)</code><br>mapreduce.reduce.shuffle.memory.limit.percent=0.25<code>(每个fetch取到的输出的大小能够占的内存比的大小)</code></p>\n<p>综上，实际每个fetcher的输出能放在内存的大小是：<code>reducer的java heap size * 0.9 * 0.25</code>。<br>若5个线程均需申请这么多内存，则需要的内存大小为：<code>reducer的java heap size * 0.9 * 0.25 * 5</code>，便超出了reducer的最大内存，从而报出<code>Java heap space OutOfMemoryError</code>。</p>\n<p><code>因此，我们可以采取调整上述3个参数的大小，控制它们的积不超过1即可</code>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://brandnewuser.iteye.com/blog/2149176\" target=\"_blank\" rel=\"external\">hadoop Shuffle Error OOM错误分析和解决</a></p>\n","excerpt":"","more":"<p>此处记录工作过程中遇到的问题、原因及解决办法</p>\n<h1 id=\"hadoop集群中一节点在任务运行过程中负载非常高\"><a href=\"#hadoop集群中一节点在任务运行过程中负载非常高\" class=\"headerlink\" title=\"hadoop集群中一节点在任务运行过程中负载非常高\"></a>hadoop集群中一节点在任务运行过程中负载非常高</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>在执行HIVE进行查询时发现，有一个节点（12核、32G内存）的负载达到了60多，且在该节点上运行的Map和Reduce都非常慢，使用top命令看到其wa cpu占用达到50%以上，有时候甚至100%。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>经一系列测试与观察发现，在该节点上进行读取的速度非常慢，而写入的速度与其他节点相差无几。<br>磁盘读写测试如下：</p>\n<p>写：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[hadoop@bis-newdatanode-s2b-<span class=\"number\">78</span> czw]$ <span class=\"selector-tag\">time</span> <span class=\"selector-tag\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/data/czw/test<span class=\"selector-class\">.dbf</span> bs=<span class=\"number\">8</span>k count=<span class=\"number\">300000</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records out</span><br><span class=\"line\"><span class=\"number\">2457600000</span> bytes (<span class=\"number\">2.5</span> GB) copied, <span class=\"number\">2.94392</span> s, <span class=\"number\">835</span> MB/s</span><br><span class=\"line\"></span><br><span class=\"line\">real    <span class=\"number\">0</span>m2.<span class=\"number\">945s</span></span><br><span class=\"line\">user    <span class=\"number\">0</span>m0.<span class=\"number\">040s</span></span><br><span class=\"line\">sys     <span class=\"number\">0</span>m2.<span class=\"number\">904s</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[hadoop@bis-newdatanode-s2b-<span class=\"number\">77</span> czw]$ <span class=\"selector-tag\">time</span> <span class=\"selector-tag\">dd</span> <span class=\"keyword\">if</span>=/dev/zero of=/data/czw/test<span class=\"selector-class\">.dbf</span> bs=<span class=\"number\">8</span>k count=<span class=\"number\">300000</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records <span class=\"keyword\">in</span></span><br><span class=\"line\"><span class=\"number\">300000</span>+<span class=\"number\">0</span> records out</span><br><span class=\"line\"><span class=\"number\">2457600000</span> bytes (<span class=\"number\">2.5</span> GB) copied, <span class=\"number\">2.67449</span> s, <span class=\"number\">919</span> MB/s</span><br><span class=\"line\"></span><br><span class=\"line\">real    <span class=\"number\">0</span>m2.<span class=\"number\">697s</span></span><br><span class=\"line\">user    <span class=\"number\">0</span>m0.<span class=\"number\">041s</span></span><br><span class=\"line\">sys     <span class=\"number\">0</span>m2.<span class=\"number\">629s</span></span><br></pre></td></tr></table></figure>\n<p>读：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">hadoop@bis-newdatanode-s2b-78</span> czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k</span><br><span class=\"line\"><span class=\"number\">116913</span><span class=\"number\">+0</span> records in</span><br><span class=\"line\"><span class=\"number\">116912</span><span class=\"number\">+0</span> records out</span><br><span class=\"line\"><span class=\"number\">957743104</span> bytes (<span class=\"name\">958</span> MB) copied, <span class=\"number\">108.427</span> s, <span class=\"number\">8.8</span> MB/s</span><br><span class=\"line\"><span class=\"number\">0.01</span>user <span class=\"number\">0.99</span>system <span class=\"number\">1</span>:48.42elapsed <span class=\"number\">0</span>%CPU (<span class=\"name\">0avgtext+0avgdata</span> <span class=\"number\">3344</span>maxresident)k</span><br><span class=\"line\"><span class=\"number\">1381376</span>inputs+0outputs (<span class=\"name\">0major+243minor</span>)pagefaults <span class=\"number\">0</span>swaps</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">hadoop@bis-newdatanode-s2b-77</span> czw]$ sudo time dd if=/dev/mapper/datavg-datalv of=/dev/null bs=8k</span><br><span class=\"line\"><span class=\"number\">8624017</span><span class=\"number\">+0</span> records in</span><br><span class=\"line\"><span class=\"number\">8624016</span><span class=\"number\">+0</span> records out</span><br><span class=\"line\"><span class=\"number\">70647939072</span> bytes (<span class=\"name\">71</span> GB) copied, <span class=\"number\">98.3302</span> s, <span class=\"number\">718</span> MB/s</span><br><span class=\"line\"><span class=\"number\">0.94</span>user <span class=\"number\">77.33</span>system <span class=\"number\">1</span>:38.34elapsed <span class=\"number\">79</span>%CPU (<span class=\"name\">0avgtext+0avgdata</span> <span class=\"number\">3360</span>maxresident)k</span><br><span class=\"line\"><span class=\"number\">137980240</span>inputs+0outputs (<span class=\"name\">2major+242minor</span>)pagefaults <span class=\"number\">0</span>swaps</span><br></pre></td></tr></table></figure>\n<h1 id=\"Reduce-ShuffleError-error-in-shuffle-in-fetcher-OutOfMemoryError\"><a href=\"#Reduce-ShuffleError-error-in-shuffle-in-fetcher-OutOfMemoryError\" class=\"headerlink\" title=\"Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError\"></a>Reduce ShuffleError: error in shuffle in fetcher, OutOfMemoryError</h1><h2 id=\"问题描述-1\"><a href=\"#问题描述-1\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>发现一个job偶尔会出现ShuffleError错误，重新执行又可以正常运行，查看其错误日志为：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.TaskAttemptListenerImpl</span>: Task: attempt_1468643232136_15659_r_000044_0 - exited : org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Shuffle</span><span class=\"variable\">$ShuffleError</span>: error <span class=\"keyword\">in</span> shuffle <span class=\"keyword\">in</span> fetcher#<span class=\"number\">1</span></span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Shuffle</span><span class=\"selector-class\">.run</span>(Shuffle<span class=\"selector-class\">.java</span>:<span class=\"number\">121</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.ReduceTask</span><span class=\"selector-class\">.run</span>(ReduceTask<span class=\"selector-class\">.java</span>:<span class=\"number\">380</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.YarnChild</span>$<span class=\"number\">2</span>.run(YarnChild<span class=\"selector-class\">.java</span>:<span class=\"number\">162</span>)</span><br><span class=\"line\">\tat java<span class=\"selector-class\">.security</span><span class=\"selector-class\">.AccessController</span><span class=\"selector-class\">.doPrivileged</span>(Native Method)</span><br><span class=\"line\">\tat javax<span class=\"selector-class\">.security</span><span class=\"selector-class\">.auth</span><span class=\"selector-class\">.Subject</span><span class=\"selector-class\">.doAs</span>(Subject<span class=\"selector-class\">.java</span>:<span class=\"number\">415</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.security</span><span class=\"selector-class\">.UserGroupInformation</span><span class=\"selector-class\">.doAs</span>(UserGroupInformation<span class=\"selector-class\">.java</span>:<span class=\"number\">1491</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapred</span><span class=\"selector-class\">.YarnChild</span><span class=\"selector-class\">.main</span>(YarnChild<span class=\"selector-class\">.java</span>:<span class=\"number\">157</span>)</span><br><span class=\"line\">Caused by: java<span class=\"selector-class\">.lang</span><span class=\"selector-class\">.OutOfMemoryError</span>: Java heap space</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.BoundedByteArrayOutputStream</span>.&lt;init&gt;(BoundedByteArrayOutputStream<span class=\"selector-class\">.java</span>:<span class=\"number\">56</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.io</span><span class=\"selector-class\">.BoundedByteArrayOutputStream</span>.&lt;init&gt;(BoundedByteArrayOutputStream<span class=\"selector-class\">.java</span>:<span class=\"number\">46</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.InMemoryMapOutput</span>.&lt;init&gt;(InMemoryMapOutput<span class=\"selector-class\">.java</span>:<span class=\"number\">63</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.MergeManagerImpl</span><span class=\"selector-class\">.unconditionalReserve</span>(MergeManagerImpl<span class=\"selector-class\">.java</span>:<span class=\"number\">297</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.MergeManagerImpl</span><span class=\"selector-class\">.reserve</span>(MergeManagerImpl<span class=\"selector-class\">.java</span>:<span class=\"number\">287</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.copyMapOutput</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">411</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.copyFromHost</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">341</span>)</span><br><span class=\"line\">\tat org<span class=\"selector-class\">.apache</span><span class=\"selector-class\">.hadoop</span><span class=\"selector-class\">.mapreduce</span><span class=\"selector-class\">.task</span><span class=\"selector-class\">.reduce</span><span class=\"selector-class\">.Fetcher</span><span class=\"selector-class\">.run</span>(Fetcher<span class=\"selector-class\">.java</span>:<span class=\"number\">165</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"原因-1\"><a href=\"#原因-1\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>我们的参数设置：<br>mapreduce.reduce.shuffle.parallelcopies=5<code>(reuduce shuffle阶段并行传输数据的Fetcher线程数)</code><br>mapreduce.reduce.shuffle.input.buffer.percent=0.9<code>(copy阶段内存使用的最大值)</code><br>mapreduce.reduce.shuffle.memory.limit.percent=0.25<code>(每个fetch取到的输出的大小能够占的内存比的大小)</code></p>\n<p>综上，实际每个fetcher的输出能放在内存的大小是：<code>reducer的java heap size * 0.9 * 0.25</code>。<br>若5个线程均需申请这么多内存，则需要的内存大小为：<code>reducer的java heap size * 0.9 * 0.25 * 5</code>，便超出了reducer的最大内存，从而报出<code>Java heap space OutOfMemoryError</code>。</p>\n<p><code>因此，我们可以采取调整上述3个参数的大小，控制它们的积不超过1即可</code>。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"http://brandnewuser.iteye.com/blog/2149176\">hadoop Shuffle Error OOM错误分析和解决</a></p>\n"},{"title":"js-trouble-shooting","date":"2016-08-09T10:32:04.000Z","toc":true,"_content":"记录使用js时遇到的问题、原因及解决办法。\n\n# chrome display不生效\n\n## 问题描述\n\n往后台请求数据时有一定的延时，为了更好的用户体验，需要在页面进行查询时，先展示一个loading的gif图片。\n关键代码如下：\n```\n$(\"#id\").css(\"display\", \"none\");\n$(\"#id\").css(\"display\", \"block\");\n```\n在firefox下正常显示，在chrome下不能正常展示，而在chrome下进行调试时，在此处打上断点，便又可正常显示。\n\n## 原因\n在js中使用ajax向后台请求数据时，采用了同步的方式`async: false`引起。\n一点猜测：由于使用`async: false`时，Ajax请求会将整个浏览器锁死，而在chrome下`$(\"#id\").css(\"display\", \"none\");`尚未渲染完成，因此无法看到加载图片。\n\n## 解决办法\n使用ajax请求默认的异步请求方式，注释掉`async: false`或将其改为`async: true`。\n\n\n\n","source":"_posts/js-trouble-shooting.md","raw":"---\ntitle: js-trouble-shooting\ndate: 2016-08-09 18:32:04\ntoc: true\ntags:\n- js\ncategories:\n- js\n---\n记录使用js时遇到的问题、原因及解决办法。\n\n# chrome display不生效\n\n## 问题描述\n\n往后台请求数据时有一定的延时，为了更好的用户体验，需要在页面进行查询时，先展示一个loading的gif图片。\n关键代码如下：\n```\n$(\"#id\").css(\"display\", \"none\");\n$(\"#id\").css(\"display\", \"block\");\n```\n在firefox下正常显示，在chrome下不能正常展示，而在chrome下进行调试时，在此处打上断点，便又可正常显示。\n\n## 原因\n在js中使用ajax向后台请求数据时，采用了同步的方式`async: false`引起。\n一点猜测：由于使用`async: false`时，Ajax请求会将整个浏览器锁死，而在chrome下`$(\"#id\").css(\"display\", \"none\");`尚未渲染完成，因此无法看到加载图片。\n\n## 解决办法\n使用ajax请求默认的异步请求方式，注释掉`async: false`或将其改为`async: true`。\n\n\n\n","slug":"js-trouble-shooting","published":1,"updated":"2016-08-14T07:34:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirub9ogf0001g7v0wbtdw2uu","content":"<p>记录使用js时遇到的问题、原因及解决办法。</p>\n<h1 id=\"chrome-display不生效\"><a href=\"#chrome-display不生效\" class=\"headerlink\" title=\"chrome display不生效\"></a>chrome display不生效</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>往后台请求数据时有一定的延时，为了更好的用户体验，需要在页面进行查询时，先展示一个loading的gif图片。<br>关键代码如下：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">\"#id\"</span>).css(<span class=\"string\">\"display\"</span>, <span class=\"string\">\"none\"</span>);</span><br><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">\"#id\"</span>).css(<span class=\"string\">\"display\"</span>, <span class=\"string\">\"block\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在firefox下正常显示，在chrome下不能正常展示，而在chrome下进行调试时，在此处打上断点，便又可正常显示。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>在js中使用ajax向后台请求数据时，采用了同步的方式<code>async: false</code>引起。<br>一点猜测：由于使用<code>async: false</code>时，Ajax请求会将整个浏览器锁死，而在chrome下<code>$(&quot;#id&quot;).css(&quot;display&quot;, &quot;none&quot;);</code>尚未渲染完成，因此无法看到加载图片。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>使用ajax请求默认的异步请求方式，注释掉<code>async: false</code>或将其改为<code>async: true</code>。</p>\n","excerpt":"","more":"<p>记录使用js时遇到的问题、原因及解决办法。</p>\n<h1 id=\"chrome-display不生效\"><a href=\"#chrome-display不生效\" class=\"headerlink\" title=\"chrome display不生效\"></a>chrome display不生效</h1><h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>往后台请求数据时有一定的延时，为了更好的用户体验，需要在页面进行查询时，先展示一个loading的gif图片。<br>关键代码如下：<br><figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">\"#id\"</span>).css(<span class=\"string\">\"display\"</span>, <span class=\"string\">\"none\"</span>);</span><br><span class=\"line\"><span class=\"variable\">$(</span><span class=\"string\">\"#id\"</span>).css(<span class=\"string\">\"display\"</span>, <span class=\"string\">\"block\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>在firefox下正常显示，在chrome下不能正常展示，而在chrome下进行调试时，在此处打上断点，便又可正常显示。</p>\n<h2 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h2><p>在js中使用ajax向后台请求数据时，采用了同步的方式<code>async: false</code>引起。<br>一点猜测：由于使用<code>async: false</code>时，Ajax请求会将整个浏览器锁死，而在chrome下<code>$(&quot;#id&quot;).css(&quot;display&quot;, &quot;none&quot;);</code>尚未渲染完成，因此无法看到加载图片。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>使用ajax请求默认的异步请求方式，注释掉<code>async: false</code>或将其改为<code>async: true</code>。</p>\n"},{"title":"hive-params","date":"2016-07-15T02:08:05.000Z","toc":true,"_content":"\n本文主要翻译自hive 1.2.1版本的hive-default.xml.template。\n\n# hive参数配置\n\nHive提供三种可以改变环境变量的方法，分别是：（1）、修改配置文件；（2）、命令行参数；（3）、进入cli后设置参数。\n\n## 修改配置文件\n\n修改Hive的配置文件：`${HIVE_HOME}/conf/hive-site.xml`\n\n## 命令行参数\n\n在命令行添加-hiveconf param=value来设定参数\n如：\n```\nhive --hiveconf mapreduce.job.queuename=queue1\n```\n\n## 进入cli后设置参数\n\n可以在进入cli后，使用SET设置参数，如：\n\n```\nhive> set mapreduce.job.queuename=queue1;\n```\n\n这种配置也是对本次启动的会话有效，下次启动需要重新配置。\n在HQL中使用SET关键字还可以查看配置的值，如下：\n\n```\nhive> set mapreduce.job.queuename;\nmapreduce.job.queuename=queue1\n```\n\n如果set后面什么都不添加，这样可以查到Hive的所有属性配置。\n\n# hive参数大全\n\n参数|说明|默认值\n--|--|--\n11|12|13\n21|22|23\n31|32|33","source":"_posts/hive-params.md","raw":"---\ntitle: hive-params\ndate: 2016-07-15 10:08:05\ntoc: true\ntags: \n- hive\ncategories: \n- hive\n---\n\n本文主要翻译自hive 1.2.1版本的hive-default.xml.template。\n\n# hive参数配置\n\nHive提供三种可以改变环境变量的方法，分别是：（1）、修改配置文件；（2）、命令行参数；（3）、进入cli后设置参数。\n\n## 修改配置文件\n\n修改Hive的配置文件：`${HIVE_HOME}/conf/hive-site.xml`\n\n## 命令行参数\n\n在命令行添加-hiveconf param=value来设定参数\n如：\n```\nhive --hiveconf mapreduce.job.queuename=queue1\n```\n\n## 进入cli后设置参数\n\n可以在进入cli后，使用SET设置参数，如：\n\n```\nhive> set mapreduce.job.queuename=queue1;\n```\n\n这种配置也是对本次启动的会话有效，下次启动需要重新配置。\n在HQL中使用SET关键字还可以查看配置的值，如下：\n\n```\nhive> set mapreduce.job.queuename;\nmapreduce.job.queuename=queue1\n```\n\n如果set后面什么都不添加，这样可以查到Hive的所有属性配置。\n\n# hive参数大全\n\n参数|说明|默认值\n--|--|--\n11|12|13\n21|22|23\n31|32|33","slug":"hive-params","published":1,"updated":"2016-08-14T07:34:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirub9ogx0004g7v09rmk1eij","content":"<p>本文主要翻译自hive 1.2.1版本的hive-default.xml.template。</p>\n<h1 id=\"hive参数配置\"><a href=\"#hive参数配置\" class=\"headerlink\" title=\"hive参数配置\"></a>hive参数配置</h1><p>Hive提供三种可以改变环境变量的方法，分别是：（1）、修改配置文件；（2）、命令行参数；（3）、进入cli后设置参数。</p>\n<h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>修改Hive的配置文件：<code>${HIVE_HOME}/conf/hive-site.xml</code></p>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>在命令行添加-hiveconf param=value来设定参数<br>如：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive --hiveconf mapreduce<span class=\"selector-class\">.job</span><span class=\"selector-class\">.queuename</span>=queue1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"进入cli后设置参数\"><a href=\"#进入cli后设置参数\" class=\"headerlink\" title=\"进入cli后设置参数\"></a>进入cli后设置参数</h2><p>可以在进入cli后，使用SET设置参数，如：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">set</span> mapreduce.<span class=\"keyword\">job</span>.queuename=queue1<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这种配置也是对本次启动的会话有效，下次启动需要重新配置。<br>在HQL中使用SET关键字还可以查看配置的值，如下：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">set</span> mapreduce.<span class=\"keyword\">job</span>.queuename<span class=\"comment\">;</span></span><br><span class=\"line\">mapreduce.<span class=\"keyword\">job</span>.queuename=queue1</span><br></pre></td></tr></table></figure>\n<p>如果set后面什么都不添加，这样可以查到Hive的所有属性配置。</p>\n<h1 id=\"hive参数大全\"><a href=\"#hive参数大全\" class=\"headerlink\" title=\"hive参数大全\"></a>hive参数大全</h1><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n","excerpt":"","more":"<p>本文主要翻译自hive 1.2.1版本的hive-default.xml.template。</p>\n<h1 id=\"hive参数配置\"><a href=\"#hive参数配置\" class=\"headerlink\" title=\"hive参数配置\"></a>hive参数配置</h1><p>Hive提供三种可以改变环境变量的方法，分别是：（1）、修改配置文件；（2）、命令行参数；（3）、进入cli后设置参数。</p>\n<h2 id=\"修改配置文件\"><a href=\"#修改配置文件\" class=\"headerlink\" title=\"修改配置文件\"></a>修改配置文件</h2><p>修改Hive的配置文件：<code>${HIVE_HOME}/conf/hive-site.xml</code></p>\n<h2 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h2><p>在命令行添加-hiveconf param=value来设定参数<br>如：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive --hiveconf mapreduce<span class=\"selector-class\">.job</span><span class=\"selector-class\">.queuename</span>=queue1</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"进入cli后设置参数\"><a href=\"#进入cli后设置参数\" class=\"headerlink\" title=\"进入cli后设置参数\"></a>进入cli后设置参数</h2><p>可以在进入cli后，使用SET设置参数，如：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">set</span> mapreduce.<span class=\"keyword\">job</span>.queuename=queue1<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure>\n<p>这种配置也是对本次启动的会话有效，下次启动需要重新配置。<br>在HQL中使用SET关键字还可以查看配置的值，如下：</p>\n<figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">set</span> mapreduce.<span class=\"keyword\">job</span>.queuename<span class=\"comment\">;</span></span><br><span class=\"line\">mapreduce.<span class=\"keyword\">job</span>.queuename=queue1</span><br></pre></td></tr></table></figure>\n<p>如果set后面什么都不添加，这样可以查到Hive的所有属性配置。</p>\n<h1 id=\"hive参数大全\"><a href=\"#hive参数大全\" class=\"headerlink\" title=\"hive参数大全\"></a>hive参数大全</h1><table>\n<thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>11</td>\n<td>12</td>\n<td>13</td>\n</tr>\n<tr>\n<td>21</td>\n<td>22</td>\n<td>23</td>\n</tr>\n<tr>\n<td>31</td>\n<td>32</td>\n<td>33</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"mysql-tips","date":"2016-08-09T10:31:24.000Z","toc":true,"_content":"记录使用mysql的过程中一些技巧、方法、注意事项。\n\n# on case when\n做关联查询时需要根据输入数据的值来判断关联条件。\n如有表t1(code, name)、t2(code,name)，当code为空时，使用name关联。\n在查询的时候，这种情况一般都使用case when来进行逻辑判断，因此突发奇想是否可以在表关联时使用case when, 即\n```\nselect * from t1 left join t2 on \ncase when t1.code is null then t1.name = t2.name \nelse t1.code = t2.code end\n```\n这种用法是错误的，尽管其在mysql下并不会报错，case when放在on后面，不会进行操作。\n正确的写法应该是：\n```\nselect * from t1 left join t2 on\n(t1.code is null and t1.name = t2.name)\nor\n(t1.code = t2.code)\n```\n","source":"_posts/mysql-tips.md","raw":"---\ntitle: mysql-tips\ndate: 2016-08-09 18:31:24\ntoc: true\ntags:\n- mysql\ncategories:\n- mysql\n---\n记录使用mysql的过程中一些技巧、方法、注意事项。\n\n# on case when\n做关联查询时需要根据输入数据的值来判断关联条件。\n如有表t1(code, name)、t2(code,name)，当code为空时，使用name关联。\n在查询的时候，这种情况一般都使用case when来进行逻辑判断，因此突发奇想是否可以在表关联时使用case when, 即\n```\nselect * from t1 left join t2 on \ncase when t1.code is null then t1.name = t2.name \nelse t1.code = t2.code end\n```\n这种用法是错误的，尽管其在mysql下并不会报错，case when放在on后面，不会进行操作。\n正确的写法应该是：\n```\nselect * from t1 left join t2 on\n(t1.code is null and t1.name = t2.name)\nor\n(t1.code = t2.code)\n```\n","slug":"mysql-tips","published":1,"updated":"2016-08-14T07:34:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirub9oh00005g7v0py74hlqj","content":"<p>记录使用mysql的过程中一些技巧、方法、注意事项。</p>\n<h1 id=\"on-case-when\"><a href=\"#on-case-when\" class=\"headerlink\" title=\"on case when\"></a>on case when</h1><p>做关联查询时需要根据输入数据的值来判断关联条件。<br>如有表t1(code, name)、t2(code,name)，当code为空时，使用name关联。<br>在查询的时候，这种情况一般都使用case when来进行逻辑判断，因此突发奇想是否可以在表关联时使用case when, 即<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> t1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> t2 <span class=\"keyword\">on</span> </span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">when</span> t1.code <span class=\"keyword\">is</span> <span class=\"literal\">null</span> <span class=\"keyword\">then</span> t1.name = t2.name </span><br><span class=\"line\"><span class=\"keyword\">else</span> t1.code = t2.code <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>这种用法是错误的，尽管其在mysql下并不会报错，case when放在on后面，不会进行操作。<br>正确的写法应该是：<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from <span class=\"built_in\">t1</span> left <span class=\"keyword\">join </span><span class=\"built_in\">t2</span> on</span><br><span class=\"line\">(<span class=\"built_in\">t1</span><span class=\"meta\">.code</span> is null <span class=\"keyword\">and </span><span class=\"built_in\">t1</span>.name = <span class=\"built_in\">t2</span>.name)</span><br><span class=\"line\"><span class=\"keyword\">or</span><br><span class=\"line\"></span>(<span class=\"built_in\">t1</span><span class=\"meta\">.code</span> = <span class=\"built_in\">t2</span><span class=\"meta\">.code</span>)</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<p>记录使用mysql的过程中一些技巧、方法、注意事项。</p>\n<h1 id=\"on-case-when\"><a href=\"#on-case-when\" class=\"headerlink\" title=\"on case when\"></a>on case when</h1><p>做关联查询时需要根据输入数据的值来判断关联条件。<br>如有表t1(code, name)、t2(code,name)，当code为空时，使用name关联。<br>在查询的时候，这种情况一般都使用case when来进行逻辑判断，因此突发奇想是否可以在表关联时使用case when, 即<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> * <span class=\"keyword\">from</span> t1 <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> t2 <span class=\"keyword\">on</span> </span><br><span class=\"line\"><span class=\"keyword\">case</span> <span class=\"keyword\">when</span> t1.code <span class=\"keyword\">is</span> <span class=\"literal\">null</span> <span class=\"keyword\">then</span> t1.name = t2.name </span><br><span class=\"line\"><span class=\"keyword\">else</span> t1.code = t2.code <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></p>\n<p>这种用法是错误的，尽管其在mysql下并不会报错，case when放在on后面，不会进行操作。<br>正确的写法应该是：<br><figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select * from <span class=\"built_in\">t1</span> left <span class=\"keyword\">join </span><span class=\"built_in\">t2</span> on</span><br><span class=\"line\">(<span class=\"built_in\">t1</span><span class=\"meta\">.code</span> is null <span class=\"keyword\">and </span><span class=\"built_in\">t1</span>.name = <span class=\"built_in\">t2</span>.name)</span><br><span class=\"line\"><span class=\"keyword\">or</span><br><span class=\"line\"></span>(<span class=\"built_in\">t1</span><span class=\"meta\">.code</span> = <span class=\"built_in\">t2</span><span class=\"meta\">.code</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Hive语法手册","date":"2016-04-05T16:00:00.000Z","toc":true,"_content":"\n# 数据操作语句\n\n## DML：装载，插入，更新，删除\n\n## 导入/导出\n\n## 数据检索：查询\n\n### select\n\n#### select语法\n\n```\n[WITH CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting with Hive 0.13.0)\nSELECT [ALL | DISTINCT] select_expr, select_expr, ...\n  FROM table_reference\n  [WHERE where_condition]\n  [GROUP BY col_list]\n  [ORDER BY col_list]\n  [CLUSTER BY col_list\n    | [DISTRIBUTE BY col_list] [SORT BY col_list]\n  ]\n [LIMIT number]\n```\n\n* select语句可以是联合查询(union)的一部分或另一个查询的子查询。\n* table_reference表示实际的查询对象，可以是一个普通表，一个视图，一个join或一个子查询。\n* 表名和列名不区分大小写。\n\t* 在Hive 0.12和更早的版本中，表和列名中只允许字母数字和下划线。\n\t* 在Hive 0.13及更高版本中，列名可以包含任何Unicode字符（见[HIVE-6013](https://issues.apache.org/jira/browse/HIVE-6013)），反引号（\\`\\`）可指定的任何列名。可以使用双反引号（\\`\\`）来表示一个反引号字符。\n\t* 要恢复到0.13.0版本以前的行为，并限制列的名称字母，数字和下划线字符，设置属性`hive.support.quoted.identifiers`为none。在此配置中，反引号(\\`\\`)中的字符被解释为正则表达式。有关详细信息，请参阅[Supporting Quoted Identifiers in Column Names](https://issues.apache.org/jira/browse/HIVE-6013）。另见[正则表达式](#####正则表达式)。\n* 简单查询。例如，下面的查询检索所有列，并从表T1的所有行。\n\n```\nSELECT * FROM t1\n```\n\n```\n注意使用0.13及以上版本，FROM是可选的，如select 1 + 1\n```\n\n* 获取当前数据库（0.13及以上版本），使用current_database（）函数：\n\n```\nSELECT current_database()\n```\n\n* 指定数据库，在表名前指定数据库名（\"db_name.table_name\"Hive 0.7开始）或在查询语句之前使用`use`语句。\n“db_name.table_name”允许访问不同数据库的表。\nuse语句对之后所有的HiveQL语句生效，使用default重置为默认数据库。\n\n```\nUSE database_name;\nSELECT query_specifications;\nUSE default;\n```\n\n##### where子句\n\nWHERE条件是一个布尔表达式。例如，下面的查询只返回美国区域数量大于10的销售记录。Hive的WHERE子句中支持许多[操作符和UDF](####操作符和用户自定义函数(UDFS))。\n\n```\nSELECT * FROM sales WHERE amount > 10 AND region = \"US\"\n```\n\n0.13以上版本也支持在where子句中使用一些子查询。\n\n##### all和distinct子句\n\nALL和DISTINCT选项指定重复的行是否应该返回。如果没有这些选项给出，默认是所有（返回所有匹配的行）。DISTINCT指定结果集中删除重复的行。注意：Hive从1.1.0版本开始支持`SELECT DISTINCT *`语句。[HIVE-9194](https://issues.apache.org/jira/browse/HIVE-9194)\n\n```\nhive> SELECT col1, col2 FROM t1\n    1 3\n    1 3\n    1 4\n    2 5\nhive> SELECT DISTINCT col1, col2 FROM t1\n    1 3\n    1 4\n    2 5\nhive> SELECT DISTINCT col1 FROM t1\n    1\n    2\n```\n\nALL和DISTINCT也可以在UNION子句中使用-见[Union](####Union)以获取更多信息。\n\n##### 基于分区（partition）的查询\n一般情况下，一个SELECT查询扫描整个表。如果一个表使用PARTITIONED BY子句创建，查询语句可以仅查询指定分区表的一小部分。Hive在where子句或Join子句中进行分区修剪，例如：表page_views使用列date进行分区，以下查询语句仅检索2008-03-01和2008-03-31之前的行。\n\n```\nSELECT page_views.*\nFROM page_views\nWHERE page_views.date >= '2008-03-01' AND page_views.date <= '2008-03-31'\n```\n\n如果表page_views与表dim_users关联，可以像下面一样在on子句中指定分区范围。\n\n```\nSELECT page_views.*\nFROM page_views JOIN dim_users\n  ON (page_views.user_id = dim_users.id AND page_views.date >= '2008-03-01' AND page_views.date <= '2008-03-31')\n```\n\n另见[Group By](####Group By)。\n\n另见[Sort By / Cluster By / Distribute By / Order By](#### Sort/Distribute/Cluster/Order By)\n\n##### having子句\n\nHive 0.7.0版本增加了对HAVING子句的支持。在旧版本中可以使用子查询达到同样的效果：\n\n```\nSELECT col1 FROM t1 GROUP BY col1 HAVING SUM(col2) > 10\n```\n\n```\nSELECT col1 FROM (SELECT col1, SUM(col2) AS col2sum FROM t1 GROUP BY col1) t2 WHERE t2.col2sum > 10\n```\n\n##### limit子句\n\n限制指示要返回的行数。返回的行被随机选择。下面的查询从表T中随机返回1到5行。\n\n```\nSELECT * FROM t1 LIMIT 5\n```\n\n* Top k查询，下面的语句返回Top 5的销售记录。\n\n```\nSET mapred.reduce.tasks = 1\nSELECT * FROM sales SORT BY amount DESC LIMIT 5\n```\n\n`这个列子应该不对`\n\n##### 正则表达式\n\n0.13.0及更高版本中，如果配置了`hive.support.quoted.identifiers`为`none`，则在select语句支持查询基于正则表达式的列名。\n\n* 我们使用Java正则表达式的语法。尝试[http://www.fileformat.info/tool/regex.htm](http://www.fileformat.info/tool/regex.htm)用于测试。\n* 下面的查询将选择所有ds或hr的列。\n\n```\nSELECT `(ds|hr)?+.+` FROM sales\n```\n\n#### Group By\n\n##### Group By语法\n\n```\ngroupByClause: GROUP BY groupByExpression (, groupByExpression)*\n \ngroupByExpression: expression\n \ngroupByQuery: SELECT expression (, expression)* FROM src groupByClause?\n```\n\n在group by表达式中，列由名称指定，而不是列编号，在Hive 0.11及更高版本中，列可以通过位置指定。需要配置`hive.groupby.orderby.position.alias`为`true`（默认为`false`）。\n\n##### 简单例子\n\n为了计算表中的行数：\n\n```\nSELECT COUNT(*) FROM table2;\n```\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n为了计算不同性别的用户数量，可以使用以下查询。\n\n```\nINSERT OVERWRITE TABLE pv_gender_sum\nSELECT pv_users.gender, count (DISTINCT pv_users.userid)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n多个聚合可以在同一时间内完成，但是，没有任何两个聚合可以使用不同的列。例如，以下是可能的，因为count(DISTINCT)和sum(DISTINCT)指定了相同的列：\n\n```\nINSERT OVERWRITE TABLE pv_gender_agg\nSELECT pv_users.gender, count(DISTINCT pv_users.userid), count(*), sum(DISTINCT pv_users.userid)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n如下查询是不允许的，在同一个查询中不允许使用多个DISTINCT表达式。\n\n```\nINSERT OVERWRITE TABLE pv_gender_agg\nSELECT pv_users.gender, count(DISTINCT pv_users.userid), count(DISTINCT pv_users.ip)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n##### Select语句和group by子句\n\n当使用group by子句，select语句只能包含列包括在GROUP BY子句。当然，有很多聚合功能（例如count）同样可以用在select子句中。\n让我们以一个简单的例子：\n\n```\nCREATE TABLE t1(a INTEGER, b INTGER);\n```\n一个使用上表的group by查询可能是这样的：\n\n```\nSELECT\n   a,\n   sum(b)\nFROM\n   t1\nGROUP BY\n   a;\n```\n上面的查询可以正常运行，因为select子句包括a(使用列a做group by)和一个聚合函数(sum(b))。\n但是，下面的语句不能运行：\n```\nSELECT\n   a,\n   b\nFROM\n   t1\nGROUP BY\n   a;\n```\n因为select子句中有一个未包含在group by子句中的附加列(列 b)，也不是一个聚合函数。这是因为，如果表是这样的：\n\na|b\n-|-\n100|1\n100|2\n100|3\n由于仅在a上进行了组合，那么在组a=100中，b应该显示为什么值呢？人们可以说，它应该是第一个值或最​低值，但我们都同意，有多种可能的选择。Hive抛弃了这种猜测，认为在select子句中拥有group by子句中不存在的列是无效的SQL(准确地说，是HQL)。\n\n##### 高级功能\n\n###### 多组插入\n聚合或简单查询的结果可以输出到多个表甚至是hdfs(使用hdfs操作)上，例如，在按性别分类的同时，有一个需求是按年龄分类。一个可行的查询是这样的：\n\n```\nFROM pv_users\nINSERT OVERWRITE TABLE pv_gender_sum\n  SELECT pv_users.gender, count(DISTINCT pv_users.userid)\n  GROUP BY pv_users.gender\nINSERT OVERWRITE DIRECTORY '/user/facebook/tmp/pv_age_sum'\n  SELECT pv_users.age, count(DISTINCT pv_users.userid)\n  GROUP BY pv_users.age;\n```\n\n###### map端聚合\n\nhive.map.aggr控制我们如何做聚合，默认为false，如果它被设置为true，Hive将在map任务直接做的第一级集合。\n这通常提供了更好的效率，但可能需要更多的内存来运行工作。\n\n```\nset hive.map.aggr=true;\nSELECT COUNT(*) FROM table2;\n```\n\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n###### Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数\n\n```\n版本：\nrouping sets, CUBE and ROLLUP操作符,和GROUPING__ID函数在Hive 0.10.0版本中加入。\n```\n\n见[增强聚合，多维数据集，分组和汇总](###增强聚合、多维数据集、分组和汇总)获取有关这些聚合操作的详细信息。\n\n另见JIRAs：\n[HIVE-2397](https://issues.apache.org/jira/browse/HIVE-2397)group by支持rollup选项\n[HIVE-3433](https://issues.apache.org/jira/browse/HIVE-3433)实现CUBE和ROLLUP操作符\n[HIVE-3471](https://issues.apache.org/jira/browse/HIVE-3471)实现Hive sets分组集\n[HIVE-3613](https://issues.apache.org/jira/browse/HIVE-3613)实现GROUPING_ID函数\n\n#### Sort/Distribute/Cluster/Order By\n\n描述select子句中的ORDER BY, SORT BY, CLUSTER BY, 和DISTRIBUTE BY的语法。\n\n##### Order By语法\n\nHive QL中的Order By语法跟SQL语言中的ORDER BY类似。\n\n```\ncolOrder: ( ASC | DESC )\ncolNullOrder: (NULLS FIRST | NULLS LAST)           -- (Note: Available in Hive 2.1.0 and later)\norderBy: ORDER BY colName colOrder? colNullOrder? (',' colName colOrder? colNullOrder?)*\nquery: SELECT expression (',' expression)* FROM src orderBy\n```\n\n\"order by\"子句具有很多局限性，在严格模式(设置了`hive.mapred.mode=strict`)中，order by子句后需要跟上`limit`子句，若将`hive.mapred.mode`设置为`nonstrict`则不需要`limit`子句。原因是，为了将所有的记录排序，只能使用一个reducer，如果数据量太大，单个reducer将花费很长的时间才能执行完成。\n\n需要注意的是列由列名指定，则不是位置编号，可以在0.11.0及更新版本中使用配置`hive.groupby.orderby.position.alias`为`true`（默认为false）来启用位置编号。\n默认的排序顺序是升序（ASC）。\n在Hive 2.1.0及更高版本中，支持空排序，默认空排序顺序为ASC顺序是NULLS FIRST，而默认为空的倒序排列顺序是NULLS LAST。\n\n##### Sort By语法\n\nSort By语法跟SQL语言中的ORDER BY类似。\n\n```\ncolOrder: ( ASC | DESC )\nsortBy: SORT BY colName colOrder? (',' colName colOrder?)*\nquery: SELECT expression (',' expression)* FROM src sortBy\n```\nHive在将数据传递到reducer之前，使用sort by对行进行排序，排列顺序取决于列的类型，如果列是numeric类型，则按数值顺序排序，如果是string类型，则按字典顺序排序。\n\n##### Sort By和Order By的区别\n\n\"order by\"和\"sort by\"的区别在于，前者对所有输出进行排序，后者仅对一个reducer中的输出进行排序，如果存在多个reducer，sort by只能进行部分排序。\n\n注意：可能会对Sort By和CLUSTER BY的区别感到困惑，CLUSTER BY在有多个reducer的情况下，为了将数据均衡地分布数据，将数据按字段进行分区并排序。\n\n基本上，在每个reducer中的数据将会按照用户指定的字段进行排序。如下示例：\n\n```\nSELECT key, value FROM src SORT BY key ASC, value DESC\n```\n这个查询可能有2个reducer，输出分别是：\n\n```\n0   5\n0   3\n3   6\n9   1\n```\n```\n0   4\n0   3\n1   1\n2   5\n```\n\n在一次transform后，变量将会被认为是string类型，意味着数值型将按照字典序进行排序，为了克服这种情况，在使用sort by之前需要使用一个带有cast的子查询，如下：\n\n```\nFROM (FROM (FROM src\n            SELECT TRANSFORM(value)\n            USING 'mapper'\n            AS value, count) mapped\n      SELECT cast(value as double) AS value, cast(count as int) AS count\n      SORT BY value, count) sorted\nSELECT TRANSFORM(value, count)\nUSING 'reducer'\nAS whatever\n```\n\n##### Cluster By和Distribute By语法\n\nCluster By和Distribute By主要跟[Transform/Map-Reduce脚本](####Transform和map-reduce脚本)一起使用，但是有时候为了给后续的子查询分区并排序时，这是非常有用的。\nCluster By可以看作是Distribute By和Sort By的合集。\nHive使用Distribute By指定的列将数据分发到reducer中，相同的值将会放到同一个reducer中，但是Distribute By不保证clustering或sorting属性。\n\n例如，我们Distribute By X以下5行记录到2个reducer中：\n\n```\nx1\nx2\nx4\nx3\nx1\n```\nreducer 1\n\n```\nx1\nx2\nx1\n```\n\nreducer 2\n\n```\nx4\nx3\n```\nX相同的值x1分发到reducer1 中，但不能保存其在相邻位置。\n\n如果我们使用Cluster By x，这两个reducer将会进行进一步排序。\nreducer 1\n\n```\nx1\nx1\nx2\n```\n\nreducer 2\n\n```\nx3\nx4\n```\n\n可以使用Distribute By和Sort By来代替Cluster By，而且分区列和排序列可以是不同的列。\n\n```\nSELECT col1, col2 FROM t1 CLUSTER BY col1\n```\n\n```\nSELECT col1, col2 FROM t1 DISTRIBUTE BY col1\nSELECT col1, col2 FROM t1 DISTRIBUTE BY col1 SORT BY col1 ASC, col2 DESC\n```\n\n```\nFROM (\n  FROM pv_users\n  MAP ( pv_users.userid, pv_users.date )\n  USING 'map_script'\n  AS c1, c2, c3\n  DISTRIBUTE BY c2\n  SORT BY c2, c1) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE ( map_output.c1, map_output.c2, map_output.c3 )\n  USING 'reduce_script'\n  AS date, count;\n```\n\n#### Transform和map-reduce脚本\n\n用户可以指定自定义的mapper和reducer，例如，为了执行自定义的mapper-map_script和自定义的reducer-reducer_script，可以使用如下带有TRANSFORM子句的命令嵌入map和reduce脚本。\n\n默认情况下，在传输给自定义脚本时，列将会转换成string类型，并且以tab作为分隔符，同样的，为了区分空字符串，所有的NULL值将被转换成\\N字符。自定义脚本的标准输出是tab分隔的string列，任何包括\\N的值将被认为是NULL, string类型的结果将转换成表定义中的列类型。用户自定义脚本可以输出debug信息到标准错误，这将在Hadoop任务详细信息页面上显示。这些默认值可以被ROW FORMAT覆盖。\n\n在windows下，使用\"cmd /c your_script\"。\n\n```\n警告\n在transformation之前处理任意string列是你的责任，如果有string列包含tab，需要使用[REGEXP_REPLACE](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-StringFunctions)并替换tab为其他字符。\n```\n\n```\n警告\n从形式上，MAP...和REDUCE...是SELECT TRANSFORM ( ... )的语法。换句话说，它们作为阅读查询语句的注释或说明。注意：使用这些关键字是危险的，如，输出\"REDUCE\" 不能强制转换成reduce，输出\"MAP\"不能强制转换成map。\n```\n另请参阅[ Sort By / Cluster By / Distribute By ](#### Sort/Distribute/Cluster/Order By)和[Larry Ogrodnek's的博客](http://dev.bizo.com/2009/10/hive-map-reduce-in-java.html)\n\n```\nclusterBy: CLUSTER BY colName (',' colName)*\ndistributeBy: DISTRIBUTE BY colName (',' colName)*\nsortBy: SORT BY colName (ASC | DESC)? (',' colName (ASC | DESC)?)*\n \nrowFormat\n  : ROW FORMAT\n    (DELIMITED [FIELDS TERMINATED BY char]\n               [COLLECTION ITEMS TERMINATED BY char]\n               [MAP KEYS TERMINATED BY char]\n               [ESCAPED BY char]\n               [LINES SEPARATED BY char]\n     |\n     SERDE serde_name [WITH SERDEPROPERTIES\n                            property_name=property_value,\n                            property_name=property_value, ...])\n \noutRowFormat : rowFormat\ninRowFormat : rowFormat\noutRecordReader : RECORDREADER className\n \nquery:\n  FROM (\n    FROM src\n    MAP expression (',' expression)*\n    (inRowFormat)?\n    USING 'my_map_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n    ( clusterBy? | distributeBy? sortBy? ) src_alias\n  )\n  REDUCE expression (',' expression)*\n    (inRowFormat)?\n    USING 'my_reduce_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n \n  FROM (\n    FROM src\n    SELECT TRANSFORM '(' expression (',' expression)* ')'\n    (inRowFormat)?\n    USING 'my_map_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n    ( clusterBy? | distributeBy? sortBy? ) src_alias\n  )\n  SELECT TRANSFORM '(' expression (',' expression)* ')'\n    (inRowFormat)?\n    USING 'my_reduce_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n```\n\n标准SQL不支持TRANSFORM，TRANSFORM子句在Hive 0.13.0及[HIVE-6415](https://issues.apache.org/jira/browse/HIVE-6415)的后续版本中，通过配置[SQL standard based authorization](https://cwiki.apache.org/confluence/display/Hive/SQL+Standard+Based+Hive+Authorization)禁用。\n\nTRANSFORM示例：\n例1：\n\n```\nFROM (\n  FROM pv_users\n  MAP pv_users.userid, pv_users.date\n  USING 'map_script'\n  AS dt, uid\n  CLUSTER BY dt) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE map_output.dt, map_output.uid\n  USING 'reduce_script'\n  AS date, count;\nFROM (\n  FROM pv_users\n  SELECT TRANSFORM(pv_users.userid, pv_users.date)\n  USING 'map_script'\n  AS dt, uid\n  CLUSTER BY dt) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  SELECT TRANSFORM(map_output.dt, map_output.uid)\n  USING 'reduce_script'\n  AS date, count;\n```\n例2:\n\n```\nFROM (\n  FROM src\n  SELECT TRANSFORM(src.key, src.value) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'\n  USING '/bin/cat'\n  AS (tkey, tvalue) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'\n  RECORDREADER 'org.apache.hadoop.hive.contrib.util.typedbytes.TypedBytesRecordReader'\n) tmap\nINSERT OVERWRITE TABLE dest1 SELECT tkey, tvalue\n```\n\n##### 缺少schema的map-reduce脚本\n\n如果在USING my_script之后没有AS子句，Hive假定脚本的输出包括两个部分，key是第一个tab之前的部分，值是第一个tab之后的部分。注意这与指定AS key, value不同，因为在那种情况下，如果存在多个tab，value将仅包含第一个tab第二个tab之间的部分。\n\n注意我们可以直接使用CLUSTER BY key，而不在脚本中指定输出格式。\n\n```\nFROM (\n  FROM pv_users\n  MAP pv_users.userid, pv_users.date\n  USING 'map_script'\n  CLUSTER BY key) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE map_output.key, map_output.value\n  USING 'reduce_script'\n  AS date, count;\n```\n\n##### TRANSFORM的输出\n\n脚本的输出字段默认以string进行输入，例如：\n\n```\nSELECT TRANSFORM(stuff)\nUSING 'script'\nAS thing1, thing2\n```\n这将可以被强制转换为\n\n```\nSELECT TRANSFORM(stuff)\nUSING 'script'\nAS (thing1 INT, thing2 INT)\n```\n\n#### 操作符和用户自定义函数(UDFS)\n\n在Beeline或CLi下，使用如下命令来显示最近的文档：\n\n```\nSHOW FUNCTIONS;\nDESCRIBE FUNCTION <function_name>;\nDESCRIBE FUNCTION EXTENDED <function_name>;\n```\n\n```\n当UDF嵌套在UDF或function中时存在Bug。\n当 `hive.cache.expr.evaluation`设置为`true`（默认）时，UDF嵌套在UDF或function中将会产生不正确的结果。这个bug会影响0.12.0, 0.13.0和0.13.1。0.14.0修复了这个bug([HIVE-7314](https://issues.apache.org/jira/browse/HIVE-7314).\n这个问题与UDF的实现的getDisplayString方法有关，在Hive user mailing list中的相关[讨论](http://mail-archives.apache.org/mod_mbox/hive-user/201407.mbox/%3cCAEWg7THU-Pr1Dfv_A8VS3Uz5t3ZyJvL0f-bebg4Zb3hXkK-CGQ@mail.gmail.com%3e)\n```\n\n##### 内置操作符\n\n###### 关系运算符\n\n###### 算术运算符\n\n###### 逻辑运算符\n\n###### 复杂类型的运算符\n\n##### 内置函数\n\n###### \n\n###### \n\n###### \n\n###### \n\n###### \n\n##### 内置聚合函数\n\n##### 内置生成表函数\n\n##### Grouping and Sorting on\n\n##### UDF内部\n\n##### 创建自定义的UDF\n\n#### XPath专用函数\n\n#### Joins\n\n#### Join优化\n\n#### Union\n\n#### 横向视图\n\n### 子查询\n\n### 采样\n\n### 虚拟列\n\n### 窗口和分析函数\n\n### 增强聚合、多维数据集、分组和汇总\n\n## 程序语言：Hive HPL/SQL\n\n## 解释执行计划\n\n","source":"_posts/hive-language-manual.md","raw":"---\ntitle: Hive语法手册\ndate: 2016/04/06 00:00:00\ntoc: true\ntags: \n- hive\ncategories: \n- hive\n---\n\n# 数据操作语句\n\n## DML：装载，插入，更新，删除\n\n## 导入/导出\n\n## 数据检索：查询\n\n### select\n\n#### select语法\n\n```\n[WITH CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting with Hive 0.13.0)\nSELECT [ALL | DISTINCT] select_expr, select_expr, ...\n  FROM table_reference\n  [WHERE where_condition]\n  [GROUP BY col_list]\n  [ORDER BY col_list]\n  [CLUSTER BY col_list\n    | [DISTRIBUTE BY col_list] [SORT BY col_list]\n  ]\n [LIMIT number]\n```\n\n* select语句可以是联合查询(union)的一部分或另一个查询的子查询。\n* table_reference表示实际的查询对象，可以是一个普通表，一个视图，一个join或一个子查询。\n* 表名和列名不区分大小写。\n\t* 在Hive 0.12和更早的版本中，表和列名中只允许字母数字和下划线。\n\t* 在Hive 0.13及更高版本中，列名可以包含任何Unicode字符（见[HIVE-6013](https://issues.apache.org/jira/browse/HIVE-6013)），反引号（\\`\\`）可指定的任何列名。可以使用双反引号（\\`\\`）来表示一个反引号字符。\n\t* 要恢复到0.13.0版本以前的行为，并限制列的名称字母，数字和下划线字符，设置属性`hive.support.quoted.identifiers`为none。在此配置中，反引号(\\`\\`)中的字符被解释为正则表达式。有关详细信息，请参阅[Supporting Quoted Identifiers in Column Names](https://issues.apache.org/jira/browse/HIVE-6013）。另见[正则表达式](#####正则表达式)。\n* 简单查询。例如，下面的查询检索所有列，并从表T1的所有行。\n\n```\nSELECT * FROM t1\n```\n\n```\n注意使用0.13及以上版本，FROM是可选的，如select 1 + 1\n```\n\n* 获取当前数据库（0.13及以上版本），使用current_database（）函数：\n\n```\nSELECT current_database()\n```\n\n* 指定数据库，在表名前指定数据库名（\"db_name.table_name\"Hive 0.7开始）或在查询语句之前使用`use`语句。\n“db_name.table_name”允许访问不同数据库的表。\nuse语句对之后所有的HiveQL语句生效，使用default重置为默认数据库。\n\n```\nUSE database_name;\nSELECT query_specifications;\nUSE default;\n```\n\n##### where子句\n\nWHERE条件是一个布尔表达式。例如，下面的查询只返回美国区域数量大于10的销售记录。Hive的WHERE子句中支持许多[操作符和UDF](####操作符和用户自定义函数(UDFS))。\n\n```\nSELECT * FROM sales WHERE amount > 10 AND region = \"US\"\n```\n\n0.13以上版本也支持在where子句中使用一些子查询。\n\n##### all和distinct子句\n\nALL和DISTINCT选项指定重复的行是否应该返回。如果没有这些选项给出，默认是所有（返回所有匹配的行）。DISTINCT指定结果集中删除重复的行。注意：Hive从1.1.0版本开始支持`SELECT DISTINCT *`语句。[HIVE-9194](https://issues.apache.org/jira/browse/HIVE-9194)\n\n```\nhive> SELECT col1, col2 FROM t1\n    1 3\n    1 3\n    1 4\n    2 5\nhive> SELECT DISTINCT col1, col2 FROM t1\n    1 3\n    1 4\n    2 5\nhive> SELECT DISTINCT col1 FROM t1\n    1\n    2\n```\n\nALL和DISTINCT也可以在UNION子句中使用-见[Union](####Union)以获取更多信息。\n\n##### 基于分区（partition）的查询\n一般情况下，一个SELECT查询扫描整个表。如果一个表使用PARTITIONED BY子句创建，查询语句可以仅查询指定分区表的一小部分。Hive在where子句或Join子句中进行分区修剪，例如：表page_views使用列date进行分区，以下查询语句仅检索2008-03-01和2008-03-31之前的行。\n\n```\nSELECT page_views.*\nFROM page_views\nWHERE page_views.date >= '2008-03-01' AND page_views.date <= '2008-03-31'\n```\n\n如果表page_views与表dim_users关联，可以像下面一样在on子句中指定分区范围。\n\n```\nSELECT page_views.*\nFROM page_views JOIN dim_users\n  ON (page_views.user_id = dim_users.id AND page_views.date >= '2008-03-01' AND page_views.date <= '2008-03-31')\n```\n\n另见[Group By](####Group By)。\n\n另见[Sort By / Cluster By / Distribute By / Order By](#### Sort/Distribute/Cluster/Order By)\n\n##### having子句\n\nHive 0.7.0版本增加了对HAVING子句的支持。在旧版本中可以使用子查询达到同样的效果：\n\n```\nSELECT col1 FROM t1 GROUP BY col1 HAVING SUM(col2) > 10\n```\n\n```\nSELECT col1 FROM (SELECT col1, SUM(col2) AS col2sum FROM t1 GROUP BY col1) t2 WHERE t2.col2sum > 10\n```\n\n##### limit子句\n\n限制指示要返回的行数。返回的行被随机选择。下面的查询从表T中随机返回1到5行。\n\n```\nSELECT * FROM t1 LIMIT 5\n```\n\n* Top k查询，下面的语句返回Top 5的销售记录。\n\n```\nSET mapred.reduce.tasks = 1\nSELECT * FROM sales SORT BY amount DESC LIMIT 5\n```\n\n`这个列子应该不对`\n\n##### 正则表达式\n\n0.13.0及更高版本中，如果配置了`hive.support.quoted.identifiers`为`none`，则在select语句支持查询基于正则表达式的列名。\n\n* 我们使用Java正则表达式的语法。尝试[http://www.fileformat.info/tool/regex.htm](http://www.fileformat.info/tool/regex.htm)用于测试。\n* 下面的查询将选择所有ds或hr的列。\n\n```\nSELECT `(ds|hr)?+.+` FROM sales\n```\n\n#### Group By\n\n##### Group By语法\n\n```\ngroupByClause: GROUP BY groupByExpression (, groupByExpression)*\n \ngroupByExpression: expression\n \ngroupByQuery: SELECT expression (, expression)* FROM src groupByClause?\n```\n\n在group by表达式中，列由名称指定，而不是列编号，在Hive 0.11及更高版本中，列可以通过位置指定。需要配置`hive.groupby.orderby.position.alias`为`true`（默认为`false`）。\n\n##### 简单例子\n\n为了计算表中的行数：\n\n```\nSELECT COUNT(*) FROM table2;\n```\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n为了计算不同性别的用户数量，可以使用以下查询。\n\n```\nINSERT OVERWRITE TABLE pv_gender_sum\nSELECT pv_users.gender, count (DISTINCT pv_users.userid)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n多个聚合可以在同一时间内完成，但是，没有任何两个聚合可以使用不同的列。例如，以下是可能的，因为count(DISTINCT)和sum(DISTINCT)指定了相同的列：\n\n```\nINSERT OVERWRITE TABLE pv_gender_agg\nSELECT pv_users.gender, count(DISTINCT pv_users.userid), count(*), sum(DISTINCT pv_users.userid)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n如下查询是不允许的，在同一个查询中不允许使用多个DISTINCT表达式。\n\n```\nINSERT OVERWRITE TABLE pv_gender_agg\nSELECT pv_users.gender, count(DISTINCT pv_users.userid), count(DISTINCT pv_users.ip)\nFROM pv_users\nGROUP BY pv_users.gender;\n```\n\n##### Select语句和group by子句\n\n当使用group by子句，select语句只能包含列包括在GROUP BY子句。当然，有很多聚合功能（例如count）同样可以用在select子句中。\n让我们以一个简单的例子：\n\n```\nCREATE TABLE t1(a INTEGER, b INTGER);\n```\n一个使用上表的group by查询可能是这样的：\n\n```\nSELECT\n   a,\n   sum(b)\nFROM\n   t1\nGROUP BY\n   a;\n```\n上面的查询可以正常运行，因为select子句包括a(使用列a做group by)和一个聚合函数(sum(b))。\n但是，下面的语句不能运行：\n```\nSELECT\n   a,\n   b\nFROM\n   t1\nGROUP BY\n   a;\n```\n因为select子句中有一个未包含在group by子句中的附加列(列 b)，也不是一个聚合函数。这是因为，如果表是这样的：\n\na|b\n-|-\n100|1\n100|2\n100|3\n由于仅在a上进行了组合，那么在组a=100中，b应该显示为什么值呢？人们可以说，它应该是第一个值或最​低值，但我们都同意，有多种可能的选择。Hive抛弃了这种猜测，认为在select子句中拥有group by子句中不存在的列是无效的SQL(准确地说，是HQL)。\n\n##### 高级功能\n\n###### 多组插入\n聚合或简单查询的结果可以输出到多个表甚至是hdfs(使用hdfs操作)上，例如，在按性别分类的同时，有一个需求是按年龄分类。一个可行的查询是这样的：\n\n```\nFROM pv_users\nINSERT OVERWRITE TABLE pv_gender_sum\n  SELECT pv_users.gender, count(DISTINCT pv_users.userid)\n  GROUP BY pv_users.gender\nINSERT OVERWRITE DIRECTORY '/user/facebook/tmp/pv_age_sum'\n  SELECT pv_users.age, count(DISTINCT pv_users.userid)\n  GROUP BY pv_users.age;\n```\n\n###### map端聚合\n\nhive.map.aggr控制我们如何做聚合，默认为false，如果它被设置为true，Hive将在map任务直接做的第一级集合。\n这通常提供了更好的效率，但可能需要更多的内存来运行工作。\n\n```\nset hive.map.aggr=true;\nSELECT COUNT(*) FROM table2;\n```\n\n注意在不包含[HIVE-287](https://issues.apache.org/jira/browse/HIVE-287)的Hive版本中，需要使用`COUNT(1)`代替`COUNT(*)`\n\n###### Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数\n\n```\n版本：\nrouping sets, CUBE and ROLLUP操作符,和GROUPING__ID函数在Hive 0.10.0版本中加入。\n```\n\n见[增强聚合，多维数据集，分组和汇总](###增强聚合、多维数据集、分组和汇总)获取有关这些聚合操作的详细信息。\n\n另见JIRAs：\n[HIVE-2397](https://issues.apache.org/jira/browse/HIVE-2397)group by支持rollup选项\n[HIVE-3433](https://issues.apache.org/jira/browse/HIVE-3433)实现CUBE和ROLLUP操作符\n[HIVE-3471](https://issues.apache.org/jira/browse/HIVE-3471)实现Hive sets分组集\n[HIVE-3613](https://issues.apache.org/jira/browse/HIVE-3613)实现GROUPING_ID函数\n\n#### Sort/Distribute/Cluster/Order By\n\n描述select子句中的ORDER BY, SORT BY, CLUSTER BY, 和DISTRIBUTE BY的语法。\n\n##### Order By语法\n\nHive QL中的Order By语法跟SQL语言中的ORDER BY类似。\n\n```\ncolOrder: ( ASC | DESC )\ncolNullOrder: (NULLS FIRST | NULLS LAST)           -- (Note: Available in Hive 2.1.0 and later)\norderBy: ORDER BY colName colOrder? colNullOrder? (',' colName colOrder? colNullOrder?)*\nquery: SELECT expression (',' expression)* FROM src orderBy\n```\n\n\"order by\"子句具有很多局限性，在严格模式(设置了`hive.mapred.mode=strict`)中，order by子句后需要跟上`limit`子句，若将`hive.mapred.mode`设置为`nonstrict`则不需要`limit`子句。原因是，为了将所有的记录排序，只能使用一个reducer，如果数据量太大，单个reducer将花费很长的时间才能执行完成。\n\n需要注意的是列由列名指定，则不是位置编号，可以在0.11.0及更新版本中使用配置`hive.groupby.orderby.position.alias`为`true`（默认为false）来启用位置编号。\n默认的排序顺序是升序（ASC）。\n在Hive 2.1.0及更高版本中，支持空排序，默认空排序顺序为ASC顺序是NULLS FIRST，而默认为空的倒序排列顺序是NULLS LAST。\n\n##### Sort By语法\n\nSort By语法跟SQL语言中的ORDER BY类似。\n\n```\ncolOrder: ( ASC | DESC )\nsortBy: SORT BY colName colOrder? (',' colName colOrder?)*\nquery: SELECT expression (',' expression)* FROM src sortBy\n```\nHive在将数据传递到reducer之前，使用sort by对行进行排序，排列顺序取决于列的类型，如果列是numeric类型，则按数值顺序排序，如果是string类型，则按字典顺序排序。\n\n##### Sort By和Order By的区别\n\n\"order by\"和\"sort by\"的区别在于，前者对所有输出进行排序，后者仅对一个reducer中的输出进行排序，如果存在多个reducer，sort by只能进行部分排序。\n\n注意：可能会对Sort By和CLUSTER BY的区别感到困惑，CLUSTER BY在有多个reducer的情况下，为了将数据均衡地分布数据，将数据按字段进行分区并排序。\n\n基本上，在每个reducer中的数据将会按照用户指定的字段进行排序。如下示例：\n\n```\nSELECT key, value FROM src SORT BY key ASC, value DESC\n```\n这个查询可能有2个reducer，输出分别是：\n\n```\n0   5\n0   3\n3   6\n9   1\n```\n```\n0   4\n0   3\n1   1\n2   5\n```\n\n在一次transform后，变量将会被认为是string类型，意味着数值型将按照字典序进行排序，为了克服这种情况，在使用sort by之前需要使用一个带有cast的子查询，如下：\n\n```\nFROM (FROM (FROM src\n            SELECT TRANSFORM(value)\n            USING 'mapper'\n            AS value, count) mapped\n      SELECT cast(value as double) AS value, cast(count as int) AS count\n      SORT BY value, count) sorted\nSELECT TRANSFORM(value, count)\nUSING 'reducer'\nAS whatever\n```\n\n##### Cluster By和Distribute By语法\n\nCluster By和Distribute By主要跟[Transform/Map-Reduce脚本](####Transform和map-reduce脚本)一起使用，但是有时候为了给后续的子查询分区并排序时，这是非常有用的。\nCluster By可以看作是Distribute By和Sort By的合集。\nHive使用Distribute By指定的列将数据分发到reducer中，相同的值将会放到同一个reducer中，但是Distribute By不保证clustering或sorting属性。\n\n例如，我们Distribute By X以下5行记录到2个reducer中：\n\n```\nx1\nx2\nx4\nx3\nx1\n```\nreducer 1\n\n```\nx1\nx2\nx1\n```\n\nreducer 2\n\n```\nx4\nx3\n```\nX相同的值x1分发到reducer1 中，但不能保存其在相邻位置。\n\n如果我们使用Cluster By x，这两个reducer将会进行进一步排序。\nreducer 1\n\n```\nx1\nx1\nx2\n```\n\nreducer 2\n\n```\nx3\nx4\n```\n\n可以使用Distribute By和Sort By来代替Cluster By，而且分区列和排序列可以是不同的列。\n\n```\nSELECT col1, col2 FROM t1 CLUSTER BY col1\n```\n\n```\nSELECT col1, col2 FROM t1 DISTRIBUTE BY col1\nSELECT col1, col2 FROM t1 DISTRIBUTE BY col1 SORT BY col1 ASC, col2 DESC\n```\n\n```\nFROM (\n  FROM pv_users\n  MAP ( pv_users.userid, pv_users.date )\n  USING 'map_script'\n  AS c1, c2, c3\n  DISTRIBUTE BY c2\n  SORT BY c2, c1) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE ( map_output.c1, map_output.c2, map_output.c3 )\n  USING 'reduce_script'\n  AS date, count;\n```\n\n#### Transform和map-reduce脚本\n\n用户可以指定自定义的mapper和reducer，例如，为了执行自定义的mapper-map_script和自定义的reducer-reducer_script，可以使用如下带有TRANSFORM子句的命令嵌入map和reduce脚本。\n\n默认情况下，在传输给自定义脚本时，列将会转换成string类型，并且以tab作为分隔符，同样的，为了区分空字符串，所有的NULL值将被转换成\\N字符。自定义脚本的标准输出是tab分隔的string列，任何包括\\N的值将被认为是NULL, string类型的结果将转换成表定义中的列类型。用户自定义脚本可以输出debug信息到标准错误，这将在Hadoop任务详细信息页面上显示。这些默认值可以被ROW FORMAT覆盖。\n\n在windows下，使用\"cmd /c your_script\"。\n\n```\n警告\n在transformation之前处理任意string列是你的责任，如果有string列包含tab，需要使用[REGEXP_REPLACE](https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-StringFunctions)并替换tab为其他字符。\n```\n\n```\n警告\n从形式上，MAP...和REDUCE...是SELECT TRANSFORM ( ... )的语法。换句话说，它们作为阅读查询语句的注释或说明。注意：使用这些关键字是危险的，如，输出\"REDUCE\" 不能强制转换成reduce，输出\"MAP\"不能强制转换成map。\n```\n另请参阅[ Sort By / Cluster By / Distribute By ](#### Sort/Distribute/Cluster/Order By)和[Larry Ogrodnek's的博客](http://dev.bizo.com/2009/10/hive-map-reduce-in-java.html)\n\n```\nclusterBy: CLUSTER BY colName (',' colName)*\ndistributeBy: DISTRIBUTE BY colName (',' colName)*\nsortBy: SORT BY colName (ASC | DESC)? (',' colName (ASC | DESC)?)*\n \nrowFormat\n  : ROW FORMAT\n    (DELIMITED [FIELDS TERMINATED BY char]\n               [COLLECTION ITEMS TERMINATED BY char]\n               [MAP KEYS TERMINATED BY char]\n               [ESCAPED BY char]\n               [LINES SEPARATED BY char]\n     |\n     SERDE serde_name [WITH SERDEPROPERTIES\n                            property_name=property_value,\n                            property_name=property_value, ...])\n \noutRowFormat : rowFormat\ninRowFormat : rowFormat\noutRecordReader : RECORDREADER className\n \nquery:\n  FROM (\n    FROM src\n    MAP expression (',' expression)*\n    (inRowFormat)?\n    USING 'my_map_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n    ( clusterBy? | distributeBy? sortBy? ) src_alias\n  )\n  REDUCE expression (',' expression)*\n    (inRowFormat)?\n    USING 'my_reduce_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n \n  FROM (\n    FROM src\n    SELECT TRANSFORM '(' expression (',' expression)* ')'\n    (inRowFormat)?\n    USING 'my_map_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n    ( clusterBy? | distributeBy? sortBy? ) src_alias\n  )\n  SELECT TRANSFORM '(' expression (',' expression)* ')'\n    (inRowFormat)?\n    USING 'my_reduce_script'\n    ( AS colName (',' colName)* )?\n    (outRowFormat)? (outRecordReader)?\n```\n\n标准SQL不支持TRANSFORM，TRANSFORM子句在Hive 0.13.0及[HIVE-6415](https://issues.apache.org/jira/browse/HIVE-6415)的后续版本中，通过配置[SQL standard based authorization](https://cwiki.apache.org/confluence/display/Hive/SQL+Standard+Based+Hive+Authorization)禁用。\n\nTRANSFORM示例：\n例1：\n\n```\nFROM (\n  FROM pv_users\n  MAP pv_users.userid, pv_users.date\n  USING 'map_script'\n  AS dt, uid\n  CLUSTER BY dt) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE map_output.dt, map_output.uid\n  USING 'reduce_script'\n  AS date, count;\nFROM (\n  FROM pv_users\n  SELECT TRANSFORM(pv_users.userid, pv_users.date)\n  USING 'map_script'\n  AS dt, uid\n  CLUSTER BY dt) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  SELECT TRANSFORM(map_output.dt, map_output.uid)\n  USING 'reduce_script'\n  AS date, count;\n```\n例2:\n\n```\nFROM (\n  FROM src\n  SELECT TRANSFORM(src.key, src.value) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'\n  USING '/bin/cat'\n  AS (tkey, tvalue) ROW FORMAT SERDE 'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'\n  RECORDREADER 'org.apache.hadoop.hive.contrib.util.typedbytes.TypedBytesRecordReader'\n) tmap\nINSERT OVERWRITE TABLE dest1 SELECT tkey, tvalue\n```\n\n##### 缺少schema的map-reduce脚本\n\n如果在USING my_script之后没有AS子句，Hive假定脚本的输出包括两个部分，key是第一个tab之前的部分，值是第一个tab之后的部分。注意这与指定AS key, value不同，因为在那种情况下，如果存在多个tab，value将仅包含第一个tab第二个tab之间的部分。\n\n注意我们可以直接使用CLUSTER BY key，而不在脚本中指定输出格式。\n\n```\nFROM (\n  FROM pv_users\n  MAP pv_users.userid, pv_users.date\n  USING 'map_script'\n  CLUSTER BY key) map_output\nINSERT OVERWRITE TABLE pv_users_reduced\n  REDUCE map_output.key, map_output.value\n  USING 'reduce_script'\n  AS date, count;\n```\n\n##### TRANSFORM的输出\n\n脚本的输出字段默认以string进行输入，例如：\n\n```\nSELECT TRANSFORM(stuff)\nUSING 'script'\nAS thing1, thing2\n```\n这将可以被强制转换为\n\n```\nSELECT TRANSFORM(stuff)\nUSING 'script'\nAS (thing1 INT, thing2 INT)\n```\n\n#### 操作符和用户自定义函数(UDFS)\n\n在Beeline或CLi下，使用如下命令来显示最近的文档：\n\n```\nSHOW FUNCTIONS;\nDESCRIBE FUNCTION <function_name>;\nDESCRIBE FUNCTION EXTENDED <function_name>;\n```\n\n```\n当UDF嵌套在UDF或function中时存在Bug。\n当 `hive.cache.expr.evaluation`设置为`true`（默认）时，UDF嵌套在UDF或function中将会产生不正确的结果。这个bug会影响0.12.0, 0.13.0和0.13.1。0.14.0修复了这个bug([HIVE-7314](https://issues.apache.org/jira/browse/HIVE-7314).\n这个问题与UDF的实现的getDisplayString方法有关，在Hive user mailing list中的相关[讨论](http://mail-archives.apache.org/mod_mbox/hive-user/201407.mbox/%3cCAEWg7THU-Pr1Dfv_A8VS3Uz5t3ZyJvL0f-bebg4Zb3hXkK-CGQ@mail.gmail.com%3e)\n```\n\n##### 内置操作符\n\n###### 关系运算符\n\n###### 算术运算符\n\n###### 逻辑运算符\n\n###### 复杂类型的运算符\n\n##### 内置函数\n\n###### \n\n###### \n\n###### \n\n###### \n\n###### \n\n##### 内置聚合函数\n\n##### 内置生成表函数\n\n##### Grouping and Sorting on\n\n##### UDF内部\n\n##### 创建自定义的UDF\n\n#### XPath专用函数\n\n#### Joins\n\n#### Join优化\n\n#### Union\n\n#### 横向视图\n\n### 子查询\n\n### 采样\n\n### 虚拟列\n\n### 窗口和分析函数\n\n### 增强聚合、多维数据集、分组和汇总\n\n## 程序语言：Hive HPL/SQL\n\n## 解释执行计划\n\n","slug":"hive-language-manual","published":1,"updated":"2016-08-21T06:07:15.000Z","_id":"ciruc8szc0000hgv0hf3e2msj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"数据操作语句\"><a href=\"#数据操作语句\" class=\"headerlink\" title=\"数据操作语句\"></a>数据操作语句</h1><h2 id=\"DML：装载，插入，更新，删除\"><a href=\"#DML：装载，插入，更新，删除\" class=\"headerlink\" title=\"DML：装载，插入，更新，删除\"></a>DML：装载，插入，更新，删除</h2><h2 id=\"导入-导出\"><a href=\"#导入-导出\" class=\"headerlink\" title=\"导入/导出\"></a>导入/导出</h2><h2 id=\"数据检索：查询\"><a href=\"#数据检索：查询\" class=\"headerlink\" title=\"数据检索：查询\"></a>数据检索：查询</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><h4 id=\"select语法\"><a href=\"#select语法\" class=\"headerlink\" title=\"select语法\"></a>select语法</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">WITH</span> CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting <span class=\"keyword\">with</span> Hive <span class=\"number\">0.13</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> [ALL | <span class=\"keyword\">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> table_reference</span><br><span class=\"line\">  [<span class=\"keyword\">WHERE</span> where_condition]</span><br><span class=\"line\">  [<span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  [<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  [CLUSTER <span class=\"keyword\">BY</span> col_list</span><br><span class=\"line\">    | [DISTRIBUTE <span class=\"keyword\">BY</span> col_list] [SORT <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  ]</span><br><span class=\"line\"> [LIMIT number]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>select语句可以是联合查询(union)的一部分或另一个查询的子查询。</li>\n<li>table_reference表示实际的查询对象，可以是一个普通表，一个视图，一个join或一个子查询。</li>\n<li>表名和列名不区分大小写。<ul>\n<li>在Hive 0.12和更早的版本中，表和列名中只允许字母数字和下划线。</li>\n<li>在Hive 0.13及更高版本中，列名可以包含任何Unicode字符（见<a href=\"https://issues.apache.org/jira/browse/HIVE-6013\" target=\"_blank\" rel=\"external\">HIVE-6013</a>），反引号（``）可指定的任何列名。可以使用双反引号（``）来表示一个反引号字符。</li>\n<li>要恢复到0.13.0版本以前的行为，并限制列的名称字母，数字和下划线字符，设置属性<code>hive.support.quoted.identifiers</code>为none。在此配置中，反引号(``)中的字符被解释为正则表达式。有关详细信息，请参阅<a href=\"https://issues.apache.org/jira/browse/HIVE-6013）。另见[正则表达式](#####正则表达式\" target=\"_blank\" rel=\"external\">Supporting Quoted Identifiers in Column Names</a>。</li>\n</ul>\n</li>\n<li>简单查询。例如，下面的查询检索所有列，并从表T1的所有行。</li>\n</ul>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> t1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意使用<span class=\"number\">0.13</span>及以上版本，<span class=\"keyword\">FROM</span>是可选的，如<span class=\"keyword\">select</span> <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前数据库（0.13及以上版本），使用current_database（）函数：</li>\n</ul>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT </span>current_database()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指定数据库，在表名前指定数据库名（”db_name.table_name”Hive 0.7开始）或在查询语句之前使用<code>use</code>语句。<br>“db_name.table_name”允许访问不同数据库的表。<br>use语句对之后所有的HiveQL语句生效，使用default重置为默认数据库。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> database_name;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> query_specifications;</span><br><span class=\"line\"><span class=\"keyword\">USE</span> <span class=\"keyword\">default</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"where子句\"><a href=\"#where子句\" class=\"headerlink\" title=\"where子句\"></a>where子句</h5><p>WHERE条件是一个布尔表达式。例如，下面的查询只返回美国区域数量大于10的销售记录。Hive的WHERE子句中支持许多<a href=\"####操作符和用户自定义函数(UDFS\">操作符和UDF</a>)。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sales <span class=\"keyword\">WHERE</span> amount &gt; <span class=\"number\">10</span> <span class=\"keyword\">AND</span> region = <span class=\"string\">\"US\"</span></span><br></pre></td></tr></table></figure>\n<p>0.13以上版本也支持在where子句中使用一些子查询。</p>\n<h5 id=\"all和distinct子句\"><a href=\"#all和distinct子句\" class=\"headerlink\" title=\"all和distinct子句\"></a>all和distinct子句</h5><p>ALL和DISTINCT选项指定重复的行是否应该返回。如果没有这些选项给出，默认是所有（返回所有匹配的行）。DISTINCT指定结果集中删除重复的行。注意：Hive从1.1.0版本开始支持<code>SELECT DISTINCT *</code>语句。<a href=\"https://issues.apache.org/jira/browse/HIVE-9194\" target=\"_blank\" rel=\"external\">HIVE-9194</a></p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">5</span></span><br><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> col1, col2 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">5</span></span><br><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> col1 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>ALL和DISTINCT也可以在UNION子句中使用-见<a href=\"####Union\">Union</a>以获取更多信息。</p>\n<h5 id=\"基于分区（partition）的查询\"><a href=\"#基于分区（partition）的查询\" class=\"headerlink\" title=\"基于分区（partition）的查询\"></a>基于分区（partition）的查询</h5><p>一般情况下，一个SELECT查询扫描整个表。如果一个表使用PARTITIONED BY子句创建，查询语句可以仅查询指定分区表的一小部分。Hive在where子句或Join子句中进行分区修剪，例如：表page_views使用列date进行分区，以下查询语句仅检索2008-03-01和2008-03-31之前的行。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> page_views.*</span><br><span class=\"line\">FROM page_views</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> page_views.<span class=\"built_in\">date</span> &gt;= <span class=\"string\">'2008-03-01'</span> <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &lt;= <span class=\"string\">'2008-03-31'</span></span><br></pre></td></tr></table></figure>\n<p>如果表page_views与表dim_users关联，可以像下面一样在on子句中指定分区范围。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> page_views.*</span><br><span class=\"line\">FROM page_views <span class=\"keyword\">JOIN</span> dim_users</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> (page_views.user_id = dim_users.id <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &gt;= <span class=\"string\">'2008-03-01'</span> <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &lt;= <span class=\"string\">'2008-03-31'</span>)</span><br></pre></td></tr></table></figure>\n<p>另见<a href=\"####Group By\">Group By</a>。</p>\n<p>另见<a href=\"#### Sort/Distribute/Cluster/Order By\">Sort By / Cluster By / Distribute By / Order By</a></p>\n<h5 id=\"having子句\"><a href=\"#having子句\" class=\"headerlink\" title=\"having子句\"></a>having子句</h5><p>Hive 0.7.0版本增加了对HAVING子句的支持。在旧版本中可以使用子查询达到同样的效果：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">HAVING</span> <span class=\"keyword\">SUM</span>(col2) &gt; <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1 <span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> col1, <span class=\"keyword\">SUM</span>(col2) <span class=\"keyword\">AS</span> col2sum <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col1) t2 <span class=\"keyword\">WHERE</span> t2.col2sum &gt; <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"limit子句\"><a href=\"#limit子句\" class=\"headerlink\" title=\"limit子句\"></a>limit子句</h5><p>限制指示要返回的行数。返回的行被随机选择。下面的查询从表T中随机返回1到5行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">LIMIT</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Top k查询，下面的语句返回Top 5的销售记录。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> mapred.reduce.tasks = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sales <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> amount <span class=\"keyword\">DESC</span> <span class=\"keyword\">LIMIT</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p><code>这个列子应该不对</code></p>\n<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5><p>0.13.0及更高版本中，如果配置了<code>hive.support.quoted.identifiers</code>为<code>none</code>，则在select语句支持查询基于正则表达式的列名。</p>\n<ul>\n<li>我们使用Java正则表达式的语法。尝试<a href=\"http://www.fileformat.info/tool/regex.htm\" target=\"_blank\" rel=\"external\">http://www.fileformat.info/tool/regex.htm</a>用于测试。</li>\n<li>下面的查询将选择所有ds或hr的列。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">`(ds|hr)?+.+`</span> <span class=\"keyword\">FROM</span> sales</span><br></pre></td></tr></table></figure>\n<h4 id=\"Group-By\"><a href=\"#Group-By\" class=\"headerlink\" title=\"Group By\"></a>Group By</h4><h5 id=\"Group-By语法\"><a href=\"#Group-By语法\" class=\"headerlink\" title=\"Group By语法\"></a>Group By语法</h5><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">group</span>ByClause: GROUP BY <span class=\"keyword\">group</span>ByExpression (, <span class=\"keyword\">group</span>ByExpression)*</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span>ByExpression: expression</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span>ByQuery: SELECT expression (, expression)* FROM src <span class=\"keyword\">group</span>ByClause?</span><br></pre></td></tr></table></figure>\n<p>在group by表达式中，列由名称指定，而不是列编号，在Hive 0.11及更高版本中，列可以通过位置指定。需要配置<code>hive.groupby.orderby.position.alias</code>为<code>true</code>（默认为<code>false</code>）。</p>\n<h5 id=\"简单例子\"><a href=\"#简单例子\" class=\"headerlink\" title=\"简单例子\"></a>简单例子</h5><p>为了计算表中的行数：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\" target=\"_blank\" rel=\"external\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<p>为了计算不同性别的用户数量，可以使用以下查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_sum</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span> (<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<p>多个聚合可以在同一时间内完成，但是，没有任何两个聚合可以使用不同的列。例如，以下是可能的，因为count(DISTINCT)和sum(DISTINCT)指定了相同的列：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_agg</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid), <span class=\"keyword\">count</span>(*), <span class=\"keyword\">sum</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\" target=\"_blank\" rel=\"external\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<p>如下查询是不允许的，在同一个查询中不允许使用多个DISTINCT表达式。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_agg</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid), <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.ip)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Select语句和group-by子句\"><a href=\"#Select语句和group-by子句\" class=\"headerlink\" title=\"Select语句和group by子句\"></a>Select语句和group by子句</h5><p>当使用group by子句，select语句只能包含列包括在GROUP BY子句。当然，有很多聚合功能（例如count）同样可以用在select子句中。<br>让我们以一个简单的例子：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE <span class=\"keyword\">TABLE</span> t1(a <span class=\"comment\">INTEGER, b INTGER)</span>;</span><br></pre></td></tr></table></figure>\n<p>一个使用上表的group by查询可能是这样的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   a,</span><br><span class=\"line\">   <span class=\"keyword\">sum</span>(b)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">   t1</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">   a;</span><br></pre></td></tr></table></figure>\n<p>上面的查询可以正常运行，因为select子句包括a(使用列a做group by)和一个聚合函数(sum(b))。<br>但是，下面的语句不能运行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   a,</span><br><span class=\"line\">   b</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">   t1</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">   a;</span><br></pre></td></tr></table></figure></p>\n<p>因为select子句中有一个未包含在group by子句中的附加列(列 b)，也不是一个聚合函数。这是因为，如果表是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>1</td>\n</tr>\n<tr>\n<td>100</td>\n<td>2</td>\n</tr>\n<tr>\n<td>100</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>由于仅在a上进行了组合，那么在组a=100中，b应该显示为什么值呢？人们可以说，它应该是第一个值或最​低值，但我们都同意，有多种可能的选择。Hive抛弃了这种猜测，认为在select子句中拥有group by子句中不存在的列是无效的SQL(准确地说，是HQL)。</p>\n<h5 id=\"高级功能\"><a href=\"#高级功能\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h5><h6 id=\"多组插入\"><a href=\"#多组插入\" class=\"headerlink\" title=\"多组插入\"></a>多组插入</h6><p>聚合或简单查询的结果可以输出到多个表甚至是hdfs(使用hdfs操作)上，例如，在按性别分类的同时，有一个需求是按年龄分类。一个可行的查询是这样的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM pv_users</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_sum</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\">  <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">DIRECTORY</span> <span class=\"string\">'/user/facebook/tmp/pv_age_sum'</span></span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> pv_users.age, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\">  <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.age;</span><br></pre></td></tr></table></figure>\n<h6 id=\"map端聚合\"><a href=\"#map端聚合\" class=\"headerlink\" title=\"map端聚合\"></a>map端聚合</h6><p>hive.map.aggr控制我们如何做聚合，默认为false，如果它被设置为true，Hive将在map任务直接做的第一级集合。<br>这通常提供了更好的效率，但可能需要更多的内存来运行工作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> hive.map.aggr=<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\" target=\"_blank\" rel=\"external\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<h6 id=\"Grouping-Sets-Cubes-Rollups-和GROUPING-ID函数\"><a href=\"#Grouping-Sets-Cubes-Rollups-和GROUPING-ID函数\" class=\"headerlink\" title=\"Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数\"></a>Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数</h6><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本：</span><br><span class=\"line\">rouping <span class=\"keyword\">sets</span>, CUBE <span class=\"comment\">and ROLLUP</span>操作符<span class=\"comment\">,</span>和<span class=\"comment\">GROUPING__ID</span>函数在<span class=\"comment\">Hive 0.10.0</span>版本中加入。</span><br></pre></td></tr></table></figure>\n<p>见<a href=\"###增强聚合、多维数据集、分组和汇总\">增强聚合，多维数据集，分组和汇总</a>获取有关这些聚合操作的详细信息。</p>\n<p>另见JIRAs：<br><a href=\"https://issues.apache.org/jira/browse/HIVE-2397\" target=\"_blank\" rel=\"external\">HIVE-2397</a>group by支持rollup选项<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3433\" target=\"_blank\" rel=\"external\">HIVE-3433</a>实现CUBE和ROLLUP操作符<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3471\" target=\"_blank\" rel=\"external\">HIVE-3471</a>实现Hive sets分组集<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3613\" target=\"_blank\" rel=\"external\">HIVE-3613</a>实现GROUPING_ID函数</p>\n<h4 id=\"Sort-Distribute-Cluster-Order-By\"><a href=\"#Sort-Distribute-Cluster-Order-By\" class=\"headerlink\" title=\"Sort/Distribute/Cluster/Order By\"></a>Sort/Distribute/Cluster/Order By</h4><p>描述select子句中的ORDER BY, SORT BY, CLUSTER BY, 和DISTRIBUTE BY的语法。</p>\n<h5 id=\"Order-By语法\"><a href=\"#Order-By语法\" class=\"headerlink\" title=\"Order By语法\"></a>Order By语法</h5><p>Hive QL中的Order By语法跟SQL语言中的ORDER BY类似。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colOrder: ( <span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span> )</span><br><span class=\"line\">colNullOrder: (NULLS FIRST | NULLS LAST)           -- (Note: Available <span class=\"keyword\">in</span> Hive <span class=\"number\">2.1</span>.<span class=\"number\">0</span> <span class=\"keyword\">and</span> later)</span><br><span class=\"line\">orderBy: <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> colName colOrder? colNullOrder? (<span class=\"string\">','</span> colName colOrder? colNullOrder?)*</span><br><span class=\"line\">query: <span class=\"keyword\">SELECT</span> expression (<span class=\"string\">','</span> expression)* <span class=\"keyword\">FROM</span> src orderBy</span><br></pre></td></tr></table></figure>\n<p>“order by”子句具有很多局限性，在严格模式(设置了<code>hive.mapred.mode=strict</code>)中，order by子句后需要跟上<code>limit</code>子句，若将<code>hive.mapred.mode</code>设置为<code>nonstrict</code>则不需要<code>limit</code>子句。原因是，为了将所有的记录排序，只能使用一个reducer，如果数据量太大，单个reducer将花费很长的时间才能执行完成。</p>\n<p>需要注意的是列由列名指定，则不是位置编号，可以在0.11.0及更新版本中使用配置<code>hive.groupby.orderby.position.alias</code>为<code>true</code>（默认为false）来启用位置编号。<br>默认的排序顺序是升序（ASC）。<br>在Hive 2.1.0及更高版本中，支持空排序，默认空排序顺序为ASC顺序是NULLS FIRST，而默认为空的倒序排列顺序是NULLS LAST。</p>\n<h5 id=\"Sort-By语法\"><a href=\"#Sort-By语法\" class=\"headerlink\" title=\"Sort By语法\"></a>Sort By语法</h5><p>Sort By语法跟SQL语言中的ORDER BY类似。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colOrder: ( <span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span> )</span><br><span class=\"line\">sortBy: SORT <span class=\"keyword\">BY</span> colName colOrder? (<span class=\"string\">','</span> colName colOrder?)*</span><br><span class=\"line\">query: <span class=\"keyword\">SELECT</span> expression (<span class=\"string\">','</span> expression)* <span class=\"keyword\">FROM</span> src sortBy</span><br></pre></td></tr></table></figure>\n<p>Hive在将数据传递到reducer之前，使用sort by对行进行排序，排列顺序取决于列的类型，如果列是numeric类型，则按数值顺序排序，如果是string类型，则按字典顺序排序。</p>\n<h5 id=\"Sort-By和Order-By的区别\"><a href=\"#Sort-By和Order-By的区别\" class=\"headerlink\" title=\"Sort By和Order By的区别\"></a>Sort By和Order By的区别</h5><p>“order by”和”sort by”的区别在于，前者对所有输出进行排序，后者仅对一个reducer中的输出进行排序，如果存在多个reducer，sort by只能进行部分排序。</p>\n<p>注意：可能会对Sort By和CLUSTER BY的区别感到困惑，CLUSTER BY在有多个reducer的情况下，为了将数据均衡地分布数据，将数据按字段进行分区并排序。</p>\n<p>基本上，在每个reducer中的数据将会按照用户指定的字段进行排序。如下示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">key</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">FROM</span> src <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">key</span> <span class=\"keyword\">ASC</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<p>这个查询可能有2个reducer，输出分别是：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"symbol\">3 </span>  <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"symbol\">9 </span>  <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"symbol\">1 </span>  <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"symbol\">2 </span>  <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>在一次transform后，变量将会被认为是string类型，意味着数值型将按照字典序进行排序，为了克服这种情况，在使用sort by之前需要使用一个带有cast的子查询，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (FROM (FROM src</span><br><span class=\"line\">            <span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">value</span>)</span><br><span class=\"line\">            <span class=\"keyword\">USING</span> <span class=\"string\">'mapper'</span></span><br><span class=\"line\">            <span class=\"keyword\">AS</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>) mapped</span><br><span class=\"line\">      <span class=\"keyword\">SELECT</span> <span class=\"keyword\">cast</span>(<span class=\"keyword\">value</span> <span class=\"keyword\">as</span> <span class=\"keyword\">double</span>) <span class=\"keyword\">AS</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">cast</span>(<span class=\"keyword\">count</span> <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>) <span class=\"keyword\">AS</span> <span class=\"keyword\">count</span></span><br><span class=\"line\">      <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>) sorted</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'reducer'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> whatever</span><br></pre></td></tr></table></figure>\n<h5 id=\"Cluster-By和Distribute-By语法\"><a href=\"#Cluster-By和Distribute-By语法\" class=\"headerlink\" title=\"Cluster By和Distribute By语法\"></a>Cluster By和Distribute By语法</h5><p>Cluster By和Distribute By主要跟<a href=\"####Transform和map-reduce脚本\">Transform/Map-Reduce脚本</a>一起使用，但是有时候为了给后续的子查询分区并排序时，这是非常有用的。<br>Cluster By可以看作是Distribute By和Sort By的合集。<br>Hive使用Distribute By指定的列将数据分发到reducer中，相同的值将会放到同一个reducer中，但是Distribute By不保证clustering或sorting属性。</p>\n<p>例如，我们Distribute By X以下5行记录到2个reducer中：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x2</span><br><span class=\"line\">x4</span><br><span class=\"line\">x3</span><br><span class=\"line\">x1</span><br></pre></td></tr></table></figure>\n<p>reducer 1</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x2</span><br><span class=\"line\">x1</span><br></pre></td></tr></table></figure>\n<p>reducer 2</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x4</span></span><br><span class=\"line\">x3</span><br></pre></td></tr></table></figure>\n<p>X相同的值x1分发到reducer1 中，但不能保存其在相邻位置。</p>\n<p>如果我们使用Cluster By x，这两个reducer将会进行进一步排序。<br>reducer 1</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x1</span><br><span class=\"line\">x2</span><br></pre></td></tr></table></figure>\n<p>reducer 2</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x3</span></span><br><span class=\"line\">x4</span><br></pre></td></tr></table></figure>\n<p>可以使用Distribute By和Sort By来代替Cluster By，而且分区列和排序列可以是不同的列。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 CLUSTER <span class=\"keyword\">BY</span> col1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">DISTRIBUTE</span> <span class=\"keyword\">BY</span> col1</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">DISTRIBUTE</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">ASC</span>, col2 <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP ( pv_users.userid, pv_users.<span class=\"built_in\">date</span> )</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> c1, c2, c3</span><br><span class=\"line\">  DISTRIBUTE <span class=\"keyword\">BY</span> c2</span><br><span class=\"line\">  SORT <span class=\"keyword\">BY</span> c2, c1) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE ( map_output.c1, map_output.c2, map_output.c3 )</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Transform和map-reduce脚本\"><a href=\"#Transform和map-reduce脚本\" class=\"headerlink\" title=\"Transform和map-reduce脚本\"></a>Transform和map-reduce脚本</h4><p>用户可以指定自定义的mapper和reducer，例如，为了执行自定义的mapper-map_script和自定义的reducer-reducer_script，可以使用如下带有TRANSFORM子句的命令嵌入map和reduce脚本。</p>\n<p>默认情况下，在传输给自定义脚本时，列将会转换成string类型，并且以tab作为分隔符，同样的，为了区分空字符串，所有的NULL值将被转换成\\N字符。自定义脚本的标准输出是tab分隔的string列，任何包括\\N的值将被认为是NULL, string类型的结果将转换成表定义中的列类型。用户自定义脚本可以输出debug信息到标准错误，这将在Hadoop任务详细信息页面上显示。这些默认值可以被ROW FORMAT覆盖。</p>\n<p>在windows下，使用”cmd /c your_script”。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告</span><br><span class=\"line\">在transformation之前处理任意string列是你的责任，如果有string列包含tab，需要使用[<span class=\"string\">REGEXP_REPLACE</span>](<span class=\"link\">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-StringFunctions</span>)并替换tab为其他字符。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告</span><br><span class=\"line\">从形式上，<span class=\"built_in\">MAP</span><span class=\"attr\">...</span>和REDUCE<span class=\"attr\">...</span>是<span class=\"keyword\">SELECT</span> TRANSFORM ( <span class=\"attr\">...</span> )的语法。换句话说，它们作为阅读查询语句的注释或说明。注意：使用这些关键字是危险的，如，输出<span class=\"string\">\"REDUCE\"</span> 不能强制转换成reduce，输出<span class=\"string\">\"MAP\"</span>不能强制转换成<span class=\"built_in\">map</span>。</span><br></pre></td></tr></table></figure>\n<p>另请参阅<a href=\"#### Sort/Distribute/Cluster/Order By\"> Sort By / Cluster By / Distribute By </a>和<a href=\"http://dev.bizo.com/2009/10/hive-map-reduce-in-java.html\" target=\"_blank\" rel=\"external\">Larry Ogrodnek’s的博客</a></p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clusterBy: CLUSTER <span class=\"keyword\">BY</span> colName (<span class=\"string\">','</span> colName)*</span><br><span class=\"line\">distributeBy: DISTRIBUTE <span class=\"keyword\">BY</span> colName (<span class=\"string\">','</span> colName)*</span><br><span class=\"line\">sortBy: SORT <span class=\"keyword\">BY</span> colName (<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>)? (<span class=\"string\">','</span> colName (<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>)?)*</span><br><span class=\"line\"> </span><br><span class=\"line\">rowFormat</span><br><span class=\"line\">  : ROW FORMAT</span><br><span class=\"line\">    (DELIMITED [FIELDS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [COLLECTION ITEMS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [MAP KEYS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [ESCAPED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [LINES SEPARATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">     |</span><br><span class=\"line\">     SERDE serde_name [<span class=\"keyword\">WITH</span> SERDEPROPERTIES</span><br><span class=\"line\">                            property_name=property_value,</span><br><span class=\"line\">                            property_name=property_value, ...])</span><br><span class=\"line\"> </span><br><span class=\"line\">outRowFormat : rowFormat</span><br><span class=\"line\">inRowFormat : rowFormat</span><br><span class=\"line\">outRecordReader : RECORDREADER className</span><br><span class=\"line\"> </span><br><span class=\"line\">query:</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> src</span><br><span class=\"line\">    MAP expression (<span class=\"string\">','</span> expression)*</span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_map_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\">    ( clusterBy? | distributeBy? sortBy? ) src_alias</span><br><span class=\"line\">  )</span><br><span class=\"line\">  REDUCE expression (<span class=\"string\">','</span> expression)*</span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_reduce_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> src</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> TRANSFORM <span class=\"string\">'('</span> expression (<span class=\"string\">','</span> expression)* <span class=\"string\">')'</span></span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_map_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\">    ( clusterBy? | distributeBy? sortBy? ) src_alias</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM <span class=\"string\">'('</span> expression (<span class=\"string\">','</span> expression)* <span class=\"string\">')'</span></span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_reduce_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br></pre></td></tr></table></figure>\n<p>标准SQL不支持TRANSFORM，TRANSFORM子句在Hive 0.13.0及<a href=\"https://issues.apache.org/jira/browse/HIVE-6415\" target=\"_blank\" rel=\"external\">HIVE-6415</a>的后续版本中，通过配置<a href=\"https://cwiki.apache.org/confluence/display/Hive/SQL+Standard+Based+Hive+Authorization\" target=\"_blank\" rel=\"external\">SQL standard based authorization</a>禁用。</p>\n<p>TRANSFORM示例：<br>例1：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP pv_users.userid, pv_users.<span class=\"built_in\">date</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> dt, uid</span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> dt) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE map_output.dt, map_output.uid</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(pv_users.userid, pv_users.<span class=\"built_in\">date</span>)</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> dt, uid</span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> dt) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(map_output.dt, map_output.uid)</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<p>例2:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (</span><br><span class=\"line\">  FROM src</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(src.key, src.value) <span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> SERDE <span class=\"string\">'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"string\">'/bin/cat'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> (tkey, tvalue) <span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> SERDE <span class=\"string\">'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'</span></span><br><span class=\"line\">  RECORDREADER <span class=\"string\">'org.apache.hadoop.hive.contrib.util.typedbytes.TypedBytesRecordReader'</span></span><br><span class=\"line\">) tmap</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> dest1 <span class=\"keyword\">SELECT</span> tkey, tvalue</span><br></pre></td></tr></table></figure>\n<h5 id=\"缺少schema的map-reduce脚本\"><a href=\"#缺少schema的map-reduce脚本\" class=\"headerlink\" title=\"缺少schema的map-reduce脚本\"></a>缺少schema的map-reduce脚本</h5><p>如果在USING my_script之后没有AS子句，Hive假定脚本的输出包括两个部分，key是第一个tab之前的部分，值是第一个tab之后的部分。注意这与指定AS key, value不同，因为在那种情况下，如果存在多个tab，value将仅包含第一个tab第二个tab之间的部分。</p>\n<p>注意我们可以直接使用CLUSTER BY key，而不在脚本中指定输出格式。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP pv_users.userid, pv_users.<span class=\"built_in\">date</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> <span class=\"keyword\">key</span>) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE map_output.<span class=\"keyword\">key</span>, map_output.value</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TRANSFORM的输出\"><a href=\"#TRANSFORM的输出\" class=\"headerlink\" title=\"TRANSFORM的输出\"></a>TRANSFORM的输出</h5><p>脚本的输出字段默认以string进行输入，例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">stuff</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'script'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> thing1, thing2</span><br></pre></td></tr></table></figure>\n<p>这将可以被强制转换为</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">stuff</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'script'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> (thing1 <span class=\"built_in\">INT</span>, thing2 <span class=\"built_in\">INT</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作符和用户自定义函数-UDFS\"><a href=\"#操作符和用户自定义函数-UDFS\" class=\"headerlink\" title=\"操作符和用户自定义函数(UDFS)\"></a>操作符和用户自定义函数(UDFS)</h4><p>在Beeline或CLi下，使用如下命令来显示最近的文档：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> FUNCTIONS;</span><br><span class=\"line\"><span class=\"keyword\">DESCRIBE</span> <span class=\"keyword\">FUNCTION</span> &lt;function_name&gt;;</span><br><span class=\"line\"><span class=\"keyword\">DESCRIBE</span> <span class=\"keyword\">FUNCTION</span> <span class=\"keyword\">EXTENDED</span> &lt;function_name&gt;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当UDF嵌套在UDF或function中时存在Bug。</span><br><span class=\"line\">当 <span class=\"code\">`hive.cache.expr.evaluation`</span>设置为<span class=\"code\">`true`</span>（默认）时，UDF嵌套在UDF或function中将会产生不正确的结果。这个bug会影响0.12.0, 0.13.0和0.13.1。0.14.0修复了这个bug([<span class=\"string\">HIVE-7314</span>](<span class=\"link\">https://issues.apache.org/jira/browse/HIVE-7314</span>).</span><br><span class=\"line\">这个问题与UDF的实现的getDisplayString方法有关，在Hive user mailing list中的相关[<span class=\"string\">讨论</span>](<span class=\"link\">http://mail-archives.apache.org/mod_mbox/hive-user/201407.mbox/%3cCAEWg7THU-Pr1Dfv_A8VS3Uz5t3ZyJvL0f-bebg4Zb3hXkK-CGQ@mail.gmail.com%3e</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"内置操作符\"><a href=\"#内置操作符\" class=\"headerlink\" title=\"内置操作符\"></a>内置操作符</h5><h6 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h6><h6 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h6><h6 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h6><h6 id=\"复杂类型的运算符\"><a href=\"#复杂类型的运算符\" class=\"headerlink\" title=\"复杂类型的运算符\"></a>复杂类型的运算符</h6><h5 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h5><p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<h5 id=\"内置聚合函数\"><a href=\"#内置聚合函数\" class=\"headerlink\" title=\"内置聚合函数\"></a>内置聚合函数</h5><h5 id=\"内置生成表函数\"><a href=\"#内置生成表函数\" class=\"headerlink\" title=\"内置生成表函数\"></a>内置生成表函数</h5><h5 id=\"Grouping-and-Sorting-on\"><a href=\"#Grouping-and-Sorting-on\" class=\"headerlink\" title=\"Grouping and Sorting on\"></a>Grouping and Sorting on</h5><h5 id=\"UDF内部\"><a href=\"#UDF内部\" class=\"headerlink\" title=\"UDF内部\"></a>UDF内部</h5><h5 id=\"创建自定义的UDF\"><a href=\"#创建自定义的UDF\" class=\"headerlink\" title=\"创建自定义的UDF\"></a>创建自定义的UDF</h5><h4 id=\"XPath专用函数\"><a href=\"#XPath专用函数\" class=\"headerlink\" title=\"XPath专用函数\"></a>XPath专用函数</h4><h4 id=\"Joins\"><a href=\"#Joins\" class=\"headerlink\" title=\"Joins\"></a>Joins</h4><h4 id=\"Join优化\"><a href=\"#Join优化\" class=\"headerlink\" title=\"Join优化\"></a>Join优化</h4><h4 id=\"Union\"><a href=\"#Union\" class=\"headerlink\" title=\"Union\"></a>Union</h4><h4 id=\"横向视图\"><a href=\"#横向视图\" class=\"headerlink\" title=\"横向视图\"></a>横向视图</h4><h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><h3 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h3><h3 id=\"虚拟列\"><a href=\"#虚拟列\" class=\"headerlink\" title=\"虚拟列\"></a>虚拟列</h3><h3 id=\"窗口和分析函数\"><a href=\"#窗口和分析函数\" class=\"headerlink\" title=\"窗口和分析函数\"></a>窗口和分析函数</h3><h3 id=\"增强聚合、多维数据集、分组和汇总\"><a href=\"#增强聚合、多维数据集、分组和汇总\" class=\"headerlink\" title=\"增强聚合、多维数据集、分组和汇总\"></a>增强聚合、多维数据集、分组和汇总</h3><h2 id=\"程序语言：Hive-HPL-SQL\"><a href=\"#程序语言：Hive-HPL-SQL\" class=\"headerlink\" title=\"程序语言：Hive HPL/SQL\"></a>程序语言：Hive HPL/SQL</h2><h2 id=\"解释执行计划\"><a href=\"#解释执行计划\" class=\"headerlink\" title=\"解释执行计划\"></a>解释执行计划</h2>","excerpt":"","more":"<h1 id=\"数据操作语句\"><a href=\"#数据操作语句\" class=\"headerlink\" title=\"数据操作语句\"></a>数据操作语句</h1><h2 id=\"DML：装载，插入，更新，删除\"><a href=\"#DML：装载，插入，更新，删除\" class=\"headerlink\" title=\"DML：装载，插入，更新，删除\"></a>DML：装载，插入，更新，删除</h2><h2 id=\"导入-导出\"><a href=\"#导入-导出\" class=\"headerlink\" title=\"导入/导出\"></a>导入/导出</h2><h2 id=\"数据检索：查询\"><a href=\"#数据检索：查询\" class=\"headerlink\" title=\"数据检索：查询\"></a>数据检索：查询</h2><h3 id=\"select\"><a href=\"#select\" class=\"headerlink\" title=\"select\"></a>select</h3><h4 id=\"select语法\"><a href=\"#select语法\" class=\"headerlink\" title=\"select语法\"></a>select语法</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"keyword\">WITH</span> CommonTableExpression (, CommonTableExpression)*]    (Note: Only available starting <span class=\"keyword\">with</span> Hive <span class=\"number\">0.13</span>.<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> [ALL | <span class=\"keyword\">DISTINCT</span>] select_expr, select_expr, ...</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> table_reference</span><br><span class=\"line\">  [<span class=\"keyword\">WHERE</span> where_condition]</span><br><span class=\"line\">  [<span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  [<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  [CLUSTER <span class=\"keyword\">BY</span> col_list</span><br><span class=\"line\">    | [DISTRIBUTE <span class=\"keyword\">BY</span> col_list] [SORT <span class=\"keyword\">BY</span> col_list]</span><br><span class=\"line\">  ]</span><br><span class=\"line\"> [LIMIT number]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>select语句可以是联合查询(union)的一部分或另一个查询的子查询。</li>\n<li>table_reference表示实际的查询对象，可以是一个普通表，一个视图，一个join或一个子查询。</li>\n<li>表名和列名不区分大小写。<ul>\n<li>在Hive 0.12和更早的版本中，表和列名中只允许字母数字和下划线。</li>\n<li>在Hive 0.13及更高版本中，列名可以包含任何Unicode字符（见<a href=\"https://issues.apache.org/jira/browse/HIVE-6013\">HIVE-6013</a>），反引号（``）可指定的任何列名。可以使用双反引号（``）来表示一个反引号字符。</li>\n<li>要恢复到0.13.0版本以前的行为，并限制列的名称字母，数字和下划线字符，设置属性<code>hive.support.quoted.identifiers</code>为none。在此配置中，反引号(``)中的字符被解释为正则表达式。有关详细信息，请参阅<a href=\"https://issues.apache.org/jira/browse/HIVE-6013）。另见[正则表达式](#####正则表达式\">Supporting Quoted Identifiers in Column Names</a>。</li>\n</ul>\n</li>\n<li>简单查询。例如，下面的查询检索所有列，并从表T1的所有行。</li>\n</ul>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> t1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意使用<span class=\"number\">0.13</span>及以上版本，<span class=\"keyword\">FROM</span>是可选的，如<span class=\"keyword\">select</span> <span class=\"number\">1</span> + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>获取当前数据库（0.13及以上版本），使用current_database（）函数：</li>\n</ul>\n<figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT </span>current_database()</span><br></pre></td></tr></table></figure>\n<ul>\n<li>指定数据库，在表名前指定数据库名（”db_name.table_name”Hive 0.7开始）或在查询语句之前使用<code>use</code>语句。<br>“db_name.table_name”允许访问不同数据库的表。<br>use语句对之后所有的HiveQL语句生效，使用default重置为默认数据库。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> database_name;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> query_specifications;</span><br><span class=\"line\"><span class=\"keyword\">USE</span> <span class=\"keyword\">default</span>;</span><br></pre></td></tr></table></figure>\n<h5 id=\"where子句\"><a href=\"#where子句\" class=\"headerlink\" title=\"where子句\"></a>where子句</h5><p>WHERE条件是一个布尔表达式。例如，下面的查询只返回美国区域数量大于10的销售记录。Hive的WHERE子句中支持许多<a href=\"####操作符和用户自定义函数(UDFS\">操作符和UDF</a>)。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sales <span class=\"keyword\">WHERE</span> amount &gt; <span class=\"number\">10</span> <span class=\"keyword\">AND</span> region = <span class=\"string\">\"US\"</span></span><br></pre></td></tr></table></figure>\n<p>0.13以上版本也支持在where子句中使用一些子查询。</p>\n<h5 id=\"all和distinct子句\"><a href=\"#all和distinct子句\" class=\"headerlink\" title=\"all和distinct子句\"></a>all和distinct子句</h5><p>ALL和DISTINCT选项指定重复的行是否应该返回。如果没有这些选项给出，默认是所有（返回所有匹配的行）。DISTINCT指定结果集中删除重复的行。注意：Hive从1.1.0版本开始支持<code>SELECT DISTINCT *</code>语句。<a href=\"https://issues.apache.org/jira/browse/HIVE-9194\">HIVE-9194</a></p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">5</span></span><br><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> col1, col2 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"number\">1</span> <span class=\"number\">4</span></span><br><span class=\"line\">    <span class=\"number\">2</span> <span class=\"number\">5</span></span><br><span class=\"line\">hive&gt; <span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> col1 <span class=\"keyword\">FROM</span> t1</span><br><span class=\"line\">    <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n<p>ALL和DISTINCT也可以在UNION子句中使用-见<a href=\"####Union\">Union</a>以获取更多信息。</p>\n<h5 id=\"基于分区（partition）的查询\"><a href=\"#基于分区（partition）的查询\" class=\"headerlink\" title=\"基于分区（partition）的查询\"></a>基于分区（partition）的查询</h5><p>一般情况下，一个SELECT查询扫描整个表。如果一个表使用PARTITIONED BY子句创建，查询语句可以仅查询指定分区表的一小部分。Hive在where子句或Join子句中进行分区修剪，例如：表page_views使用列date进行分区，以下查询语句仅检索2008-03-01和2008-03-31之前的行。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> page_views.*</span><br><span class=\"line\">FROM page_views</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> page_views.<span class=\"built_in\">date</span> &gt;= <span class=\"string\">'2008-03-01'</span> <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &lt;= <span class=\"string\">'2008-03-31'</span></span><br></pre></td></tr></table></figure>\n<p>如果表page_views与表dim_users关联，可以像下面一样在on子句中指定分区范围。</p>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> page_views.*</span><br><span class=\"line\">FROM page_views <span class=\"keyword\">JOIN</span> dim_users</span><br><span class=\"line\">  <span class=\"keyword\">ON</span> (page_views.user_id = dim_users.id <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &gt;= <span class=\"string\">'2008-03-01'</span> <span class=\"keyword\">AND</span> page_views.<span class=\"built_in\">date</span> &lt;= <span class=\"string\">'2008-03-31'</span>)</span><br></pre></td></tr></table></figure>\n<p>另见<a href=\"####Group By\">Group By</a>。</p>\n<p>另见<a href=\"#### Sort/Distribute/Cluster/Order By\">Sort By / Cluster By / Distribute By / Order By</a></p>\n<h5 id=\"having子句\"><a href=\"#having子句\" class=\"headerlink\" title=\"having子句\"></a>having子句</h5><p>Hive 0.7.0版本增加了对HAVING子句的支持。在旧版本中可以使用子查询达到同样的效果：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">HAVING</span> <span class=\"keyword\">SUM</span>(col2) &gt; <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1 <span class=\"keyword\">FROM</span> (<span class=\"keyword\">SELECT</span> col1, <span class=\"keyword\">SUM</span>(col2) <span class=\"keyword\">AS</span> col2sum <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> col1) t2 <span class=\"keyword\">WHERE</span> t2.col2sum &gt; <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"limit子句\"><a href=\"#limit子句\" class=\"headerlink\" title=\"limit子句\"></a>limit子句</h5><p>限制指示要返回的行数。返回的行被随机选择。下面的查询从表T中随机返回1到5行。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">LIMIT</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>Top k查询，下面的语句返回Top 5的销售记录。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> mapred.reduce.tasks = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> sales <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> amount <span class=\"keyword\">DESC</span> <span class=\"keyword\">LIMIT</span> <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p><code>这个列子应该不对</code></p>\n<h5 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h5><p>0.13.0及更高版本中，如果配置了<code>hive.support.quoted.identifiers</code>为<code>none</code>，则在select语句支持查询基于正则表达式的列名。</p>\n<ul>\n<li>我们使用Java正则表达式的语法。尝试<a href=\"http://www.fileformat.info/tool/regex.htm\">http://www.fileformat.info/tool/regex.htm</a>用于测试。</li>\n<li>下面的查询将选择所有ds或hr的列。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"string\">`(ds|hr)?+.+`</span> <span class=\"keyword\">FROM</span> sales</span><br></pre></td></tr></table></figure>\n<h4 id=\"Group-By\"><a href=\"#Group-By\" class=\"headerlink\" title=\"Group By\"></a>Group By</h4><h5 id=\"Group-By语法\"><a href=\"#Group-By语法\" class=\"headerlink\" title=\"Group By语法\"></a>Group By语法</h5><figure class=\"highlight pf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">group</span>ByClause: GROUP BY <span class=\"keyword\">group</span>ByExpression (, <span class=\"keyword\">group</span>ByExpression)*</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span>ByExpression: expression</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">group</span>ByQuery: SELECT expression (, expression)* FROM src <span class=\"keyword\">group</span>ByClause?</span><br></pre></td></tr></table></figure>\n<p>在group by表达式中，列由名称指定，而不是列编号，在Hive 0.11及更高版本中，列可以通过位置指定。需要配置<code>hive.groupby.orderby.position.alias</code>为<code>true</code>（默认为<code>false</code>）。</p>\n<h5 id=\"简单例子\"><a href=\"#简单例子\" class=\"headerlink\" title=\"简单例子\"></a>简单例子</h5><p>为了计算表中的行数：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<p>为了计算不同性别的用户数量，可以使用以下查询。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_sum</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span> (<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<p>多个聚合可以在同一时间内完成，但是，没有任何两个聚合可以使用不同的列。例如，以下是可能的，因为count(DISTINCT)和sum(DISTINCT)指定了相同的列：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_agg</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid), <span class=\"keyword\">count</span>(*), <span class=\"keyword\">sum</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<p>如下查询是不允许的，在同一个查询中不允许使用多个DISTINCT表达式。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_agg</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid), <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.ip)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender;</span><br></pre></td></tr></table></figure>\n<h5 id=\"Select语句和group-by子句\"><a href=\"#Select语句和group-by子句\" class=\"headerlink\" title=\"Select语句和group by子句\"></a>Select语句和group by子句</h5><p>当使用group by子句，select语句只能包含列包括在GROUP BY子句。当然，有很多聚合功能（例如count）同样可以用在select子句中。<br>让我们以一个简单的例子：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE <span class=\"keyword\">TABLE</span> t1(a <span class=\"comment\">INTEGER, b INTGER)</span>;</span><br></pre></td></tr></table></figure>\n<p>一个使用上表的group by查询可能是这样的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   a,</span><br><span class=\"line\">   <span class=\"keyword\">sum</span>(b)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">   t1</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">   a;</span><br></pre></td></tr></table></figure>\n<p>上面的查询可以正常运行，因为select子句包括a(使用列a做group by)和一个聚合函数(sum(b))。<br>但是，下面的语句不能运行：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">   a,</span><br><span class=\"line\">   b</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">   t1</span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">   a;</span><br></pre></td></tr></table></figure></p>\n<p>因为select子句中有一个未包含在group by子句中的附加列(列 b)，也不是一个聚合函数。这是因为，如果表是这样的：</p>\n<table>\n<thead>\n<tr>\n<th>a</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>100</td>\n<td>1</td>\n</tr>\n<tr>\n<td>100</td>\n<td>2</td>\n</tr>\n<tr>\n<td>100</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>由于仅在a上进行了组合，那么在组a=100中，b应该显示为什么值呢？人们可以说，它应该是第一个值或最​低值，但我们都同意，有多种可能的选择。Hive抛弃了这种猜测，认为在select子句中拥有group by子句中不存在的列是无效的SQL(准确地说，是HQL)。</p>\n<h5 id=\"高级功能\"><a href=\"#高级功能\" class=\"headerlink\" title=\"高级功能\"></a>高级功能</h5><h6 id=\"多组插入\"><a href=\"#多组插入\" class=\"headerlink\" title=\"多组插入\"></a>多组插入</h6><p>聚合或简单查询的结果可以输出到多个表甚至是hdfs(使用hdfs操作)上，例如，在按性别分类的同时，有一个需求是按年龄分类。一个可行的查询是这样的：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM pv_users</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> pv_gender_sum</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> pv_users.gender, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\">  <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.gender</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">DIRECTORY</span> <span class=\"string\">'/user/facebook/tmp/pv_age_sum'</span></span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> pv_users.age, <span class=\"keyword\">count</span>(<span class=\"keyword\">DISTINCT</span> pv_users.userid)</span><br><span class=\"line\">  <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> pv_users.age;</span><br></pre></td></tr></table></figure>\n<h6 id=\"map端聚合\"><a href=\"#map端聚合\" class=\"headerlink\" title=\"map端聚合\"></a>map端聚合</h6><p>hive.map.aggr控制我们如何做聚合，默认为false，如果它被设置为true，Hive将在map任务直接做的第一级集合。<br>这通常提供了更好的效率，但可能需要更多的内存来运行工作。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span> hive.map.aggr=<span class=\"literal\">true</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(*) <span class=\"keyword\">FROM</span> table2;</span><br></pre></td></tr></table></figure>\n<p>注意在不包含<a href=\"https://issues.apache.org/jira/browse/HIVE-287\">HIVE-287</a>的Hive版本中，需要使用<code>COUNT(1)</code>代替<code>COUNT(*)</code></p>\n<h6 id=\"Grouping-Sets-Cubes-Rollups-和GROUPING-ID函数\"><a href=\"#Grouping-Sets-Cubes-Rollups-和GROUPING-ID函数\" class=\"headerlink\" title=\"Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数\"></a>Grouping Sets, Cubes, Rollups, 和GROUPING__ID函数</h6><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">版本：</span><br><span class=\"line\">rouping <span class=\"keyword\">sets</span>, CUBE <span class=\"comment\">and ROLLUP</span>操作符<span class=\"comment\">,</span>和<span class=\"comment\">GROUPING__ID</span>函数在<span class=\"comment\">Hive 0.10.0</span>版本中加入。</span><br></pre></td></tr></table></figure>\n<p>见<a href=\"###增强聚合、多维数据集、分组和汇总\">增强聚合，多维数据集，分组和汇总</a>获取有关这些聚合操作的详细信息。</p>\n<p>另见JIRAs：<br><a href=\"https://issues.apache.org/jira/browse/HIVE-2397\">HIVE-2397</a>group by支持rollup选项<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3433\">HIVE-3433</a>实现CUBE和ROLLUP操作符<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3471\">HIVE-3471</a>实现Hive sets分组集<br><a href=\"https://issues.apache.org/jira/browse/HIVE-3613\">HIVE-3613</a>实现GROUPING_ID函数</p>\n<h4 id=\"Sort-Distribute-Cluster-Order-By\"><a href=\"#Sort-Distribute-Cluster-Order-By\" class=\"headerlink\" title=\"Sort/Distribute/Cluster/Order By\"></a>Sort/Distribute/Cluster/Order By</h4><p>描述select子句中的ORDER BY, SORT BY, CLUSTER BY, 和DISTRIBUTE BY的语法。</p>\n<h5 id=\"Order-By语法\"><a href=\"#Order-By语法\" class=\"headerlink\" title=\"Order By语法\"></a>Order By语法</h5><p>Hive QL中的Order By语法跟SQL语言中的ORDER BY类似。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colOrder: ( <span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span> )</span><br><span class=\"line\">colNullOrder: (NULLS FIRST | NULLS LAST)           -- (Note: Available <span class=\"keyword\">in</span> Hive <span class=\"number\">2.1</span>.<span class=\"number\">0</span> <span class=\"keyword\">and</span> later)</span><br><span class=\"line\">orderBy: <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> colName colOrder? colNullOrder? (<span class=\"string\">','</span> colName colOrder? colNullOrder?)*</span><br><span class=\"line\">query: <span class=\"keyword\">SELECT</span> expression (<span class=\"string\">','</span> expression)* <span class=\"keyword\">FROM</span> src orderBy</span><br></pre></td></tr></table></figure>\n<p>“order by”子句具有很多局限性，在严格模式(设置了<code>hive.mapred.mode=strict</code>)中，order by子句后需要跟上<code>limit</code>子句，若将<code>hive.mapred.mode</code>设置为<code>nonstrict</code>则不需要<code>limit</code>子句。原因是，为了将所有的记录排序，只能使用一个reducer，如果数据量太大，单个reducer将花费很长的时间才能执行完成。</p>\n<p>需要注意的是列由列名指定，则不是位置编号，可以在0.11.0及更新版本中使用配置<code>hive.groupby.orderby.position.alias</code>为<code>true</code>（默认为false）来启用位置编号。<br>默认的排序顺序是升序（ASC）。<br>在Hive 2.1.0及更高版本中，支持空排序，默认空排序顺序为ASC顺序是NULLS FIRST，而默认为空的倒序排列顺序是NULLS LAST。</p>\n<h5 id=\"Sort-By语法\"><a href=\"#Sort-By语法\" class=\"headerlink\" title=\"Sort By语法\"></a>Sort By语法</h5><p>Sort By语法跟SQL语言中的ORDER BY类似。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">colOrder: ( <span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span> )</span><br><span class=\"line\">sortBy: SORT <span class=\"keyword\">BY</span> colName colOrder? (<span class=\"string\">','</span> colName colOrder?)*</span><br><span class=\"line\">query: <span class=\"keyword\">SELECT</span> expression (<span class=\"string\">','</span> expression)* <span class=\"keyword\">FROM</span> src sortBy</span><br></pre></td></tr></table></figure>\n<p>Hive在将数据传递到reducer之前，使用sort by对行进行排序，排列顺序取决于列的类型，如果列是numeric类型，则按数值顺序排序，如果是string类型，则按字典顺序排序。</p>\n<h5 id=\"Sort-By和Order-By的区别\"><a href=\"#Sort-By和Order-By的区别\" class=\"headerlink\" title=\"Sort By和Order By的区别\"></a>Sort By和Order By的区别</h5><p>“order by”和”sort by”的区别在于，前者对所有输出进行排序，后者仅对一个reducer中的输出进行排序，如果存在多个reducer，sort by只能进行部分排序。</p>\n<p>注意：可能会对Sort By和CLUSTER BY的区别感到困惑，CLUSTER BY在有多个reducer的情况下，为了将数据均衡地分布数据，将数据按字段进行分区并排序。</p>\n<p>基本上，在每个reducer中的数据将会按照用户指定的字段进行排序。如下示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">key</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">FROM</span> src <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">key</span> <span class=\"keyword\">ASC</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<p>这个查询可能有2个reducer，输出分别是：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"symbol\">3 </span>  <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"symbol\">9 </span>  <span class=\"number\">1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"symbol\">0 </span>  <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"symbol\">1 </span>  <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"symbol\">2 </span>  <span class=\"number\">5</span></span><br></pre></td></tr></table></figure>\n<p>在一次transform后，变量将会被认为是string类型，意味着数值型将按照字典序进行排序，为了克服这种情况，在使用sort by之前需要使用一个带有cast的子查询，如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (FROM (FROM src</span><br><span class=\"line\">            <span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">value</span>)</span><br><span class=\"line\">            <span class=\"keyword\">USING</span> <span class=\"string\">'mapper'</span></span><br><span class=\"line\">            <span class=\"keyword\">AS</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>) mapped</span><br><span class=\"line\">      <span class=\"keyword\">SELECT</span> <span class=\"keyword\">cast</span>(<span class=\"keyword\">value</span> <span class=\"keyword\">as</span> <span class=\"keyword\">double</span>) <span class=\"keyword\">AS</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">cast</span>(<span class=\"keyword\">count</span> <span class=\"keyword\">as</span> <span class=\"built_in\">int</span>) <span class=\"keyword\">AS</span> <span class=\"keyword\">count</span></span><br><span class=\"line\">      <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>) sorted</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">value</span>, <span class=\"keyword\">count</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'reducer'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> whatever</span><br></pre></td></tr></table></figure>\n<h5 id=\"Cluster-By和Distribute-By语法\"><a href=\"#Cluster-By和Distribute-By语法\" class=\"headerlink\" title=\"Cluster By和Distribute By语法\"></a>Cluster By和Distribute By语法</h5><p>Cluster By和Distribute By主要跟<a href=\"####Transform和map-reduce脚本\">Transform/Map-Reduce脚本</a>一起使用，但是有时候为了给后续的子查询分区并排序时，这是非常有用的。<br>Cluster By可以看作是Distribute By和Sort By的合集。<br>Hive使用Distribute By指定的列将数据分发到reducer中，相同的值将会放到同一个reducer中，但是Distribute By不保证clustering或sorting属性。</p>\n<p>例如，我们Distribute By X以下5行记录到2个reducer中：</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x2</span><br><span class=\"line\">x4</span><br><span class=\"line\">x3</span><br><span class=\"line\">x1</span><br></pre></td></tr></table></figure>\n<p>reducer 1</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x2</span><br><span class=\"line\">x1</span><br></pre></td></tr></table></figure>\n<p>reducer 2</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x4</span></span><br><span class=\"line\">x3</span><br></pre></td></tr></table></figure>\n<p>X相同的值x1分发到reducer1 中，但不能保存其在相邻位置。</p>\n<p>如果我们使用Cluster By x，这两个reducer将会进行进一步排序。<br>reducer 1</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x1</span></span><br><span class=\"line\">x1</span><br><span class=\"line\">x2</span><br></pre></td></tr></table></figure>\n<p>reducer 2</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">x3</span></span><br><span class=\"line\">x4</span><br></pre></td></tr></table></figure>\n<p>可以使用Distribute By和Sort By来代替Cluster By，而且分区列和排序列可以是不同的列。</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 CLUSTER <span class=\"keyword\">BY</span> col1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">DISTRIBUTE</span> <span class=\"keyword\">BY</span> col1</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> col1, col2 <span class=\"keyword\">FROM</span> t1 <span class=\"keyword\">DISTRIBUTE</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">SORT</span> <span class=\"keyword\">BY</span> col1 <span class=\"keyword\">ASC</span>, col2 <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP ( pv_users.userid, pv_users.<span class=\"built_in\">date</span> )</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> c1, c2, c3</span><br><span class=\"line\">  DISTRIBUTE <span class=\"keyword\">BY</span> c2</span><br><span class=\"line\">  SORT <span class=\"keyword\">BY</span> c2, c1) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE ( map_output.c1, map_output.c2, map_output.c3 )</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Transform和map-reduce脚本\"><a href=\"#Transform和map-reduce脚本\" class=\"headerlink\" title=\"Transform和map-reduce脚本\"></a>Transform和map-reduce脚本</h4><p>用户可以指定自定义的mapper和reducer，例如，为了执行自定义的mapper-map_script和自定义的reducer-reducer_script，可以使用如下带有TRANSFORM子句的命令嵌入map和reduce脚本。</p>\n<p>默认情况下，在传输给自定义脚本时，列将会转换成string类型，并且以tab作为分隔符，同样的，为了区分空字符串，所有的NULL值将被转换成\\N字符。自定义脚本的标准输出是tab分隔的string列，任何包括\\N的值将被认为是NULL, string类型的结果将转换成表定义中的列类型。用户自定义脚本可以输出debug信息到标准错误，这将在Hadoop任务详细信息页面上显示。这些默认值可以被ROW FORMAT覆盖。</p>\n<p>在windows下，使用”cmd /c your_script”。</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告</span><br><span class=\"line\">在transformation之前处理任意string列是你的责任，如果有string列包含tab，需要使用[<span class=\"string\">REGEXP_REPLACE</span>](<span class=\"link\">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF#LanguageManualUDF-StringFunctions</span>)并替换tab为其他字符。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">警告</span><br><span class=\"line\">从形式上，<span class=\"built_in\">MAP</span><span class=\"attr\">...</span>和REDUCE<span class=\"attr\">...</span>是<span class=\"keyword\">SELECT</span> TRANSFORM ( <span class=\"attr\">...</span> )的语法。换句话说，它们作为阅读查询语句的注释或说明。注意：使用这些关键字是危险的，如，输出<span class=\"string\">\"REDUCE\"</span> 不能强制转换成reduce，输出<span class=\"string\">\"MAP\"</span>不能强制转换成<span class=\"built_in\">map</span>。</span><br></pre></td></tr></table></figure>\n<p>另请参阅<a href=\"#### Sort/Distribute/Cluster/Order By\"> Sort By / Cluster By / Distribute By </a>和<a href=\"http://dev.bizo.com/2009/10/hive-map-reduce-in-java.html\">Larry Ogrodnek’s的博客</a></p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">clusterBy: CLUSTER <span class=\"keyword\">BY</span> colName (<span class=\"string\">','</span> colName)*</span><br><span class=\"line\">distributeBy: DISTRIBUTE <span class=\"keyword\">BY</span> colName (<span class=\"string\">','</span> colName)*</span><br><span class=\"line\">sortBy: SORT <span class=\"keyword\">BY</span> colName (<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>)? (<span class=\"string\">','</span> colName (<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>)?)*</span><br><span class=\"line\"> </span><br><span class=\"line\">rowFormat</span><br><span class=\"line\">  : ROW FORMAT</span><br><span class=\"line\">    (DELIMITED [FIELDS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [COLLECTION ITEMS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [MAP KEYS TERMINATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [ESCAPED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">               [LINES SEPARATED <span class=\"keyword\">BY</span> char]</span><br><span class=\"line\">     |</span><br><span class=\"line\">     SERDE serde_name [<span class=\"keyword\">WITH</span> SERDEPROPERTIES</span><br><span class=\"line\">                            property_name=property_value,</span><br><span class=\"line\">                            property_name=property_value, ...])</span><br><span class=\"line\"> </span><br><span class=\"line\">outRowFormat : rowFormat</span><br><span class=\"line\">inRowFormat : rowFormat</span><br><span class=\"line\">outRecordReader : RECORDREADER className</span><br><span class=\"line\"> </span><br><span class=\"line\">query:</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> src</span><br><span class=\"line\">    MAP expression (<span class=\"string\">','</span> expression)*</span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_map_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\">    ( clusterBy? | distributeBy? sortBy? ) src_alias</span><br><span class=\"line\">  )</span><br><span class=\"line\">  REDUCE expression (<span class=\"string\">','</span> expression)*</span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_reduce_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> src</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> TRANSFORM <span class=\"string\">'('</span> expression (<span class=\"string\">','</span> expression)* <span class=\"string\">')'</span></span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_map_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br><span class=\"line\">    ( clusterBy? | distributeBy? sortBy? ) src_alias</span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM <span class=\"string\">'('</span> expression (<span class=\"string\">','</span> expression)* <span class=\"string\">')'</span></span><br><span class=\"line\">    (inRowFormat)?</span><br><span class=\"line\">    <span class=\"keyword\">USING</span> <span class=\"string\">'my_reduce_script'</span></span><br><span class=\"line\">    ( <span class=\"keyword\">AS</span> colName (<span class=\"string\">','</span> colName)* )?</span><br><span class=\"line\">    (outRowFormat)? (outRecordReader)?</span><br></pre></td></tr></table></figure>\n<p>标准SQL不支持TRANSFORM，TRANSFORM子句在Hive 0.13.0及<a href=\"https://issues.apache.org/jira/browse/HIVE-6415\">HIVE-6415</a>的后续版本中，通过配置<a href=\"https://cwiki.apache.org/confluence/display/Hive/SQL+Standard+Based+Hive+Authorization\">SQL standard based authorization</a>禁用。</p>\n<p>TRANSFORM示例：<br>例1：</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP pv_users.userid, pv_users.<span class=\"built_in\">date</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> dt, uid</span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> dt) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE map_output.dt, map_output.uid</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(pv_users.userid, pv_users.<span class=\"built_in\">date</span>)</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> dt, uid</span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> dt) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(map_output.dt, map_output.uid)</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<p>例2:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM (</span><br><span class=\"line\">  FROM src</span><br><span class=\"line\">  <span class=\"keyword\">SELECT</span> TRANSFORM(src.key, src.value) <span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> SERDE <span class=\"string\">'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"string\">'/bin/cat'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> (tkey, tvalue) <span class=\"keyword\">ROW</span> <span class=\"keyword\">FORMAT</span> SERDE <span class=\"string\">'org.apache.hadoop.hive.contrib.serde2.TypedBytesSerDe'</span></span><br><span class=\"line\">  RECORDREADER <span class=\"string\">'org.apache.hadoop.hive.contrib.util.typedbytes.TypedBytesRecordReader'</span></span><br><span class=\"line\">) tmap</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> OVERWRITE <span class=\"keyword\">TABLE</span> dest1 <span class=\"keyword\">SELECT</span> tkey, tvalue</span><br></pre></td></tr></table></figure>\n<h5 id=\"缺少schema的map-reduce脚本\"><a href=\"#缺少schema的map-reduce脚本\" class=\"headerlink\" title=\"缺少schema的map-reduce脚本\"></a>缺少schema的map-reduce脚本</h5><p>如果在USING my_script之后没有AS子句，Hive假定脚本的输出包括两个部分，key是第一个tab之前的部分，值是第一个tab之后的部分。注意这与指定AS key, value不同，因为在那种情况下，如果存在多个tab，value将仅包含第一个tab第二个tab之间的部分。</p>\n<p>注意我们可以直接使用CLUSTER BY key，而不在脚本中指定输出格式。</p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> (</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> pv_users</span><br><span class=\"line\">  MAP pv_users.userid, pv_users.<span class=\"built_in\">date</span></span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'map_script'</span></span><br><span class=\"line\">  CLUSTER <span class=\"keyword\">BY</span> <span class=\"keyword\">key</span>) map_output</span><br><span class=\"line\">INSERT OVERWRITE TABLE pv_users_reduced</span><br><span class=\"line\">  REDUCE map_output.<span class=\"keyword\">key</span>, map_output.value</span><br><span class=\"line\">  <span class=\"keyword\">USING</span> <span class=\"comment\">'reduce_script'</span></span><br><span class=\"line\">  <span class=\"keyword\">AS</span> <span class=\"built_in\">date</span>, count;</span><br></pre></td></tr></table></figure>\n<h5 id=\"TRANSFORM的输出\"><a href=\"#TRANSFORM的输出\" class=\"headerlink\" title=\"TRANSFORM的输出\"></a>TRANSFORM的输出</h5><p>脚本的输出字段默认以string进行输入，例如：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">stuff</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'script'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> thing1, thing2</span><br></pre></td></tr></table></figure>\n<p>这将可以被强制转换为</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TRANSFORM(<span class=\"keyword\">stuff</span>)</span><br><span class=\"line\"><span class=\"keyword\">USING</span> <span class=\"string\">'script'</span></span><br><span class=\"line\"><span class=\"keyword\">AS</span> (thing1 <span class=\"built_in\">INT</span>, thing2 <span class=\"built_in\">INT</span>)</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作符和用户自定义函数-UDFS\"><a href=\"#操作符和用户自定义函数-UDFS\" class=\"headerlink\" title=\"操作符和用户自定义函数(UDFS)\"></a>操作符和用户自定义函数(UDFS)</h4><p>在Beeline或CLi下，使用如下命令来显示最近的文档：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SHOW</span> FUNCTIONS;</span><br><span class=\"line\"><span class=\"keyword\">DESCRIBE</span> <span class=\"keyword\">FUNCTION</span> &lt;function_name&gt;;</span><br><span class=\"line\"><span class=\"keyword\">DESCRIBE</span> <span class=\"keyword\">FUNCTION</span> <span class=\"keyword\">EXTENDED</span> &lt;function_name&gt;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">当UDF嵌套在UDF或function中时存在Bug。</span><br><span class=\"line\">当 <span class=\"code\">`hive.cache.expr.evaluation`</span>设置为<span class=\"code\">`true`</span>（默认）时，UDF嵌套在UDF或function中将会产生不正确的结果。这个bug会影响0.12.0, 0.13.0和0.13.1。0.14.0修复了这个bug([<span class=\"string\">HIVE-7314</span>](<span class=\"link\">https://issues.apache.org/jira/browse/HIVE-7314</span>).</span><br><span class=\"line\">这个问题与UDF的实现的getDisplayString方法有关，在Hive user mailing list中的相关[<span class=\"string\">讨论</span>](<span class=\"link\">http://mail-archives.apache.org/mod_mbox/hive-user/201407.mbox/%3cCAEWg7THU-Pr1Dfv_A8VS3Uz5t3ZyJvL0f-bebg4Zb3hXkK-CGQ@mail.gmail.com%3e</span>)</span><br></pre></td></tr></table></figure>\n<h5 id=\"内置操作符\"><a href=\"#内置操作符\" class=\"headerlink\" title=\"内置操作符\"></a>内置操作符</h5><h6 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h6><h6 id=\"算术运算符\"><a href=\"#算术运算符\" class=\"headerlink\" title=\"算术运算符\"></a>算术运算符</h6><h6 id=\"逻辑运算符\"><a href=\"#逻辑运算符\" class=\"headerlink\" title=\"逻辑运算符\"></a>逻辑运算符</h6><h6 id=\"复杂类型的运算符\"><a href=\"#复杂类型的运算符\" class=\"headerlink\" title=\"复杂类型的运算符\"></a>复杂类型的运算符</h6><h5 id=\"内置函数\"><a href=\"#内置函数\" class=\"headerlink\" title=\"内置函数\"></a>内置函数</h5><p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<p>###### </p>\n<h5 id=\"内置聚合函数\"><a href=\"#内置聚合函数\" class=\"headerlink\" title=\"内置聚合函数\"></a>内置聚合函数</h5><h5 id=\"内置生成表函数\"><a href=\"#内置生成表函数\" class=\"headerlink\" title=\"内置生成表函数\"></a>内置生成表函数</h5><h5 id=\"Grouping-and-Sorting-on\"><a href=\"#Grouping-and-Sorting-on\" class=\"headerlink\" title=\"Grouping and Sorting on\"></a>Grouping and Sorting on</h5><h5 id=\"UDF内部\"><a href=\"#UDF内部\" class=\"headerlink\" title=\"UDF内部\"></a>UDF内部</h5><h5 id=\"创建自定义的UDF\"><a href=\"#创建自定义的UDF\" class=\"headerlink\" title=\"创建自定义的UDF\"></a>创建自定义的UDF</h5><h4 id=\"XPath专用函数\"><a href=\"#XPath专用函数\" class=\"headerlink\" title=\"XPath专用函数\"></a>XPath专用函数</h4><h4 id=\"Joins\"><a href=\"#Joins\" class=\"headerlink\" title=\"Joins\"></a>Joins</h4><h4 id=\"Join优化\"><a href=\"#Join优化\" class=\"headerlink\" title=\"Join优化\"></a>Join优化</h4><h4 id=\"Union\"><a href=\"#Union\" class=\"headerlink\" title=\"Union\"></a>Union</h4><h4 id=\"横向视图\"><a href=\"#横向视图\" class=\"headerlink\" title=\"横向视图\"></a>横向视图</h4><h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><h3 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h3><h3 id=\"虚拟列\"><a href=\"#虚拟列\" class=\"headerlink\" title=\"虚拟列\"></a>虚拟列</h3><h3 id=\"窗口和分析函数\"><a href=\"#窗口和分析函数\" class=\"headerlink\" title=\"窗口和分析函数\"></a>窗口和分析函数</h3><h3 id=\"增强聚合、多维数据集、分组和汇总\"><a href=\"#增强聚合、多维数据集、分组和汇总\" class=\"headerlink\" title=\"增强聚合、多维数据集、分组和汇总\"></a>增强聚合、多维数据集、分组和汇总</h3><h2 id=\"程序语言：Hive-HPL-SQL\"><a href=\"#程序语言：Hive-HPL-SQL\" class=\"headerlink\" title=\"程序语言：Hive HPL/SQL\"></a>程序语言：Hive HPL/SQL</h2><h2 id=\"解释执行计划\"><a href=\"#解释执行计划\" class=\"headerlink\" title=\"解释执行计划\"></a>解释执行计划</h2>"}],"PostAsset":[{"_id":"source/_posts/java-core-jni/jni.png","slug":"jni.png","post":"cinb2xtm1000abgv08ejcz5sy","modified":0,"renderable":0},{"_id":"source/_posts/java-core-conception/conversion.png","slug":"conversion.png","post":"cinb2xt600000bgv03ys4fcie","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cinb2xt600000bgv03ys4fcie","category_id":"cinb2xt6s0003bgv0s5pcplpe","_id":"cinb2xt6x0007bgv0iw5ogsn7"},{"post_id":"cinb2xt6c0001bgv0htx6dqiq","category_id":"cinb2xt6v0005bgv04uyz4yhs","_id":"cinb2xt6y0009bgv0qqjdx24r"},{"post_id":"cinb2xtm1000abgv08ejcz5sy","category_id":"cinb2xtmf000fbgv0d8cgqndc","_id":"cinb2xtn7000nbgv0ur151t9w"},{"post_id":"cinb2xtn4000mbgv0bdfp7nsi","category_id":"cinb2xtn2000lbgv0vbkerpuw","_id":"cinb2xtnb000sbgv0zrredeu5"},{"post_id":"cinb2xtm6000cbgv0ppo70sa2","category_id":"cinb2xtn2000lbgv0vbkerpuw","_id":"cinb2xtnd000wbgv0v72d9pgo"},{"post_id":"cinb2xtmg000gbgv0sve8arbo","category_id":"cinb2xtn2000lbgv0vbkerpuw","_id":"cinb2xtnd000ybgv07yk2hh6g"},{"post_id":"cinb2xtmv000ibgv027p5xd2v","category_id":"cinb2xtn2000lbgv0vbkerpuw","_id":"cinb2xtnf0013bgv036loen96"},{"post_id":"cinb2xtn0000kbgv0du1cr6q1","category_id":"cinb2xtn2000lbgv0vbkerpuw","_id":"cinb2xtng0017bgv0k6hdvx7b"},{"post_id":"cirub9ogb0000g7v0dw855eq5","category_id":"cirub9ogw0003g7v0luxeqffg","_id":"cirub9oh40009g7v04xcpia46"},{"post_id":"cirub9ogf0001g7v0wbtdw2uu","category_id":"cirub9oh30007g7v06r2ikfap","_id":"cirub9oh6000dg7v05x34fe1r"},{"post_id":"cirub9ogx0004g7v09rmk1eij","category_id":"cirub9oh5000bg7v05pw18rsc","_id":"cirub9oh9000hg7v0f2osxfmi"},{"post_id":"cirub9oh00005g7v0py74hlqj","category_id":"cirub9oh7000fg7v01tb3fx7x","_id":"cirub9oha000jg7v0bq0g44hl"},{"post_id":"ciruc8szc0000hgv0hf3e2msj","category_id":"cirub9oh5000bg7v05pw18rsc","_id":"ciruc9pcu0002hgv0smu952df"}],"PostTag":[{"post_id":"cinb2xt600000bgv03ys4fcie","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xt6w0006bgv08f2xgqwc"},{"post_id":"cinb2xt6c0001bgv0htx6dqiq","tag_id":"cinb2xt6u0004bgv0tixroft6","_id":"cinb2xt6x0008bgv0tcc1q0sh"},{"post_id":"cinb2xtn4000mbgv0bdfp7nsi","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xtn9000qbgv0bxvlpji4"},{"post_id":"cinb2xtm1000abgv08ejcz5sy","tag_id":"cinb2xtmf000ebgv0uvc72vg9","_id":"cinb2xtna000rbgv05p8ucjwv"},{"post_id":"cinb2xtm1000abgv08ejcz5sy","tag_id":"cinb2xtmy000jbgv0gkioupgs","_id":"cinb2xtnc000vbgv0kbuokrzc"},{"post_id":"cinb2xtm6000cbgv0ppo70sa2","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xtnd000xbgv0t97s77mq"},{"post_id":"cinb2xtm6000cbgv0ppo70sa2","tag_id":"cinb2xtn7000obgv048j5zedc","_id":"cinb2xtne0010bgv0jfjj0iws"},{"post_id":"cinb2xtmg000gbgv0sve8arbo","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xtnf0012bgv0kb4ued91"},{"post_id":"cinb2xtmg000gbgv0sve8arbo","tag_id":"cinb2xtnc000ubgv0gxp1b6i6","_id":"cinb2xtnf0014bgv05zfz83ym"},{"post_id":"cinb2xtmv000ibgv027p5xd2v","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xtng0016bgv007jstnbv"},{"post_id":"cinb2xtmv000ibgv027p5xd2v","tag_id":"cinb2xtne0011bgv05qjgbcgx","_id":"cinb2xtng0018bgv0oyhfv25s"},{"post_id":"cinb2xtn0000kbgv0du1cr6q1","tag_id":"cinb2xt6j0002bgv0op81ywiv","_id":"cinb2xtnh0019bgv02meed66r"},{"post_id":"cinb2xtn0000kbgv0du1cr6q1","tag_id":"cinb2xtng0015bgv0kz9c0kk9","_id":"cinb2xtnh001abgv0r0wozb7f"},{"post_id":"cirub9ogb0000g7v0dw855eq5","tag_id":"cirub9ogj0002g7v0gw6u5tfo","_id":"cirub9oh40008g7v0evv1z1kx"},{"post_id":"cirub9ogf0001g7v0wbtdw2uu","tag_id":"cirub9oh20006g7v0kbp3fb6i","_id":"cirub9oh6000cg7v03fpu6xie"},{"post_id":"cirub9ogx0004g7v09rmk1eij","tag_id":"cirub9oh4000ag7v0mdzs1hc5","_id":"cirub9oh8000gg7v0iwrdpozr"},{"post_id":"cirub9oh00005g7v0py74hlqj","tag_id":"cirub9oh6000eg7v0yw6w184v","_id":"cirub9oha000ig7v0ruboiaqg"},{"post_id":"ciruc8szc0000hgv0hf3e2msj","tag_id":"cirub9oh4000ag7v0mdzs1hc5","_id":"ciruc9pct0001hgv0dmm0mc99"}],"Tag":[{"name":"Java","_id":"cinb2xt6j0002bgv0op81ywiv"},{"name":"hexo","_id":"cinb2xt6u0004bgv0tixroft6"},{"name":"java","_id":"cinb2xtmf000ebgv0uvc72vg9"},{"name":"jni","_id":"cinb2xtmy000jbgv0gkioupgs"},{"name":"集合","_id":"cinb2xtn7000obgv048j5zedc"},{"name":"io","_id":"cinb2xtnc000ubgv0gxp1b6i6"},{"name":"多线程","_id":"cinb2xtne0011bgv05qjgbcgx"},{"name":"nio","_id":"cinb2xtng0015bgv0kz9c0kk9"},{"name":"hadoop hive","_id":"cirub9ogj0002g7v0gw6u5tfo"},{"name":"js","_id":"cirub9oh20006g7v0kbp3fb6i"},{"name":"hive","_id":"cirub9oh4000ag7v0mdzs1hc5"},{"name":"mysql","_id":"cirub9oh6000eg7v0yw6w184v"}]}}